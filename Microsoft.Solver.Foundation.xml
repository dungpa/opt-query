<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Solver.Foundation</name>
    </assembly>
    <members>
        <member name="T:Microsoft.SolverFoundation.Common.License">
            <summary>Solver Foundation license and SKU information.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.Sku">
            <summary>SKU information.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.NonzeroLimit">
            <summary>Nonzero limit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.VariableLimit">
            <summary>Variable limit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.MipVariableLimit">
            <summary>MIP variable limit.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.MipRowLimit">
            <summary>MIP row limit.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.MipNonzeroLimit">
            <summary>MIP nonzero limit.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.CspTermLimit">
            <summary>CSP term count limit.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.License.Expiration">
            <summary>Expiration of evaluation period (if any).
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Aborted">
            <summary>
              Looks up a localized string similar to Aborted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ABoundConstraintIsNeitherAUpperBoundConstraintNorALowerBoundConstraint">
            <summary>
              Looks up a localized string similar to A bound constraint is neither a upper-bound constraint nor a lower-bound constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AcceptedContractedCount0">
            <summary>
              Looks up a localized string similar to Accepted contracted: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AcceptedExpandedCount0">
            <summary>
              Looks up a localized string similar to Accepted expanded: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AcceptedReflectedCount0">
            <summary>
              Looks up a localized string similar to Accepted reflected: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ActualSizeOfMatrixTooBig0">
            <summary>
              Looks up a localized string similar to Actual size of matrix is too big (more than {1}).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AddChange01">
            <summary>
              Looks up a localized string similar to AddChange {0} {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AddingFalseAsConstraint">
            <summary>
              Looks up a localized string similar to Trying to add constant False as a constraint. The model is infeasible.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AfterFillNonZeros0">
            <summary>
              Looks up a localized string similar to After-fill non-zeros {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AllBindableParametersShouldHaveBindClause">
            <summary>
              Looks up a localized string similar to All bindable parameters should have a binding clause in the Data Binding section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AllVariablesShouldBeActiveForTheRow">
            <summary>
              Looks up a localized string similar to All variables should be active for the row..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AlreadySolving">
            <summary>
              Looks up a localized string similar to Solve is in progress .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Argument0ToIndexOperationIsOfAnInvalidType">
            <summary>
              Looks up a localized string similar to Argument {0} to index operation is of an invalid type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ArgumentIsNotATuple">
            <summary>
              Looks up a localized string similar to Argument is not a tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AtLeast1ArgumentExpected">
            <summary>
              Looks up a localized string similar to At least one argument expected.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AtMostMofNExpectsBooleanTerms">
            <summary>
              Looks up a localized string similar to AtMostMofN expects Boolean Terms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AttributesForSymbolAreLocked">
            <summary>
              Looks up a localized string similar to Attributes for symbol &apos;{0}&apos; are locked..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.AverageDepthEstimatedTreeSize01">
            <summary>
              Looks up a localized string similar to   average depth / estimated tree size : {0} {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadAnnotation">
            <summary>
              Looks up a localized string similar to Bad annotation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadConstraint">
            <summary>
              Looks up a localized string similar to Bad constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadIterator">
            <summary>
              Looks up a localized string similar to Bad iterator.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadIterator0">
            <summary>
              Looks up a localized string similar to Bad iterator {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadKind">
            <summary>
              Looks up a localized string similar to Bad Kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadMark">
            <summary>
              Looks up a localized string similar to Bad mark.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadOMLName">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; contains invalid characters. Names must begin with a letter or underscore, and contain only letters, numbers, and underscores..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadRule">
            <summary>
              Looks up a localized string similar to Bad rule.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadTextVersionInNewLineToken">
            <summary>
              Looks up a localized string similar to Bad TextVersion in new-line token.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BadValueKind">
            <summary>
              Looks up a localized string similar to Bad ValueKind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BinddataClausesShouldHaveParameterAndInput">
            <summary>
              Looks up a localized string similar to Bind data clauses should have parameter name and input string.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BindDataInErrorEmptyCellFormat">
            <summary>
              Looks up a localized string similar to Cannot bind data to {0} from {1}. {1} either represents multiple cells or an empty cell..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BindDataInErrorMissingCellFormat">
            <summary>
              Looks up a localized string similar to Cannot bind data to {0}, please specify cell ranges..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BooleanGoal">
            <summary>
              Looks up a localized string similar to Boolean functions cannot be used as goals. Consider changing to Integer..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BoundedVidWasNeitherRowNorVar">
            <summary>
              Looks up a localized string similar to Bounded vid was neither a row nor a variable..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BoundsForDiscreteUniformDistriutionNeedsToBeIntegers">
            <summary>
              Looks up a localized string similar to Bounds for discrete uniform distribution need to be integers.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.BundariesAreNotNumeric">
            <summary>
              Looks up a localized string similar to Minimum or maximum boundaries are not numeric.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CalledOnNonType">
            <summary>
              Looks up a localized string similar to {0} called on non-type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CalledOnNull">
            <summary>
              Looks up a localized string similar to {0} called on &lt;null&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotAddCutXToModel0">
            <summary>
              Looks up a localized string similar to Cannot add cut: {0} to the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotBindReadOnlyDataTableForOutput">
            <summary>
              Looks up a localized string similar to Cannot bind read-only data table for output.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotCloneTerm">
            <summary>
              Looks up a localized string similar to Given Term cannot be cloned.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotCreateDecisionBindingOnDecisionNotAddedToAModel">
            <summary>
              Looks up a localized string similar to Cannot create decision binding on decision &apos;{0}&apos; because it is not added to any model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotCreateDecisionBindingOnDecisionNotAddedToRootModel">
            <summary>
              Looks up a localized string similar to Cannot create decision binding on decision &apos;{0}&apos; because it is not added to the root model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotEnumerateAnInfiniteNumberOfScenarios">
            <summary>
              Looks up a localized string similar to Cannot enumerate an infinite number of scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotEnumerateScenariosForBinomialValueProbabilityOfAScenarioWithSuccessfulTrialsIsInsufficientlyLarge">
            <summary>
              Looks up a localized string similar to Cannot enumerate scenarios for binomial value. Probability of a scenario with {0} successful trials is insufficiently large..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CanNotFindDomain">
            <summary>
              Looks up a localized string similar to Cannot find domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotFindIndexesForDecision0">
            <summary>
              Looks up a localized string similar to Cannot find indexes for decision {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotFindTheConstraintInTheModel">
            <summary>
              Looks up a localized string similar to Cannot find the constraint in the model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotFindTheDecisionAndIndexesInTheModel0">
            <summary>
              Looks up a localized string similar to Cannot find the decision in the model: {0}.  Make sure that the decision has been added to the model and that it is used in at least one goal or constraint..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotFindVirtualPathExtensionFromWCFHost">
            <summary>
              Looks up a localized string similar to Cannot find virtual path extension from WCF host..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotImportConstantParameter">
            <summary>
              Looks up a localized string similar to Cannot import constant parameters..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotImportForeachDecision">
            <summary>
              Looks up a localized string similar to Cannot import Foreach decisions..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotImportNonConstantIterator">
            <summary>
              Looks up a localized string similar to Cannot import non-constant iterators..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotImportNonSetIterator">
            <summary>
              Looks up a localized string similar to Cannot import non-Set iterators..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotIndexNonDecision">
            <summary>
              Looks up a localized string similar to Cannot index non-Decisions..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotRemove0BecauseItIsUsed">
            <summary>
              Looks up a localized string similar to Cannot remove {0} because it is being used..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotRepresentAsAnInteger">
            <summary>
              Looks up a localized string similar to Cannot represent {0} as an integer.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotReuseDecision0InADifferentModel">
            <summary>
              Looks up a localized string similar to Cannot reuse decision {0} in a different model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotReuseParameter0InADifferentModel">
            <summary>
              Looks up a localized string similar to Cannot reuse parameter {0} in a different model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotReuseSet0InADifferentModel">
            <summary>
              Looks up a localized string similar to Cannot reuse set {0} in a different model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotSetBoundsOnAQuadraticGoal">
            <summary>
              Looks up a localized string similar to Cannot set bounds on a quadratic goal..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotSolve">
            <summary>
              Looks up a localized string similar to Cannot use IntegerSolver to solve a non-integer model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotSolveBecauseThereIsNoActiveModel">
            <summary>
              Looks up a localized string similar to Cannot solve because there is no active model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CanNotSpecifyDomainAnyToParameter">
            <summary>
              Looks up a localized string similar to Cannot specify Domain.Any for a parameter..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotUseIdenticalOrSet">
            <summary>
              Looks up a localized string similar to Cannot use &apos;Identical&apos; (&apos;===&apos;) or Set (&apos;=&apos;) in constraints - try using &apos;Equal&apos; (&apos;==&apos;)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotUseThisTerm">
            <summary>
              Looks up a localized string similar to Cannot use this term. Only Decisions, Parameters and Constraints can be used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CannotUseThisTerm0">
            <summary>
              Looks up a localized string similar to Cannot use the term (&apos;{0}&apos;). Only Decisions, Parameters and Constraints can be used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CanTChangeCoefficientsForRowVariables">
            <summary>
              Looks up a localized string similar to Cannot change coefficients for row variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CanTMixExpressionFromDifferentRewriteSystems">
            <summary>
              Looks up a localized string similar to Cannot mix expressions from different RewriteSystems.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CloneInvalidTerm">
            <summary>
              Looks up a localized string similar to Invalid term to clone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CloneUnsupportedDomain">
            <summary>
              Looks up a localized string similar to Cannot create IntegerSolver instance because the model uses an unsupported Domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ClrObjectWrapperException0">
            <summary>
              Looks up a localized string similar to ClrObjectWrapper exception: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CoefficientForVariableInASOSRowCannotBeZero">
            <summary>
              Looks up a localized string similar to Coefficient for variable in a SOS row cannot be zero.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ColumnCompressedSparseMatrixDoesNotSupportElementInsertion">
            <summary>
              Looks up a localized string similar to ColumnCompressedSparseMatrix does not support element insertion.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ColumnIndexesDidNotSortCorrectly">
            <summary>
              Looks up a localized string similar to column indexes did not sort correctly.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComparisonsShouldHave2Arguments">
            <summary>
              Looks up a localized string similar to Comparisons should have two or more arguments.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Complete">
            <summary>
              Looks up a localized string similar to Complete.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeConstraintNotSupported">
            <summary>
              Looks up a localized string similar to CspComposite does not support this constraint .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeDomainIncompatible">
            <summary>
              Looks up a localized string similar to The composite domains of the input of this function are not compatible .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeDomainNotSupported">
            <summary>
              Looks up a localized string similar to The function does not support composite variables as input..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeDuplicateFields">
            <summary>
              Looks up a localized string similar to Field has been added to this composite .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeFieldArityZero">
            <summary>
              Looks up a localized string similar to Arity of a field in the composite cannot be less than or equal to 0 .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeFroze">
            <summary>
              Looks up a localized string similar to Composite cannot be changed since variables of this composite have been created .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeIndexOutOfRange">
            <summary>
              Looks up a localized string similar to The index to the field of the composite is out of range .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeInvalidFieldReference">
            <summary>
              Looks up a localized string similar to Specified field does not exist in this composite .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeUnknownInputs">
            <summary>
              Looks up a localized string similar to Terms created in a CspComposite must use other terms created in the same CspComposite as inputs.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CompositeVarGetValueNotSupported">
            <summary>
              Looks up a localized string similar to Cannot use GetValue to retrieve value of a composite variable. Need to retrieve the values from its fields manually .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputationalProgressOfHSDSolver">
             <summary>
               Looks up a localized string similar to 
            Computational progress of HSD solver:
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputeStatisticsBoolVars010">
            <summary>
              Looks up a localized string similar to Number of Bool vars:              {0,-10} .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputeStatisticsConstraints010">
             <summary>
               Looks up a localized string similar to Number of constraints:            {0,-10}
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputeStatisticsDelaySinceStart0Ms">
             <summary>
               Looks up a localized string similar to Delay since start:       {0}ms
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputeStatisticsIntVars010">
            <summary>
              Looks up a localized string similar to Number of Int vars:               {0,-10} .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ComputeStatisticsUserdefined08">
             <summary>
               Looks up a localized string similar to (user defined: {0,8})
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ConditionOfForEachIsNotConstant">
            <summary>
              Looks up a localized string similar to Condition of ForEach is not constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ConeType0NotSupported">
            <summary>
              Looks up a localized string similar to Cone type {0} is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ConstantValueIsNotAnInteger">
            <summary>
              Looks up a localized string similar to Constant value is not an integer or a Boolean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ConstantValuesMayNotBeRedefined">
            <summary>
              Looks up a localized string similar to Constant values may not be redefined..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ConstraintLabelAlreadyExists">
            <summary>
              Looks up a localized string similar to Constraint label already exists..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotFindStochasticCoreFileOrDirectory0">
            <summary>
              Looks up a localized string similar to Could not find stochastic core file or directory {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotGetDoubleValue">
            <summary>
              Looks up a localized string similar to Could not get double value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotParseMPSModel">
            <summary>
              Looks up a localized string similar to Failed to parse MPS model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotParseOMLModel0">
            <summary>
              Looks up a localized string similar to Failed to parse OML model. Expression: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotParseSMPSModel">
            <summary>
              Looks up a localized string similar to Failed to parse SMPS model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldNotPrintSensitivityValue">
            <summary>
              Looks up a localized string similar to Cannot print sensitivity value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CouldntFindASolverForTheModel">
            <summary>
              Looks up a localized string similar to OML could not find a solver for the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CqnDashes">
            <summary>
              Looks up a localized string similar to ----------------------------------------------------------------------------.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CqnSolverRequiresBothEvaluatorsToBeSpecifiedBeforeCallingSolve">
            <summary>
              Looks up a localized string similar to CompactQuasiNewtonSolver requires both FunctionEvaluator and GradientEvaluator to be specified before calling solve..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CqnTraceIteration0123">
            <summary>
              Looks up a localized string similar to {0,0:000}               {1,0:0.0000e+00}   {2,0:0000}                    {3}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CqnTraceIterationHeader">
            <summary>
              Looks up a localized string similar to Iteration count   New value    Evaluation call count   Termination criterion.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CqnTraceStarting012">
            <summary>
              Looks up a localized string similar to Starting          {0,0:0.0000e+00}   {1,0:0000}                    {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CSPSolverCantProcessTheModel01">
            <summary>
              Looks up a localized string similar to CSP solver cannot process the model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CSPSolverDoesNotSupportNonIntegerValues">
            <summary>
              Looks up a localized string similar to CSP solver does not support non-integer values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CurrentlyOnlyTuplesWhichIsUsedAsARandomParameterSupportsIndexing">
            <summary>
              Looks up a localized string similar to Indexed Tuples can only be used for random Parameters..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CutGenException">
            <summary>
              Looks up a localized string similar to Cannot perform cut generation in a multi-threaded environment .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.CutLowerUpperEntryCount012">
            <summary>
              Looks up a localized string similar to Lower: {0}, Upper: {1}, Entry count: {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Cycle01">
            <summary>
              Looks up a localized string similar to Cycle! {0} {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DataBindingFailedForParameter012">
            <summary>
              Looks up a localized string similar to Data binding failed for parameter {0} because {2} is not a valid index for set {1}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecimalValueOutOfRange">
            <summary>
              Looks up a localized string similar to Decimal value out of range .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecisionsCannotBeDisabled">
            <summary>
              Looks up a localized string similar to Decisions cannot be disabled.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Decomposition">
            <summary>
              Looks up a localized string similar to Decomposition.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecompositionCannotBeApplied">
            <summary>
              Looks up a localized string similar to Decomposition cannot be applied because the master model is unbounded.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecompositionCannotBeAppliedInfiniteBound">
            <summary>
              Looks up a localized string similar to Decomposition cannot be applied as there is a decision which participates only in second stage constraints, and has an infinite bound..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecompositionGap0">
            <summary>
              Looks up a localized string similar to Decomposition Gap: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DecompositionIterations">
            <summary>
              Looks up a localized string similar to Decomposition Iterations: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DefaultValueShouldBeDefiniteNumber">
            <summary>
              Looks up a localized string similar to defaultValue should be a definite number.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DelegateOfFunctionIsNeeded">
            <summary>
              Looks up a localized string similar to A gradient calculation function must be specified before calling Solve..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DeterministicEquivalent">
            <summary>
              Looks up a localized string similar to Deterministic Equivalent.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Dimensions">
            <summary>
              Looks up a localized string similar to Dimensions = .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Dimensions0">
            <summary>
              Looks up a localized string similar to Dimensions = {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DirectiveCannotLocateSolver">
            <summary>
              Looks up a localized string similar to Given directive {0} cannot locate a solver that has the capability to solve the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DirectiveRequired">
            <summary>
              Looks up a localized string similar to At least one directive is required.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisolverBooleanTermExpected">
            <summary>
              Looks up a localized string similar to Unexpected Term kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisolverCantProcessTheModel">
            <summary>
              Looks up a localized string similar to IntegerSolver can&apos;t process the model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisolverIntegerTermExpected">
            <summary>
              Looks up a localized string similar to Unexpected Term kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisolverTermExpected">
            <summary>
              Looks up a localized string similar to Unexpected Term kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesAdditionRatio">
            <summary>
              Looks up a localized string similar to AdditionRatio.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesDensestVariableConnectedTo0OfConstraints">
            <summary>
              Looks up a localized string similar to -&gt; Densest variable connected to {0}% of constraints..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverDomainSizeAndAllVars">
            <summary>
              Looks up a localized string similar to Histogram over domain size and all vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverDomainSizeAndUserDefinedVars">
            <summary>
              Looks up a localized string similar to Histogram over domain size and user-defined vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverNumberOfConstraintsAndAllVars">
            <summary>
              Looks up a localized string similar to Histogram over number of constraints and all vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverNumberOfConstraintsAndBoolVars">
            <summary>
              Looks up a localized string similar to Histogram over number of constraints and bool vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverNumberOfConstraintsAndIntegerVars">
            <summary>
              Looks up a localized string similar to Histogram over number of constraints and integer vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistogramOverNumberOfConstraintsAndUserDefinedVars">
            <summary>
              Looks up a localized string similar to Histogram over number of constraints and user-defined vars:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesHistograms">
            <summary>
              Looks up a localized string similar to Histograms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesOccurenceOfConstraintsRatioCountAllConstraints">
            <summary>
              Looks up a localized string similar to Occurrence of Constraints (Ratio [= Count/AllConstraints]).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesSmallLarge">
            <summary>
              Looks up a localized string similar to Small ----------- Large.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesTotalNumberOfFeatures0">
            <summary>
              Looks up a localized string similar to Total number of features: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DisplayFeaturesXXXX">
            <summary>
              Looks up a localized string similar to XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Distribution0WithItsCurrentParametersCannotBeSampledWithLatinHypercubeMethod">
            <summary>
              Looks up a localized string similar to {0} with its current parameters cannot be sampled with LatinHypercube method.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DoesNotBelongToMatrix0">
            <summary>
              Looks up a localized string similar to This {0} does not belong to the matrix.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DoesNotHaveANumericValue">
            <summary>
              Looks up a localized string similar to {0} does not have a numeric value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DoesNotYetHaveAValue">
            <summary>
              Looks up a localized string similar to {0} does not yet have a value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DomainCanNotHaveBundaries0">
            <summary>
              Looks up a localized string similar to {0} domain can not have boundaries.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DomainIndexOutOfRange">
            <summary>
              Looks up a localized string similar to Index is out of the domain .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DomainsSectionIsNotAllowedInSubmodels">
            <summary>
              Looks up a localized string similar to Domains section is not allowed in submodels..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DomainsSectionMustContainADomainAndAName">
            <summary>
              Looks up a localized string similar to Domains section must contain a domain and a name.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DomainValueOutOfRange">
            <summary>
              Looks up a localized string similar to Values in the domain are not ordered distinct, or out of range .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicatedSet">
            <summary>
              Looks up a localized string similar to Duplicated set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateEntriesDetectedInDataBoundTo0">
            <summary>
              Looks up a localized string similar to Duplicated entries detected in data bound to {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateKey">
            <summary>
              Looks up a localized string similar to A variable of the same key already exists .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateName0">
            <summary>
              Looks up a localized string similar to Duplicate name {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateParameter">
            <summary>
              Looks up a localized string similar to Duplicate Parameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateRowNames">
            <summary>
              Looks up a localized string similar to Duplicate row names: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateTokKindForTokKindEnumValue">
            <summary>
              Looks up a localized string similar to Duplicate TokKind for TokKindEnum value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateVariable">
            <summary>
              Looks up a localized string similar to Duplicate Decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.DuplicateVariable0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a duplicate Decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EachElementInTheListMustBeATuple">
            <summary>
              Looks up a localized string similar to Each element in the list must be a Tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EachOperationMustHaveAtLeastOneInput">
            <summary>
              Looks up a localized string similar to Each operation must have at least one input.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EachScenarioShouldHaveProbabilityAndValue">
            <summary>
              Looks up a localized string similar to Each scenario should be initiated with Probability and Value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ElementOfMustHaveExactlyTwoArguments">
            <summary>
              Looks up a localized string similar to ElementOf must have exactly two arguments.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ElementOfOnlyAllowsIntegerAndEnumeratedDomains">
            <summary>
              Looks up a localized string similar to ElementOf only allows integer and enumerated domains..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ElementOfTuplesAreUnbound">
            <summary>
              Looks up a localized string similar to Tuples in ElementOf are not bound to any data source.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EmptyArgListInEqual">
            <summary>
              Looks up a localized string similar to Empty argument list in Equal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EmptyArgListInProduct">
            <summary>
              Looks up a localized string similar to Empty argument list in Product.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EmptyArgListInUnequal">
            <summary>
              Looks up a localized string similar to Empty argument list in Unequal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EmptyHeap">
            <summary>
              Looks up a localized string similar to The heap is empty .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EmptyINDEPSection">
            <summary>
              Looks up a localized string similar to Empty INDEP section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumDomainCannotContainDuplicatedValues0">
            <summary>
              Looks up a localized string similar to Enum domain cannot contain duplicate value &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumDomainCannotContainNullOrEmptyStringValue">
            <summary>
              Looks up a localized string similar to Enum domain cannot contain null or empty string values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumDomainMustHaveAtLeastOneElement">
            <summary>
              Looks up a localized string similar to Enum domain must have at least one element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumDomainRequiresEnumerationTypeAsArgument">
            <summary>
              Looks up a localized string similar to EnumDomain(TAnEnum) requires Enumeration Type as argument.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumeratedDomainsAreNotSupportedInOML">
            <summary>
              Looks up a localized string similar to Enumerated domains are not supported in OML.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumerateEmptyDomain">
            <summary>
              Looks up a localized string similar to Cannot enumerate elements in an empty domain .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EnumerateInterimSolutionsMustBeEnabledForLocalSearch">
            <summary>
              Looks up a localized string similar to EnumerateInterimSolutions in ConstraintSolverParams must be enabled for local search.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjEmptyCharacterLiteral">
            <summary>
              Looks up a localized string similar to Empty character literal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjEndOfFileFoundExpected">
            <summary>
              Looks up a localized string similar to End-of-file found, &apos;*/&apos; expected.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjExpectedCharacter0">
            <summary>
              Looks up a localized string similar to Expected character &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjFloatingPointConstantIsOutsideTheRangeOfType0">
            <summary>
              Looks up a localized string similar to Floating-point constant is outside the range of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjIntegralConstantIsTooLarge">
            <summary>
              Looks up a localized string similar to Integral constant is too large.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjKeywordIdentifierOrStringExpectedAfterVerbatimSpecifier">
            <summary>
              Looks up a localized string similar to Keyword, identifier, or string expected after verbatim specifier: @.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjNewlineInConstant">
            <summary>
              Looks up a localized string similar to Newline in constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjNumberPastColumn0">
            <summary>
              Looks up a localized string similar to Number past column {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjTooManyCharactersInCharacterLiteral">
            <summary>
              Looks up a localized string similar to Too many characters in character literal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjUnexpected0">
            <summary>
              Looks up a localized string similar to Unexpected &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjUnexpectedCharacter0">
            <summary>
              Looks up a localized string similar to Unexpected character &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjUnrecognizedEscapeSequence">
            <summary>
              Looks up a localized string similar to Unrecognized escape sequence.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrObjUnterminatedStringLiteral">
            <summary>
              Looks up a localized string similar to Unterminated string literal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Error012345">
            <summary>
              Looks up a localized string similar to Error {0}({1},{2})-({3},{4}): {5}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorCode0Token3Line12">
            <summary>
              Looks up a localized string similar to Error code {0} :token {3}:line {1}: {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorFillingSolverParametersWithDirective">
            <summary>
              Looks up a localized string similar to Error filling solver parameters with directive..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorInBasisSolve">
            <summary>
              Looks up a localized string similar to An error occurred when solving the basis .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorInBasisSolveOperation012">
            <summary>
              Looks up a localized string similar to Error in basis solve operation! {0} {1} {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorSamplingResultNeedsToBeInteger">
            <summary>
              Looks up a localized string similar to Error in sampling. Result needs to be a 32 bit integer, but it is not. successProbability argument of the distribution is probably too small.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ErrorToken">
            <summary>
              Looks up a localized string similar to Error token.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Ev0">
            <summary>
              Looks up a localized string similar to EV: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.EvaluationCallCount0">
            <summary>
              Looks up a localized string similar to Evaluation call count: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Evpi0">
            <summary>
              Looks up a localized string similar to EVPI: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExactlyMofNExpectsBooleanTerms">
            <summary>
              Looks up a localized string similar to ExactlyMofN expects Boolean Terms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExceededIterationLimit">
            <summary>
              Looks up a localized string similar to Exceeded iteration limit of {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExcelModelTooLarge">
            <summary>
              Looks up a localized string similar to Model size exceeds evaluation limit - please see About dialog for more information..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Exception1">
            <summary>
              Looks up a localized string similar to {0} Exception: {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExceptionThrownFromCholeskyThread">
            <summary>
              Looks up a localized string similar to Exception thrown from Cholesky thread.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectAListOfIntegersOrAnIntegersRange">
            <summary>
              Looks up a localized string similar to Expect a list of integers or an Integers range.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Expected0">
            <summary>
              Looks up a localized string similar to Expected &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Expected0ArgumentsButSaw1">
            <summary>
              Looks up a localized string similar to Expected {0} arguments but received {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectedAllowedSectionSymbols">
            <summary>
              Looks up a localized string similar to Expected &apos;Parameters&apos;, &apos;Decisions&apos;, &apos;Goals&apos;, or &apos;Constraints&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectedIdentifier">
            <summary>
              Looks up a localized string similar to Expected Identifier.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectedModel">
            <summary>
              Looks up a localized string similar to Expected Model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectedNumericValue">
            <summary>
              Looks up a localized string similar to Expected numeric value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectedTuples">
            <summary>
              Looks up a localized string similar to Expected Tuples.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectingIndexes0">
            <summary>
              Looks up a localized string similar to Expecting {0} indexes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpectsExactly1IndexesBut2WereProvided">
            <summary>
              Looks up a localized string similar to {0} expects exactly {1} indexes but {2} were provided.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpiredEvaluationCopy">
            <summary>
              Looks up a localized string similar to Expired evaluation copy.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpressionCannotBeConvertedToTerm">
            <summary>
              Looks up a localized string similar to Expression cannot be converted to Term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpressionFromWrongRewriteSystem">
            <summary>
              Looks up a localized string similar to Expression from wrong RewriteSystem!.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ExpressionTermCouldNotBeResolved">
            <summary>
              Looks up a localized string similar to Expression term could not be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FactoringFailedSubstituted0SlackVariables">
            <summary>
              Looks up a localized string similar to Factoring failed. Substituted {0} slack variables..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FatalError">
            <summary>
              Looks up a localized string similar to Fatal error.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FilteredSumNotYetImplemented">
            <summary>
              Looks up a localized string similar to FilteredSum not yet implemented.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FinishingPoint">
            <summary>
              Looks up a localized string similar to Finishing point =.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FinishingValue">
            <summary>
              Looks up a localized string similar to Finishing value =.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FinishingValue0">
            <summary>
              Looks up a localized string similar to {0} finishing value =.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FiniteSolveNeedsAModelInvocation">
            <summary>
              Looks up a localized string similar to FiniteSolve needs a Model invocation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FirstArgumentForBinomialDistributionMustBeInteger">
            <summary>
              Looks up a localized string similar to First argument for binomial distribution must be integer.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FirstArgumentOfTupleMemberIsNotATuple">
            <summary>
              Looks up a localized string similar to First argument of TupleMember is not a tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ForeachCannotBeUsedAsAGoal">
            <summary>
              Looks up a localized string similar to Foreach cannot be used as a goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.FunctionNotUnderstoodInExpression">
            <summary>
              Looks up a localized string similar to Function &apos;{0}[]&apos; not understood in expression.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GeneralWrongForeach">
            <summary>
              Looks up a localized string similar to Syntax error in Foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GetPowerSetListBaselineIsCalledOnANonSetNonListVar">
            <summary>
              Looks up a localized string similar to GetPowerSetListBaseline is called on a non-set/non-list variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalCannotBeAConstant">
            <summary>
              Looks up a localized string similar to Goal cannot be a constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalMustBeAnIntegerFunction">
            <summary>
              Looks up a localized string similar to Goal must be an integer function.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalsCannotContainDecisionsMultipliedByRandomParameters">
            <summary>
              Looks up a localized string similar to Goals cannot contain Decisions multiplied by RandomParameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalsNotSupportedComposite">
            <summary>
              Looks up a localized string similar to Cannot add goals to CspComposite .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalsSectionCanContainsOnlyMinimizeOrMaximize">
            <summary>
              Looks up a localized string similar to Goals section can contains only Minimize or Maximize clauses.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalsSectionCanContainsOnlyMinimizeOrMaximizeAndNot0">
            <summary>
              Looks up a localized string similar to Goals section can contains only Minimize or Maximize clauses, and not {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalWasNotMinimizeOrMaximize">
            <summary>
              Looks up a localized string similar to Goal was not Minimize or Maximize..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.GoalWithEmptyDomain">
            <summary>
              Looks up a localized string similar to Goal function cannot have an empty domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.HasMultipleValues">
            <summary>
              Looks up a localized string similar to {0} has multiple values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.HasToBeInvocation0">
            <summary>
              Looks up a localized string similar to {0} has to be an Invocation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.HSDDoesNotHandleQuadratic">
            <summary>
              Looks up a localized string similar to This solver does not support quadratic programming..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IdentifierExpected">
            <summary>
              Looks up a localized string similar to Identifier expected.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IllFormedModelCannotBeSaved">
            <summary>
              Looks up a localized string similar to Model is ill-formed and cannot be saved to OML.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IllFormedRule">
            <summary>
              Looks up a localized string similar to Ill-formed rule.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ImproperOption0">
            <summary>
              Looks up a localized string similar to Invalid option: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IncompatibleInputTerms">
            <summary>
              Looks up a localized string similar to The input Terms do not belong to the same CspModel instance .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IncompatibleMatrixSize">
            <summary>
              Looks up a localized string similar to The matrices have incompatible sizes .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IncompatibleVectorSize">
            <summary>
              Looks up a localized string similar to The vectors have incompatible sizes .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InConstraintTakesTwoArgumentAndTheSecondArgumentMustBeEitherAListOrATuple">
            <summary>
              Looks up a localized string similar to In constraint takes two argument and the second argument must be either a list or a tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexCanNotBeFound0">
            <summary>
              Looks up a localized string similar to Index [{0}] cannot be found.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexConstraintOutOfRange">
            <summary>
              Looks up a localized string similar to One of the indexes in the two dimensional Index constraint is out of range .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexedDecisionsMayNotBeProbed">
            <summary>
              Looks up a localized string similar to Indexed decisions may not be probed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexedDecisionUsedWithoutIndex">
            <summary>
              Looks up a localized string similar to Indexed decision used without index.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexError">
            <summary>
              Looks up a localized string similar to Internal Error: should be no way that the ixVar can have a value not in the index set .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexesCanNotBeFound0">
            <summary>
              Looks up a localized string similar to Indexes [{0}] cannot be found.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexIsNotConstant">
            <summary>
              Looks up a localized string similar to Index is not constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexOutOfRange">
            <summary>
              Looks up a localized string similar to Index out of range.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexVariableRangesDoNotMatchArrayShape">
            <summary>
              Looks up a localized string similar to Index variable ranges do not match array shape.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IndexWrongForParameter01">
            <summary>
              Looks up a localized string similar to {0} for parameter {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InfeasiblePrimalDueToUnboundedPrimal">
            <summary>
              Looks up a localized string similar to InfeasiblePrimal due to UnboundedPrimal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InitialNonZerosA0">
            <summary>
              Looks up a localized string similar to Initial non-zeros A[{0}].
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InitialNonZerosA0Q1">
            <summary>
              Looks up a localized string similar to Initial non-zeros A[{0}] Q[{1}].
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InOrConstraintTakesAtLeastOneArgument">
            <summary>
              Looks up a localized string similar to InOr constraint takes at least one argument.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Inputs0And1HaveDifferentSymbolDomains">
            <summary>
              Looks up a localized string similar to Inputs {0} and {1} have different symbol domains..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IntegerVariablesAreNotSupported">
            <summary>
              Looks up a localized string similar to Integer variables are not supported.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IntegralityMayNotBeRedefined">
            <summary>
              Looks up a localized string similar to The integrality setting may not be redefined..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InterfaceIncompatibleWithProblem">
            <summary>
              Looks up a localized string similar to {0} is registered with the {1} interface but that interface is incompatible with {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InteriorPointAfterReductionThisModelContainsNoVariables">
            <summary>
              Looks up a localized string similar to Interior Point: after reduction, this model contains no variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InteriorPointCannotLoadAModelWithNoVariables">
            <summary>
              Looks up a localized string similar to Interior Point cannot load a model with no variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InteriorPointCurrentlyRequiresAGoal">
            <summary>
              Looks up a localized string similar to Interior Point currently requires a goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InteriorPointSolverCanTProcessTheModel01">
            <summary>
              Looks up a localized string similar to Interior point solver can&apos;t process the model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InteriorPointSolverDoesNotSupportIntegerVariables">
            <summary>
              Looks up a localized string similar to InteriorPointSolver does not support integer variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InternalError">
            <summary>
              Looks up a localized string similar to Internal error.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InternalErrorBadSetElement">
            <summary>
              Looks up a localized string similar to Internal error: Bad set element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InterruptedExitRepeatPivots0">
            <summary>
              Looks up a localized string similar to Interrupted: exit RepeatPivots {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IntMapNonIntegerIndex">
            <summary>
              Looks up a localized string similar to Index Terms in Index constraints must be Integer Terms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentCountForOperator0">
            <summary>
              Looks up a localized string similar to Invalid argument count for operator {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForBinomialDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for binomial distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForDistribution">
            <summary>
              Looks up a localized string similar to Distribution was passed an invalid numeric value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForExponentialDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for exponential distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForGeometricDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for geometric distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForLognormalDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for log-normal distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForNormalDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for normal distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForScenariosDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for scenarios distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidArgumentsForUniformDistribution">
            <summary>
              Looks up a localized string similar to Invalid arguments for uniform distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidBaselineSet">
            <summary>
              Looks up a localized string similar to The baseline set is not an integer set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidBounds">
            <summary>
              Looks up a localized string similar to Invalid bounds.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidColumnVar">
            <summary>
              Looks up a localized string similar to Column variable is not a CspVariable with a symbol domain but the table constraint rows have symbol values .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidCompositeVariableOperation">
            <summary>
              Looks up a localized string similar to Invoked operations on composite variables are invalid.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidConeType0">
            <summary>
              Looks up a localized string similar to Invalid cone type: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidConstraintEncountered">
            <summary>
              Looks up a localized string similar to Invalid constraint encountered.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidCSectionFormat">
            <summary>
              Looks up a localized string similar to Invalid CSECTION format.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDecimalPrecision">
            <summary>
              Looks up a localized string similar to Precision for a decimal domain must be 1, 10, 100, 1000, or 10000 .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDecisionDefinition">
            <summary>
              Looks up a localized string similar to Invalid Decision definition.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDomain">
            <summary>
              Looks up a localized string similar to Invalid domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDomainForFDVariable">
            <summary>
              Looks up a localized string similar to Invalid domain for CP decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDomainForLinearVariable">
            <summary>
              Looks up a localized string similar to Invalid domain for LP decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidDomainForSATVariable">
            <summary>
              Looks up a localized string similar to Invalid domain for SAT decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidFactorialOperand">
            <summary>
              Looks up a localized string similar to Invalid operand for Factorial .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidFiniteConstraint">
            <summary>
              Looks up a localized string similar to Invalid Finite constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidFiniteGoal">
            <summary>
              Looks up a localized string similar to Invalid Finite goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidForceOperation">
            <summary>
              Looks up a localized string similar to Internal Error: Force only applies to Boolean Terms .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidFormForSos1Constraint">
            <summary>
              Looks up a localized string similar to Invalid form for Sos1 constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidFormForSos2Constraint">
            <summary>
              Looks up a localized string similar to Invalid form for Sos2 constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidIndexForSet0">
            <summary>
              Looks up a localized string similar to Invalid index {0} for set..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidInterval">
            <summary>
              Looks up a localized string similar to Invalid interval..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidIntervalDomainDefinition">
            <summary>
              Looks up a localized string similar to The lowerbound of the interval is greater than the upperbound .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidIsElementOfDetectedInSave">
            <summary>
              Looks up a localized string similar to Invalid IsElementOf detected in save.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidIsTrueCall">
            <summary>
              Looks up a localized string similar to Cannot call IsTrue on this Term .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidKeyChange">
            <summary>
              Looks up a localized string similar to Cannot modify an existing key .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidLinearConstraint">
            <summary>
              Looks up a localized string similar to Invalid linear constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidLinearModel">
            <summary>
              Looks up a localized string similar to Invalid linear model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidLinearOrQuadraticTerm">
            <summary>
              Looks up a localized string similar to Invalid linear or quadratic term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidLinearTerm">
            <summary>
              Looks up a localized string similar to Invalid linear term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidList0">
            <summary>
              Looks up a localized string similar to Invalid list {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidLogEventId">
            <summary>
              Looks up a localized string similar to A log event ID must be between 0 and 63 .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidMatrixDimensions">
            <summary>
              Looks up a localized string similar to Invalid matrix dimensions..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidModelForSolver01">
            <summary>
              Looks up a localized string similar to Invalid model for solver: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidNumber">
            <summary>
              Looks up a localized string similar to invalid number.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidOptionForFiniteSolver0">
            <summary>
              Looks up a localized string similar to Invalid option for finite solver: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidOptionForLinearSolver0">
            <summary>
              Looks up a localized string similar to Invalid option for linear solver: &apos;{0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidParams">
            <summary>
              Looks up a localized string similar to The parameter list cannot be null or empty .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidPermutation">
            <summary>
              Looks up a localized string similar to The permutation is invalid .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidRowId">
            <summary>
              Looks up a localized string similar to Invalid row id..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidRowListOrRowTuple">
            <summary>
              Looks up a localized string similar to Invalid row list or row tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSamplingMethod0">
            <summary>
              Looks up a localized string similar to Invalid sampling method {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSATConstraint">
            <summary>
              Looks up a localized string similar to Invalid SAT constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSATLiteral">
            <summary>
              Looks up a localized string similar to Invalid SAT literal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSATObjective">
            <summary>
              Looks up a localized string similar to Invalid SAT objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSetDomainDefinition">
            <summary>
              Looks up a localized string similar to The given values for constructing a set either are unordered or have duplicate values .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSolverInstance">
            <summary>
              Looks up a localized string similar to The solver instance is invalid .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidStringConstant">
            <summary>
              Looks up a localized string similar to Invalid symbol constant: this symbol does not exist in the given symbol domain .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidSymbolDomainDefinition">
            <summary>
              Looks up a localized string similar to The given symbols for constructing a symbol set have duplicate symbols .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidTermDecisionNotInModel">
            <summary>
              Looks up a localized string similar to All Decisions involved in an expression must be added to the same model with AddDecision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidTermExceptionMessage">
            <summary>
              Looks up a localized string similar to {0}: {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidTermNotInModel">
            <summary>
              Looks up a localized string similar to All Terms, Decisions, and Parameters involved in an expression must belong to the same model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidTermParameterNotInModel">
            <summary>
              Looks up a localized string similar to All Parameters involved in an expression must be added to the same model with AddParameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidValueForDirectiveOption0">
            <summary>
              Looks up a localized string similar to Invalid value for &apos;Directive&apos; option: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidValueForLinearSolverOption01">
            <summary>
              Looks up a localized string similar to Invalid value for linear solver option {0}: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidValueForOption0">
            <summary>
              Looks up a localized string similar to Invalid value for option &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidValueForSolverOption0">
            <summary>
              Looks up a localized string similar to Invalid value for &apos;Solver&apos; option: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidValueType">
            <summary>
              Looks up a localized string similar to The type of the value is unknown .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidVariable">
            <summary>
              Looks up a localized string similar to Invalid variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidVariable0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a invalid variable..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidVariableId">
            <summary>
              Looks up a localized string similar to Invalid variable id..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvalidVariablesClause">
            <summary>
              Looks up a localized string similar to Invalid Decisions clause.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.InvocationCannotBeUsedAsSetDeclaration">
            <summary>
              Looks up a localized string similar to Invocation can not be used as a Set declaration.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IpmCoreSolutionTime0">
            <summary>
              Looks up a localized string similar to IPM core solution time = {0:F2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IPMGoalCountHasBeenReducedTo1">
            <summary>
              Looks up a localized string similar to IPM goal count has been reduced to 1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IPMSolverSupportOnlySingleGoal">
             <summary>
               Looks up a localized string similar to Interior Point Method (IPM) solver currently supports a single goal only. 
            Please change the model so that it contains one goal, or use the Simplex solver..
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotASymbol">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotAValidIterationTerm">
            <summary>
              Looks up a localized string similar to {0} is not a valid iteration term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotAValidSet">
            <summary>
              Looks up a localized string similar to {0} is not a valid Set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotBoolean">
            <summary>
              Looks up a localized string similar to Input {0} is not Boolean..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotDeclaredAsTuples">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not declared as Tuples.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotNumeric">
            <summary>
              Looks up a localized string similar to Input {0} is not numeric..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotPair">
            <summary>
              Looks up a localized string similar to Input {0} is not a pair..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IsNotSymbolic">
            <summary>
              Looks up a localized string similar to {0} is not symbolic.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IterationCount0">
            <summary>
              Looks up a localized string similar to Iteration count: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.IterationLimitExceededInReplaceRepeated">
            <summary>
              Looks up a localized string similar to Iteration limit exceeded in ReplaceRepeated[{0},{1},{2}].
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.KRpRdGapKtMuGammaCAlphaCxTime">
            <summary>
              Looks up a localized string similar to  k     rp     rd     gap      k/t     mu   gamma C alpha       cx       time.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.KRpRdRgKTMuGammaCx">
            <summary>
              Looks up a localized string similar to  k      rp         rd         rg         k/t        mu    gamma       cx.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LargeErrorInBasicValue0">
            <summary>
              Looks up a localized string similar to Large error in basic value: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LenghtShouldEqualToSumOfLengths012">
            <summary>
              Looks up a localized string similar to Length of {0} should be equal to sum of lengths of {1} and {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LengthCanNotBeZero0">
            <summary>
              Looks up a localized string similar to Length of {0} can&apos;t be zero.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LicenseFormat0123456">
            <summary>
              Looks up a localized string similar to Limits: NonzeroLimit = {1}, MipVariableLimit = {2}, MipRowLimit = {3}, MipNonzeroLimit = {4}, CspTermLimit = {5}, Expiration = {6}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListContainsANonStringValue">
            <summary>
              Looks up a localized string similar to List contains a non string value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListContainsNonNumericValue">
            <summary>
              Looks up a localized string similar to List contains a non numeric value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListDidNotContainRules">
            <summary>
              Looks up a localized string similar to List did not contain Rules.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListExpectedToBeEntirelySymbols">
            <summary>
              Looks up a localized string similar to List expected to be entirely symbols.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListMustHaveAtLeastOneElement">
            <summary>
              Looks up a localized string similar to List must have at least one element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ListsCannotMixSymbolsWithLiterals">
            <summary>
              Looks up a localized string similar to Lists cannot mix symbols with literals.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LoadingOfMPSFilesContainingSpecialOrderedSetsIsNotSupported">
            <summary>
              Looks up a localized string similar to Loading of MPS files containing special ordered sets is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LoadLinearModelPassedThis">
            <summary>
              Looks up a localized string similar to LoadLinearModel passed &apos;this&apos;!.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LogComputationalProgressOfHSDSolver">
            <summary>
              Looks up a localized string similar to Computational Progress of HSD Solver:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LogicalSymbolCouldNotBeMadeAVariable">
            <summary>
              Looks up a localized string similar to Logical Symbol {0} could not be made a Decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LowerBoundCannotBeLargerThanUpperBound">
            <summary>
              Looks up a localized string similar to Lower bound cannot be larger than upper bound.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.LowerTriangularCoordinateSeen">
            <summary>
              Looks up a localized string similar to lower triangular coordinate seen.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MapArrayIndexingSizeLimitExceeded">
            <summary>
              Looks up a localized string similar to Map (array indexing) size limit of {0} elements exceeded.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MappingOfStochasticModelIsNotSupported">
            <summary>
              Looks up a localized string similar to Mapping of stochastic model is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixDimensionsAreNotValid">
            <summary>
              Looks up a localized string similar to Matrix dimensions are not valid..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixDimensionsDoNotMatch">
            <summary>
              Looks up a localized string similar to Matrix dimensions do not match..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixIsNotPositiveDefinite">
            <summary>
              Looks up a localized string similar to Matrix is not positive definite..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixIsNotSquare">
            <summary>
              Looks up a localized string similar to Matrix is not square..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixIsNotSymmetric">
            <summary>
              Looks up a localized string similar to Matrix is not symmetric..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixIsRankDeficient">
            <summary>
              Looks up a localized string similar to Matrix is rank deficient..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixIsSingular">
            <summary>
              Looks up a localized string similar to Matrix is singular.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MatrixRowDimensionsMustAgree">
            <summary>
              Looks up a localized string similar to Matrix row dimensions must agree..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MaximizeProblem">
            <summary>
              Looks up a localized string similar to Maximize problem.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MaximumIterationsExceeded">
            <summary>
              Looks up a localized string similar to Maximum iterations exceeded.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MaximumNumberOfIterationsShouldBePositive">
            <summary>
              Looks up a localized string similar to Maximum number of iterations should be positive.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MaximumTimeExceeded">
            <summary>
              Looks up a localized string similar to Maximum time exceeded.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MicrosoftSolverFoundationVersion01">
            <summary>
              Looks up a localized string similar to Microsoft Solver Foundation {0} {1} Edition.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MinimizeProblem">
            <summary>
              Looks up a localized string similar to Minimize problem.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MinimumBundaryBiggerThanMaximumBundary">
            <summary>
              Looks up a localized string similar to Minimum bound can not be bigger than maximum bound.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MinimumBundaryBiggerThanMaximumBundaryAfterRound01">
            <summary>
              Looks up a localized string similar to After rounding, the minimum bound {0} is bigger than the maximum bound {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MinimumDegreeKeyUnmatched">
            <summary>
              Looks up a localized string similar to minimum degree key unmatched.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MissingParameterValue">
            <summary>
              Looks up a localized string similar to Missing parameter value: {0}({1}).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MixedBooleanAndIntegerTypesUnexpectedInArgumentList">
            <summary>
              Looks up a localized string similar to Mixed boolean and integer types unexpected in argument list.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelCannotBeAnalyzed">
            <summary>
              Looks up a localized string similar to Model cannot be analyzed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelCouldNotBeNull">
            <summary>
              Looks up a localized string similar to model could not be null.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelHasNoSolution">
            <summary>
              Looks up a localized string similar to Model is infeasible or unknown. Cannot access ConstraintSolverSolution.GetValue.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelHasNotBeenDifferentiated">
            <summary>
              Looks up a localized string similar to The operation is invalid because the model has not been differentiated..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelIsNotStochasticButStochasticDirectiveWasUsed">
            <summary>
              Looks up a localized string similar to Model is not stochastic, but a stochastic directive was used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelIsStochasticButNonStochasticDirectiveWasUsed">
            <summary>
              Looks up a localized string similar to Model is stochastic, but a non-stochastic directive was used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelNotConvex">
            <summary>
              Looks up a localized string similar to The model is not convex..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelNotSolved">
            <summary>
              Looks up a localized string similar to Model is not solved yet. Cannot retrieve decisions&apos; values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelReduction0UnboundedRowsRemoved1ConstantOrUnboundedSlackVariablesRemoved">
            <summary>
              Looks up a localized string similar to Model reduction: {0} unbounded rows removed, {1} constant or unbounded slack variables removed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelsCannotBeSharedAcrossSolverContextInstances">
            <summary>
              Looks up a localized string similar to Models cannot be shared across SolverContext instances. Please use the SolverContext instance that created the Model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelShouldContainAtLeastOneDecisionsSection">
            <summary>
              Looks up a localized string similar to Model should contain at least one &apos;Decisions&apos; section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelShouldNotBeEditedWhileEnumeratingRowsOrVariables">
            <summary>
              Looks up a localized string similar to Model should not be edited while enumerating rows or variables..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelShouldStartWithModelAndEndWithSymbol">
            <summary>
              Looks up a localized string similar to Model should start with \&quot;Model[\&quot; and end with \&quot;]\&quot; symbol.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelSizeLimitHasBeenExceed">
            <summary>
              Looks up a localized string similar to Model size limit has been exceeded for this version of the product. Please contact Microsoft Corporation for licensing options..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ModelTooLarge">
            <summary>
              Looks up a localized string similar to Given model is too large and cannot be handled.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MpsExpectsAStringTheFileNameOptionallyFollowedByABooleanTrueForFixedFormatFalseForFree">
            <summary>
              Looks up a localized string similar to Mps expects a string (the file name), optionally followed by a boolean (True for fixed format, False for free)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Ms">
             <summary>
               Looks up a localized string similar to {0}ms
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MulticorrectorIneffective">
            <summary>
              Looks up a localized string similar to Multicorrector: ineffective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MultipleOccurrenceOfASymbolInSymbolSet">
            <summary>
              Looks up a localized string similar to multiple occurrence of a symbol in SymbolSet.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustApplyToASingleArgument">
            <summary>
              Looks up a localized string similar to {0} must apply to a single argument.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustApplyToTwoArguments">
            <summary>
              Looks up a localized string similar to {0} must apply to two arguments.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustBeAListOfIntegerValues">
            <summary>
              Looks up a localized string similar to Must be a list of integer values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustBeATupleOfIntegerValuesThatAreWithinFiniteSolverSIntegerRange">
            <summary>
              Looks up a localized string similar to Must be a tuple of integer values that are within Finite Solver&apos;s integer range.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustHaveASingleValue">
            <summary>
              Looks up a localized string similar to {0} must have a single value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustHaveAtLeastOneElement">
            <summary>
              Looks up a localized string similar to {0} must have at least one element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.MustHaveAtLeastOneValue">
            <summary>
              Looks up a localized string similar to {0} must have at least one value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NameFoundInModelWasNotPresentedAsAVariable">
            <summary>
              Looks up a localized string similar to Name found in Model was not presented as a Decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NameIsAlreadyUsedAsADomain">
            <summary>
              Looks up a localized string similar to Name is already used as a domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolver">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolverFollowedByAnyNumberOfRulesMappingRowVarToValue">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver, followed by any number of rules mapping {row, var} to value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolverFollowedByAnyNumberOfRulesMappingVariablesLabelsToValues">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver, followed by any number of rules mapping variables/labels to values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolverOptionallyFollowedByLabelVarPairs">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver, optionally followed by {label, var} pairs..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolverOptionallyFollowedByStatisticNames">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver, optionally followed by statistic names..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASimplexSolverOptionallyFollowedByVariablesLabels">
            <summary>
              Looks up a localized string similar to {0} needs a simplex solver, optionally followed by variables/labels..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsASolverWithSensitivityInformation">
            <summary>
              Looks up a localized string similar to {0} needs a solver with sensitivity information..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsAtLeast2Arguments">
            <summary>
              Looks up a localized string similar to {0} needs at least 2 arguments.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NeedsToUseDualForSensitivityRepor">
            <summary>
              Looks up a localized string similar to needs to use dual for sensitivity report.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NegationShouldHave1Argument">
            <summary>
              Looks up a localized string similar to Negation should have 1 argument.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NegativeIndex01">
            <summary>
              Looks up a localized string similar to Negative index in {0}[{1}].
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NegativePower">
            <summary>
              Looks up a localized string similar to Cannot take negative power in ConstraintSolver.Power.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NmSolverRequiresEvaluatorToBeSpecifiedBeforeCallingSolve">
            <summary>
              Looks up a localized string similar to NelderMeadSolver requires the FunctionEvaluator property to be specified before calling solve..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoArithmeticObjectForType">
            <summary>
              Looks up a localized string similar to There is no arithmetic object for this number type .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoChangesBeforeSolveComplete">
            <summary>
              Looks up a localized string similar to The model cannot be changed before Solve completes .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoConeTypeSpecified">
            <summary>
              Looks up a localized string similar to No cone type specified..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoDataBindingSetOn0">
            <summary>
              Looks up a localized string similar to No data binding set on {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoDerivativeExists01">
            <summary>
              Looks up a localized string similar to No derivative exists in row {0} for variable {1}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NodesSearchedIn1Ms">
            <summary>
              Looks up a localized string similar to {0,-10} nodes searched in {1}ms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoDomainValueKindSpecified">
            <summary>
              Looks up a localized string similar to No Domain.ValueKind specified.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoExpiration">
            <summary>
              Looks up a localized string similar to none.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonBooleanConstraints">
            <summary>
              Looks up a localized string similar to A constraint must be Boolean .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonBooleanExpressionAttemptedAsConstraint">
            <summary>
              Looks up a localized string similar to Non-boolean expression attempted as constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonBooleanInputs">
            <summary>
              Looks up a localized string similar to Non-Boolean term appears where a Boolean term is expected.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonBooleanVariableAttemptedAsConstraint">
            <summary>
              Looks up a localized string similar to Non-boolean variable attempted as constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonCompositeFieldAccess">
            <summary>
              Looks up a localized string similar to The field method is only valid for composite variables .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoneOfTheSuppliedDirectivesWasValidForTheModel">
            <summary>
              Looks up a localized string similar to None of the supplied directives was valid for the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoNewFieldsForSetListComposites">
            <summary>
              Looks up a localized string similar to Cannot add new fields to CspPowerSet or CspPowerList composite.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonIntegerDomainsInCSPProblemIsNotYetSupportedInOML">
            <summary>
              Looks up a localized string similar to non-integer domains in CSP problem is not yet supported in OML.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonlinearTerm">
            <summary>
              Looks up a localized string similar to Nonlinear term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NonlinearValue">
            <summary>
              Looks up a localized string similar to Nonlinear value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoReportType">
            <summary>
              Looks up a localized string similar to no report type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoSolverFound">
            <summary>
              Looks up a localized string similar to No solver could be found that can accept the model given the model type and directive(s).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoSolverFoundASolutionWithinTheTimeLimit">
            <summary>
              Looks up a localized string similar to No solver found a solution within the time limit..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoSolverWithCapabilityForDirectiveWithType01">
            <summary>
              Looks up a localized string similar to {1} cannot solve {0} models. Remove this directive and use a directive that supports the {0} capability..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoSuchSet">
            <summary>
              Looks up a localized string similar to No such set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotALinearOperation">
            <summary>
              Looks up a localized string similar to Not a linear operation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotARow">
            <summary>
              Looks up a localized string similar to not a row.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotBoolean">
            <summary>
              Looks up a localized string similar to Cannot convert the Term to Boolean Term .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotLpMilpQpModel">
            <summary>
              Looks up a localized string similar to The model is not a LP/MILP/QP model. Make sure the model does not contain any nonlinear constraints or strict inequalities, or use a directive that supports this model type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotSupportedRandomType">
            <summary>
              Looks up a localized string similar to Not supported random type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotTriangular">
            <summary>
              Looks up a localized string similar to not triangular.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotValidIndex012">
            <summary>
              Looks up a localized string similar to Not valid index (bigger than number of {0}) in {1}[{2}].
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NotYetImplemented">
            <summary>
              Looks up a localized string similar to not yet implemented.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoVidForTheDecision0">
            <summary>
              Looks up a localized string similar to No vid for the decision {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NoVidForTheGoal0">
            <summary>
              Looks up a localized string similar to No vid for the goal {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NullConstraints">
            <summary>
              Looks up a localized string similar to Cannot add null constraints..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NullDomain">
            <summary>
              Looks up a localized string similar to The domain for a decision cannot be null..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NullGoals">
            <summary>
              Looks up a localized string similar to Cannot add null goals..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NullInput">
            <summary>
              Looks up a localized string similar to The input cannot be null .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberNotIntegerOrOutOfRange">
            <summary>
              Looks up a localized string similar to Number not integer, or out of range.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfElementsInTupleDoesNotMatch">
            <summary>
              Looks up a localized string similar to Number of elements in tuple does not match.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfEvaluationCalls0">
            <summary>
              Looks up a localized string similar to Number of evaluation calls: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfIterationsPerformed0">
            <summary>
              Looks up a localized string similar to Number of iterations performed: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfIterationsToRememberShouldBePositive">
            <summary>
              Looks up a localized string similar to Number of iterations to remember should be positive.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfParametersForDecisionIsWrong">
            <summary>
              Looks up a localized string similar to Number of parameters for Decision is wrong.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfParametersForDecisionIsWrong0">
            <summary>
              Looks up a localized string similar to Number of parameters for Decision &apos;{0}&apos; is wrong.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.NumberOfVariablesShouldBePositive">
            <summary>
              Looks up a localized string similar to Number of variables should be positive.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ObjectiveLabelAlreadyExists">
            <summary>
              Looks up a localized string similar to Objective label already exists..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OfReInitialization0">
            <summary>
              Looks up a localized string similar to Number of re-initialization: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OfReInitializationDueToCuts0">
            <summary>
              Looks up a localized string similar to Number of re-initialization due to cuts: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OfReInitializationDueToNodes0">
            <summary>
              Looks up a localized string similar to Number of re-initialization due to nodes: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlDecision">
            <summary>
              Looks up a localized string similar to Decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidAssignedDecision">
            <summary>
              Looks up a localized string similar to Decisions can not be assigned.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidAssignmentToSetsParameter">
            <summary>
              Looks up a localized string similar to Set parameters cannot be assigned values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadBuiltinOperator">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; is not supported in OML..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadDomain">
            <summary>
              Looks up a localized string similar to The domain &apos;{0}&apos; is not recognized..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadDomainBounds">
            <summary>
              Looks up a localized string similar to Invalid domain format..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadDomainBoundType">
            <summary>
              Looks up a localized string similar to Domain bound is not of the correct type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadDomainBoundType0">
            <summary>
              Looks up a localized string similar to Domain bound &apos;{0}&apos; is not of the correct type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadExpr">
            <summary>
              Looks up a localized string similar to The expression &apos;{0}&apos; is not recognized as a value or builtin operator..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadIterator">
            <summary>
              Looks up a localized string similar to Incorrect iterator format for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadSetSpecifier">
            <summary>
              Looks up a localized string similar to Invalid use of &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadTuple">
            <summary>
              Looks up a localized string similar to Expected a Tuple here..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBadTuple0">
            <summary>
              Looks up a localized string similar to Expected a Tuple here. &apos;{0}&apos; is not a Tuple..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidBuiltinUsedAsIterator">
            <summary>
              Looks up a localized string similar to Builtin symbol &apos;{0}&apos; cannot be used as an iterator..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidConstraintNotBoolean">
            <summary>
              Looks up a localized string similar to Only Boolean values are allowed as constraints..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidConstraintNotBoolean0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; Constraint is wrong. Only Boolean values are allowed as constraints..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDecisionInDomainBound">
            <summary>
              Looks up a localized string similar to Domain bounds may not depend on decision values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDecisionInDomainBound0">
            <summary>
              Looks up a localized string similar to Domain bound &apos;{0}&apos; may not depend on decision values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDecisionInFilter">
            <summary>
              Looks up a localized string similar to A condition for &apos;{0}&apos; may not be dependent on decision values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDecisionInIteratorList">
            <summary>
              Looks up a localized string similar to Values used in an iterator cannot depend on decision values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDecisionInIteratorList0">
            <summary>
              Looks up a localized string similar to Value &apos;{0}&apos; is used in an iterator. Values used in an iterator cannot depend on decision values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDeclaredIndexIsTable">
            <summary>
              Looks up a localized string similar to Index for &apos;{0}&apos; may not be used without indexing..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDeclaredIndexUsesData">
            <summary>
              Looks up a localized string similar to Index for &apos;{0}&apos; may not depend on a parameter value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDeclaredIndexUsesDecision">
            <summary>
              Looks up a localized string similar to Index for &apos;{0}&apos; may not depend on a decision value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDeclaredIndexUsesForeach">
            <summary>
              Looks up a localized string similar to Index for &apos;{0}&apos; must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDefiningBuiltin">
            <summary>
              Looks up a localized string similar to Builtin symbol &apos;{0}&apos; cannot be redefined..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDefiningBuiltinAsSet">
            <summary>
              Looks up a localized string similar to Builtin symbol &apos;{0}&apos; cannot be used as a set..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidDefiningDuplicatedSymbols">
            <summary>
              Looks up a localized string similar to Symbol {0} has been defined. Cannot redefine it in the current Model[] section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidEachListMustContainSameNumberOfElements">
            <summary>
              Looks up a localized string similar to Each list in a Tuples assignment must contain the same number of elements..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidFewerThanNeededArgumentCount01">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; requires at least {1} argument(s)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidFilterIsNotBoolean">
            <summary>
              Looks up a localized string similar to A condition for &apos;{0}&apos; must be a Boolean value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachInDomainBound">
            <summary>
              Looks up a localized string similar to Domain bound must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachInDomainBound0">
            <summary>
              Looks up a localized string similar to Domain bound &apos;{0}&apos; must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachInFilter">
            <summary>
              Looks up a localized string similar to A condition for &apos;{0}&apos; must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachInIterator">
            <summary>
              Looks up a localized string similar to Values used as iterator bounds must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachInParameter">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not allowed in a Parameters section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidForeachNotAllowedInOperator">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; only accepts singled-value arguments..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidGoalNotNumeric">
            <summary>
              Looks up a localized string similar to Only numeric values are allowed as goals..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidGoalNotNumeric0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; Goal is wrong. Only numeric values are allowed as goals..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIncompatibleArgument">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; must have all arguments of the same type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexedRandomParameters">
            <summary>
              Looks up a localized string similar to Arguments for indexed random parameters must be specified through data binding..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexedSetsParameter">
            <summary>
              Looks up a localized string similar to Set parameters cannot be indexed..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexingByForeach">
            <summary>
              Looks up a localized string similar to Value used as index must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexingByForeach0">
            <summary>
              Looks up a localized string similar to Value &apos;{0}&apos; is used as index. Value used as index must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexingByTable">
            <summary>
              Looks up a localized string similar to Value used as index is not a valid type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexingByTable0">
            <summary>
              Looks up a localized string similar to Value &apos;{0}&apos; is used as index. Value used as index is not a valid type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidIndexOfNonTable0">
            <summary>
              Looks up a localized string similar to The value {0} cannot be indexed..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidAssignmentFormat">
            <summary>
              Looks up a localized string similar to Invalid assignment format..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidElement">
            <summary>
              Looks up a localized string similar to Invalid element..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidElement0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; element is invalid..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidSos1">
            <summary>
              Looks up a localized string similar to Sos1 constraint must contain a sum of products.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidSos2">
            <summary>
              Looks up a localized string similar to Sos2 must contain a reference constraint..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidSos2NeedEquality">
            <summary>
              Looks up a localized string similar to Sos2 must contain a reference constraint as an equality..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidInvalidSos2NeedEqualityWithTwoArguments">
            <summary>
              Looks up a localized string similar to Sos2 must contain a reference constraint as an equality with exactly two arguments..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidLabel">
            <summary>
              Looks up a localized string similar to Invalid label to goal or constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidNonAssignmentParameterInForeach">
            <summary>
              Looks up a localized string similar to Only assignment parameters are allowed inside &apos;Foreach&apos; or &apos;ForeachWhere&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidNonBooleanArgument">
            <summary>
              Looks up a localized string similar to Logical or relational operators only accept Boolean arguments..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidNonNumericArgument">
            <summary>
              Looks up a localized string similar to Arithmetic operators only accept numeric arguments..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidNonNumericInIterator">
            <summary>
              Looks up a localized string similar to Values used as iterator bounds must be numeric..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidParameterInDomainBound">
            <summary>
              Looks up a localized string similar to Domain bounds may not depend on late-bound data..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidParameterInDomainBound0">
            <summary>
              Looks up a localized string similar to Domain bound &apos;{0}&apos; may not depend on late-bound data..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidParameterNotAssignmentOrIndex0">
            <summary>
              Looks up a localized string similar to Parameter &apos;{0}&apos; must be either assigned a value (&apos;=&apos;) or indexed(&apos;[]&apos;)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidRecourseDecision">
            <summary>
              Looks up a localized string similar to Invalid recourse decision name..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidRedefiningIterator">
            <summary>
              Looks up a localized string similar to The symbol &apos;{0}&apos; is already used as an iterator in an enclosing scope..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSectionShouldStartWithDomain">
            <summary>
              Looks up a localized string similar to All Parameters sections should start with a domain and all Decisions sections should start with a domain or a submodel..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSectionShouldStartWithDomain0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a domain nor a submodel. All Parameters sections should start with a domain and all Decisions sections should start with a domain or a submodel..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSetsOutsideParametersSection">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not allowed outside the Parameters section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidStackOverflow">
            <summary>
              Looks up a localized string similar to The expression was too large to validate..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSubmodelClause">
            <summary>
              Looks up a localized string similar to Submodel must be of the form: name -&gt; Model[...], where name is a single non-quoted symbol.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSubmodelGoalConstraintName">
            <summary>
              Looks up a localized string similar to Submodel, goal and constraint names cannot be a predefined symbol..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSubmodelInstanceSymbolUnknownOrDuplicated">
            <summary>
              Looks up a localized string similar to Unknown or duplicated submodel instance symbol.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSubmodelNameHasBeenTaken">
            <summary>
              Looks up a localized string similar to Submodel name has been taken.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSubmodelNameIsAlsoDeclaredAsANamedDomain">
            <summary>
              Looks up a localized string similar to Submodel name is also declared as a named domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSymbolRedefined">
            <summary>
              Looks up a localized string similar to The symbol &apos;{0}&apos; is already used as a decision or parameter..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidSymbolRedefinedAsSet">
            <summary>
              Looks up a localized string similar to The symbol &apos;{0}&apos; is already used as a set..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTableArgument">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; cannot accept the term without indexing..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTableInIteratorList">
            <summary>
              Looks up a localized string similar to This term cannot be used in an iterator without indexing..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTableInIteratorList0">
            <summary>
              Looks up a localized string similar to The term &apos;{0}&apos; cannot be used in an iterator without indexing..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleContainsDecision">
            <summary>
              Looks up a localized string similar to Tuple element may not depend on a decision value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleContainsDecision0">
            <summary>
              Looks up a localized string similar to Tuple element &apos;{0}&apos; may not depend on a decision value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleElementContainsForeach">
            <summary>
              Looks up a localized string similar to Tuple element must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleElementContainsForeach0">
            <summary>
              Looks up a localized string similar to Tuple element &apos;{0}&apos; must be single-valued..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleElementNotNumber">
            <summary>
              Looks up a localized string similar to Tuple element is not numeric..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleElementNotNumber0">
            <summary>
              Looks up a localized string similar to Tuple element &apos;{0}&apos; is not numeric..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleOutsideTableConstraint">
            <summary>
              Looks up a localized string similar to For a Tuple to appear outside a table constraint, the first column must be of type Probability..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTuplesCanOnlyBeAssignedToListOfLists">
            <summary>
              Looks up a localized string similar to Tuples can only be assigned to a list of lists..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidTupleWrongArity">
            <summary>
              Looks up a localized string similar to Expected a Tuple with {0} arguments..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidWrongArgumentCount">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; requires exactly {1} argument(s)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlInvalidWrongTypeInAssignment">
            <summary>
              Looks up a localized string similar to The value assigned to &apos;{0}&apos; has the wrong type..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlParameter">
            <summary>
              Looks up a localized string similar to Parameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlParseExceptionLocationFormat0123">
            <summary>
              Looks up a localized string similar to &lt;{0}, {1}&gt; - &lt;{2}, {3}&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlRecourseMustContainAtLeastOneDecision">
            <summary>
              Looks up a localized string similar to Recourse sections must contain exactly one decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlSymbolUsedForDecision0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; symbol has been used for a decision and cannot be used for a parameter..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlSymbolUsedForDifferentType01">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; symbol has been used for different type of {1}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OmlSymbolUsedForParameter0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; symbol has been used for a parameter and cannot be used for a decision..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OneOnlyAddressAllowed">
            <summary>
              Looks up a localized string similar to One, and one only address allowed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OneOrMoreSolversWereNotAbortedWithinWaitLimitSpecified">
            <summary>
              Looks up a localized string similar to One or more solvers were not aborted within the wait limit specified in the directive. If this problem persists, increase Directive.WaitLimit..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyAppliesToAList">
            <summary>
              Looks up a localized string similar to {0} only applies to a List.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyBinddataClausesAllowed">
            <summary>
              Looks up a localized string similar to Only bind data clauses allowed in Input section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyConstantValuesAreAllowedForTheIterationSetInForeachFilteredForeach">
            <summary>
              Looks up a localized string similar to Only constant values are allowed for the iteration set in Foreach/FilteredForeach.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyEnumeratedDomainsSupportStringBinding">
            <summary>
              Looks up a localized string similar to Only enumerated domains can be bound to string values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyIntegerAndEnumDecisionsMayBeProbed">
            <summary>
              Looks up a localized string similar to Only integer and enum decisions may be probed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyIntervalDomainsAreAllowedForSimplex">
            <summary>
              Looks up a localized string similar to Only interval domains are allowed for simplex.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyNumericDecisionsCanBeIndexed">
            <summary>
              Looks up a localized string similar to Only numeric decisions can be indexed..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyNumericParametersCanBeIndexed">
            <summary>
              Looks up a localized string similar to Only numeric parameters can be indexed..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyOneDomainForSetsSection">
            <summary>
              Looks up a localized string similar to Only one domain can be specify for Sets section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyOneGoalIsSupportedWithCQNSolver">
            <summary>
              Looks up a localized string similar to Only one goal is supported with Compact Quasi Newton solver..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyOneInputsection">
            <summary>
              Looks up a localized string similar to Can not have more that one Input section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyOneRowIsSupportedForCQNModel">
            <summary>
              Looks up a localized string similar to Only one row is supported for Compact Quasi Newton model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyParametersDeclaredOnParametersSectionCanBeBound">
            <summary>
              Looks up a localized string similar to Only parameters declared on a Parameters section can be bound.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyREPLACEADDAndMULTIPLYAreSupported">
            <summary>
              Looks up a localized string similar to Only REPLACE, ADD and MULTIPLY are supported.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyTwoStageProblemsAreSupported">
            <summary>
              Looks up a localized string similar to Only two-stage problems are supported.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyValidForVariables">
            <summary>
              Looks up a localized string similar to This method is only valid for variables..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyValidWhenCalledOnDecisionsWith0Indexes">
            <summary>
              Looks up a localized string similar to This method is only valid when called on decisions with {0} indexes..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyValidWhenCalledOnParametersWith0Indexes">
            <summary>
              Looks up a localized string similar to This method is only valid when called on parameters with {0} indexes..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OnlyVariablesNotRowsMayBeUsedWithinAGoalRow">
            <summary>
              Looks up a localized string similar to Only variables, not rows, may be used within a goal row.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OperationNotSupportedOnConicRows">
            <summary>
              Looks up a localized string similar to This operation is not supported on second order conic rows..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OperatorNotDefined">
            <summary>
              Looks up a localized string similar to Operator was not defined.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OptimalExitRepeatPivots0">
            <summary>
              Looks up a localized string similar to optimal: exit RepeatPivots {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OrComma">
            <summary>
              Looks up a localized string similar to Or, .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OutputDataBindingFormatNotSupportedFor0CallToSelectNotFound">
            <summary>
              Looks up a localized string similar to Output data binding format not supported for {0}: Call to Select not found..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OutputDataBindingFormatNotSupportedFor0PropertyReferenceNotFound">
            <summary>
              Looks up a localized string similar to Output data binding format not supported for {0}: Property reference not found..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OutputDataBindingFormatNotSupportedFor0UnableToCallSelectOn1">
            <summary>
              Looks up a localized string similar to Output data binding format not supported for {0}: Unable to call Select on {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OutputDataBindingFormatNotSupportedFor0UnrecognizedArgumentsToSelect">
            <summary>
              Looks up a localized string similar to Output data binding format not supported for {0}: Unrecognized arguments to Select..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.OutputOfNonLinearModelsIsNotSupported">
            <summary>
              Looks up a localized string similar to Output of non-linear models or linear models with strict inequalities are not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Overflow">
            <summary>
              Looks up a localized string similar to Overflow: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Parameter0IsNotBoundToADataSource">
            <summary>
              Looks up a localized string similar to Parameter {0} is not bound to a data source.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParametersCannotBeDisabled">
            <summary>
              Looks up a localized string similar to Parameters cannot be disabled.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParameterShouldBeAssignConstantOfItsDomain">
            <summary>
              Looks up a localized string similar to A parameter may only be assigned a constant within the correct domain and range.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParameterShouldHaveIndexes">
            <summary>
              Looks up a localized string similar to Parameter should have indexes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParameterShouldUseSetsOrBeAssignedConstant">
            <summary>
              Looks up a localized string similar to A parameter must use Sets or be assigned a constant value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParametersWithNonNumericDataAreNotSupported">
            <summary>
              Looks up a localized string similar to Parameters with non-numeric data are not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParsingModelFailed0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParsingModelFailed01">
            <summary>
              Looks up a localized string similar to Unexpected term: &apos;{1}&apos;, &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ParsingMPSFailed0">
            <summary>
              Looks up a localized string similar to Parsing MPS failed: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Phase1Optimal">
            <summary>
              Looks up a localized string similar to Phase 1 Optimal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PleaseRequestInteriorPointIpmToHandleQuadraticObjectives">
            <summary>
              Looks up a localized string similar to Please request the Interior Point Method (IPM) solver to handle quadratic objectives..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverCollectionUninitialized">
            <summary>
              Looks up a localized string similar to Accessing a PluginSolverCollection instance that has not been initialized..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidAssembly">
            <summary>
              Looks up a localized string similar to Invalid solver assembly in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidCapability">
            <summary>
              Looks up a localized string similar to Invalid solver capability in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidDirectiveClass">
            <summary>
              Looks up a localized string similar to Invalid solver directive class name in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidElement">
            <summary>
              Looks up a localized string similar to Invalid element in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidMsfPluginSolversSection">
            <summary>
              Looks up a localized string similar to Invalid MsfPluginSolvers section in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidName">
            <summary>
              Looks up a localized string similar to Invalid solver name in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidParameterClass">
            <summary>
              Looks up a localized string similar to Invalid solver parameter class name in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigInvalidSolverClass">
            <summary>
              Looks up a localized string similar to Invalid solver class name in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverConfigNullElement">
            <summary>
              Looks up a localized string similar to Null element in MsfConfig section..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverDuplicatedRegistration">
            <summary>
              Looks up a localized string similar to Duplicated solver registration in &lt;MsfPluginSolvers&gt;. The same combination of capability and solverclass can appear in this section at most once.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverError">
            <summary>
              Looks up a localized string similar to Microsoft Solver Foundation plugin solver configuration exception..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverHostEnvironmentNotSupported">
            <summary>
              Looks up a localized string similar to Plugin solvers cannot be hosted in this execution environment..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PluginSolverInconsistentRegistration">
            <summary>
              Looks up a localized string similar to Solver {0} is registered twice with the same capability..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PostFeasibilityStrategy0CannotBeUsedWithAModelThatDoesNotHaveGoals">
            <summary>
              Looks up a localized string similar to Post-feasibility strategy {0} cannot be used with a model that does not have goals..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PowerIsNotConstant">
            <summary>
              Looks up a localized string similar to Power is not constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PowerIsNotInteger">
            <summary>
              Looks up a localized string similar to Power is not integer.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PowerIsOutsideOfAllowedBounds">
            <summary>
              Looks up a localized string similar to Power is outside of allowed bounds.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PredictorLoopMuGap">
            <summary>
              Looks up a localized string similar to Predictor: loop ={0,-3}, mu {1,8:G5}, gap {2,6:G3}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PreFeasibilityStrategy0CannotBeUsedWithAModelThatDoesNotHaveGoals">
            <summary>
              Looks up a localized string similar to Pre-feasibility strategy {0} cannot be used with a model that does not have goals..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Preprocessing">
            <summary>
              Looks up a localized string similar to Preprocessing....
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PreprocessingDone">
            <summary>
              Looks up a localized string similar to  done.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PreprocessingTime0Ms">
            <summary>
              Looks up a localized string similar to Preprocessing time:      {0}ms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ProbabilitiesShouldSumupToOne">
            <summary>
              Looks up a localized string similar to Probabilities should sum up to 1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ProbabilityShouldBeMoreThanZeroAndLessOrEqualToOne">
            <summary>
              Looks up a localized string similar to Probability should be more than 0 and less or equal to 1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ProhibitedForeachInDecisions">
            <summary>
              Looks up a localized string similar to Foreach statements over indexed sets are not allowed in Decision section, use the declaration alone..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ProhibitedForeachInParameters">
            <summary>
              Looks up a localized string similar to Foreach statements over indexed sets are not allowed in Parameters section, use the declaration alone..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Property0CanOnlyBeAccessedBySolvingEventHandlers">
            <summary>
              Looks up a localized string similar to Property &apos;{0}&apos; can only be accessed by Solving event handlers..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PropertyNameIsNotSupported0">
            <summary>
              Looks up a localized string similar to Property name {0} is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PropertyRequiresADecision0">
            <summary>
              Looks up a localized string similar to The property {0} requires a Decision object, but none was supplied. Accessing Decision properties in a Solving event handler is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PunctuatorAlreadyMapped">
            <summary>
              Looks up a localized string similar to Punctuator &apos;{0}&apos; already mapped!.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.PureQuadraticGoalButUnknownWhetherMinimizeOrMaximize">
            <summary>
              Looks up a localized string similar to Pure quadratic goal but unknown whether minimizing or maximizing..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.QpModelShouldNotReferenceNonVariables">
            <summary>
              Looks up a localized string similar to Quadratic models should not reference non-variables..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.QuadraticModelOnlySupportsASingleGoalRowCanTChangeToADifferentGoalRow">
            <summary>
              Looks up a localized string similar to Quadratic models only support a single goal row. Can&apos;t change to a different goal row..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RandomParameterHasAllreadyFilledWithDistributionDetails">
            <summary>
              Looks up a localized string similar to The distribution information for this random parameter has already been specified..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RandomSeed0">
            <summary>
              Looks up a localized string similar to Random Seed: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RangeOfDomainWrongNumberOfBoundaries">
            <summary>
              Looks up a localized string similar to Range of domain should have minimum value and maximum value or not having them both.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RecursionLimitExceeded">
            <summary>
              Looks up a localized string similar to Recursion limit exceeded: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReducingError">
            <summary>
              Looks up a localized string similar to {0} Reducing error.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RejectedContractedCount0">
            <summary>
              Looks up a localized string similar to Rejected contracted: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RejectedExpandedCount0">
            <summary>
              Looks up a localized string similar to Rejected expanded: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RemovedEnteringCandidate12">
            <summary>
              Looks up a localized string similar to {0} Removed entering candidate: {1}, {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RepairedSingularBasis">
            <summary>
              Looks up a localized string similar to {0} Repaired singular basis.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Replacing0With1InBasis">
            <summary>
              Looks up a localized string similar to Replacing {0} with {1} in basis.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportCapability">
            <summary>
              Looks up a localized string similar to Capabilities Applied: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportHeaderReportOverview">
            <summary>
              Looks up a localized string similar to ===Solver Foundation Service Report===.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportHeaderSolutionDetails">
            <summary>
              Looks up a localized string similar to ===Solution Details===.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportHeaderSolverExecutionDetails">
            <summary>
              Looks up a localized string similar to ===Solver Execution Details===.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportingIsOnlySupportedForSimplexIPMAndCSPModels">
            <summary>
              Looks up a localized string similar to Reporting is only supported for LP, QP, MILP, CP, and UCNLP models..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportingNotImplementedForSolverKind0">
            <summary>
              Looks up a localized string similar to Reporting not implemented for SolverKind {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineAlgorithm">
            <summary>
              Looks up a localized string similar to Algorithm: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineBacktrackCount">
            <summary>
              Looks up a localized string similar to Backtrack Count: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineBasis">
            <summary>
              Looks up a localized string similar to Basis: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineBranches">
            <summary>
              Looks up a localized string similar to Branches: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineConstraintBounds">
            <summary>
              Looks up a localized string similar to Constraint Bounds:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineDatetime0">
            <summary>
              Looks up a localized string similar to Date: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineDecisions">
            <summary>
              Looks up a localized string similar to Decisions:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineDegeneratePivots">
            <summary>
              Looks up a localized string similar to Degenerate Pivots: {0} ({1:F2} %).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineDirectives">
            <summary>
              Looks up a localized string similar to Directives:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineEliminatedSlackVariables">
            <summary>
              Looks up a localized string similar to Eliminated Slack Variables: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineFactorings">
            <summary>
              Looks up a localized string similar to Factorings: {0} + {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineGoalCoefficients">
            <summary>
              Looks up a localized string similar to Goal Coefficients:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineGoals">
            <summary>
              Looks up a localized string similar to Goals:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineInfeasibleSet">
            <summary>
              Looks up a localized string similar to Infeasible set:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineIterations">
            <summary>
              Looks up a localized string similar to Iterations: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineModelName">
            <summary>
              Looks up a localized string similar to Model Name: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineMoveSelection">
            <summary>
              Looks up a localized string similar to Move Selection: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineNonzeros">
            <summary>
              Looks up a localized string similar to Nonzeros: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineNumericFormatDouble">
            <summary>
              Looks up a localized string similar to Arithmetic: Double.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineNumericFormatExact">
            <summary>
              Looks up a localized string similar to Arithmetic: Exact.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineNumericFormatHybrid">
            <summary>
              Looks up a localized string similar to Arithmetic: Hybrid.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLinePhase1Pivots">
            <summary>
              Looks up a localized string similar to Phase 1 Pivots: {0} + {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLinePhase2Pivots">
            <summary>
              Looks up a localized string similar to Phase 2 Pivots: {0} + {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLinePivotCount">
            <summary>
              Looks up a localized string similar to Pivot Count: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLinePricingDouble">
            <summary>
              Looks up a localized string similar to Pricing (double): {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLinePricingExact">
            <summary>
              Looks up a localized string similar to Pricing (exact): {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineRows">
            <summary>
              Looks up a localized string similar to Rows: {0} -&gt; {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineShadowPricing">
            <summary>
              Looks up a localized string similar to Shadow Pricing:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineSolveCompletionStatus">
            <summary>
              Looks up a localized string similar to Solve Completion Status: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineSolverSelected">
            <summary>
              Looks up a localized string similar to Solver Selected: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineSolveTimeMs">
            <summary>
              Looks up a localized string similar to Solve Time (ms): {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineTotalTimeMs">
            <summary>
              Looks up a localized string similar to Total Time (ms): {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineValueSelection">
            <summary>
              Looks up a localized string similar to Value Selection: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineVariables">
            <summary>
              Looks up a localized string similar to Variables: {0} -&gt; {1} + {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineVariables01">
            <summary>
              Looks up a localized string similar to Variables: {0} -&gt; {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineVariableSelection">
            <summary>
              Looks up a localized string similar to Variable Selection: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReportLineVersion0">
            <summary>
              Looks up a localized string similar to Version: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Rescue">
            <summary>
              Looks up a localized string similar to rescue....
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Result0">
            <summary>
              Looks up a localized string similar to result = {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ResultNeedsToBeInteger">
            <summary>
              Looks up a localized string similar to The result cannot be converted to Int32. Either the successProbability argument of the distribution is too small, or probability argument is too big..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ReturnedASolutionInAnUnknownFormat">
            <summary>
              Looks up a localized string similar to OML returned a solution in an unknown format.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Row0AlreadyExistsInDestinationModel">
            <summary>
              Looks up a localized string similar to Row &apos;{0}&apos; already exists in destination model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RowIndexesDidNotSortCorrectly">
            <summary>
              Looks up a localized string similar to row indexes did not sort correctly.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RowIsUnbounded">
            <summary>
              Looks up a localized string similar to row {0} is unbounded.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RowNeedsToBeDifferentiatedButIsNotDifferentiable01">
            <summary>
              Looks up a localized string similar to Row {0} needs to be differentiated but {1} is not a differentiable operation..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RuleApplicationFailed">
            <summary>
              Looks up a localized string similar to rule application failed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.RuleShouldHaveTwoParameters">
            <summary>
              Looks up a localized string similar to Rule (&apos;-&gt;&apos;) should have two parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SameParametersBoundMoreThanOnce">
            <summary>
              Looks up a localized string similar to Detected multiple bindings on a single parameter. Please make sure parameters are bound only once..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Sampled">
            <summary>
              Looks up a localized string similar to Sampled.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SampleMethod0">
            <summary>
              Looks up a localized string similar to Sampling Method: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SamplesCount0">
            <summary>
              Looks up a localized string similar to Sample Count: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SamplingGettingQuantileFromTheBinomialDistributionFailed">
            <summary>
              Looks up a localized string similar to Sampling/getting Quantile from the Binomial distribution failed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SATSolverCantProcessTheModel01">
            <summary>
              Looks up a localized string similar to SAT solver can&apos;t process the model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ScenariosCount0">
            <summary>
              Looks up a localized string similar to Scenarios Count: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ScenariosMustIncludeOneElement">
            <summary>
              Looks up a localized string similar to Scenarios must include one element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SearchFirstListElementsMustBePreDeclaredVariables">
            <summary>
              Looks up a localized string similar to SearchFirst list elements must be pre-declared Variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SearchFirstTermError">
            <summary>
              Looks up a localized string similar to SearchFirst contains Terms not belonging to this Solver .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SecondArgMustBeAConstant">
            <summary>
              Looks up a localized string similar to {0} second arg must be a constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SecondArgMustBeNonnegative">
            <summary>
              Looks up a localized string similar to {0} second arg must be nonnegative.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SecondStageApproximationIsBetterThanSecondStageResult">
            <summary>
              Looks up a localized string similar to The second stage approximation is better that the actual second stage problem result..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SecondStageDecisionsValuesAverageMinimalMaximal">
            <summary>
              Looks up a localized string similar to Second stage decisions (Average [Min, Max]):.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SectionIsValidForConicModelsOnly0">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is valid for conic models only..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetBindingMayNotBeCalledOnASetWithFixedValues">
            <summary>
              Looks up a localized string similar to SetBinding may not be called on a Set with fixed values..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListEmptyListUsedInElementAt">
            <summary>
              Looks up a localized string similar to The ElementAt operator cannot take an empty constant list variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListIncompatibleDomainKind">
            <summary>
              Looks up a localized string similar to The value kind of the domains are incompatible for the set/list operator.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListIncompatibleIndex">
            <summary>
              Looks up a localized string similar to The index Term in ElementAt operator must have an interval integer domain from 0 to the maximal length of lists in listVar - 1 .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListNonscalorElement">
            <summary>
              Looks up a localized string similar to A composite variable (set/list variable) appears where a scalar variable is expected .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListNonscalorIndex">
            <summary>
              Looks up a localized string similar to The index Term in ElementAt operator must be an integer variable .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListNullBaseline">
            <summary>
              Looks up a localized string similar to The baseline set of the power-set/power-list variable is null .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListNullInput">
            <summary>
              Looks up a localized string similar to The argument to the set/list operator is null .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListOccurrenceResultNotInteger">
            <summary>
              Looks up a localized string similar to The result Term in FirstOccurrence and LastOccurrence must be an Integer Term .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListSymbolSetVarNotAllowed">
            <summary>
              Looks up a localized string similar to Cannot do Union, Intersection, or Difference on Symbol set variables with different baselines .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListVarEmptyDomain">
            <summary>
              Looks up a localized string similar to The set/list variable&apos;s baseline domain cannot be empty .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListWrongDomain">
            <summary>
              Looks up a localized string similar to The argument variable&apos;s domain must be CspPowerSet or CspPowerList in set/list operator .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetListWrongSubset">
            <summary>
              Looks up a localized string similar to The constant subset must be an array of ordered unique elements .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SetsOfEnumValuesAreNotSupportedUseDomainAnyInstead">
            <summary>
              Looks up a localized string similar to Sets of Enum values are not supported. Use Domain.Any instead..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelCannotCreateInstanceOfEmptySubmodel">
            <summary>
              Looks up a localized string similar to Cannot create instance of an empty Submodel &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelCannotInstantiateRemovedSubmodel">
            <summary>
              Looks up a localized string similar to Submodel &apos;{0}&apos; is removed. Cannot instantiate it any more.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelCannotInstantiateRootModel">
            <summary>
              Looks up a localized string similar to Root model cannot be instantiated.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelCannotModifyModels">
            <summary>
              Looks up a localized string similar to The submodel &apos;{0}&apos; is already instantiated and can no longer be modified..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelCannotRemoveInstantiatedSubmodel">
            <summary>
              Looks up a localized string similar to Submodel &apos;{0}&apos; is already instantiated and cannot be removed..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelExceedNestingLimit">
            <summary>
              Looks up a localized string similar to Submodel nesting exceeds the limit of {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelInstanceNotFound">
            <summary>
              Looks up a localized string similar to Decision member not found in the SubmodelDecision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SfsSubmodelSubmodelInstanceNotFound">
            <summary>
              Looks up a localized string similar to SubmodelDecision member not found in the SubmodelDecision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SimplexSolverCantProcessTheModel01">
            <summary>
              Looks up a localized string similar to Simplex solver can&apos;t process the model: &apos;{0}&apos;, &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SimplexSolverSymbolIsMissing">
            <summary>
              Looks up a localized string similar to SimplexSolver symbol is missing.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SingularBasis">
            <summary>
              Looks up a localized string similar to Singular basis!.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SizeOfSubmatrixIsFault">
            <summary>
              Looks up a localized string similar to Size of sub matrix is fault.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SizesDoNotMatch">
            <summary>
              Looks up a localized string similar to The sizes of {0} and {1} do not match..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SMPSCanOnlyBeParsedUsingFileOrDirectoryPath">
            <summary>
              Looks up a localized string similar to SMPS can only be parsed using a file or directory path.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionAcceptedAlg0Res1Vals2FMip3">
            <summary>
              Looks up a localized string similar to Solution accepted: alg={0}, res={1}, vals={2}, fMip={3}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionIsOutOfDate">
            <summary>
              Looks up a localized string similar to The solution is out of date..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionMappingArgumentIsNotAPluginSolutionMappingObject">
            <summary>
              Looks up a localized string similar to solutionMapping argument is not a PluginSolutionMapping object..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionMappingIsNotALinearSolutionMapping">
            <summary>
              Looks up a localized string similar to The solutionMapping argument is not a LinearSolutionMapping object..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionQualityIs0">
            <summary>
              Looks up a localized string similar to Solution quality is: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolutionRejectedAlg0Res1Vals2FMip3">
            <summary>
              Looks up a localized string similar to Solution rejected: alg={0}, res={1}, vals={2}, fMip={3}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolveMethodNeededToBeCalledBeforeCheckingSolution">
            <summary>
              Looks up a localized string similar to Solve method needed to be called before checking for solution details.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverContextCannotBeNull">
            <summary>
              Looks up a localized string similar to ISolverEnvironment parameter cannot be null when calling PluginSolverCollection.GetSolvers or PluginSolverCollection.GetDefaultSolver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotImplementInterface">
            <summary>
              Looks up a localized string similar to {0} is registered with the {1} interface but does not support it.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotSupportBoundedVariables">
            <summary>
              Looks up a localized string similar to {0} does not support bounded variables. Remove this directive and use a directive that supports bounded variables..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotSupportConstrainedModels">
            <summary>
              Looks up a localized string similar to {0} does not support constrained models. Remove this directive and use a directive that supports constrained models..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotSupportGettingOrSettingProperties">
            <summary>
              Looks up a localized string similar to Solver does not support getting or setting properties.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotSupportNonDifferentiableModels">
            <summary>
              Looks up a localized string similar to {0} does not support non-differentiable models. Remove this directive and use a directive that supports non-differentiable models..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverDoesNotSupportOperation">
            <summary>
              Looks up a localized string similar to {0} does not support the operation {1}. Remove this directive and use a directive that supports {1}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverInterfaceNotSupported">
            <summary>
              Looks up a localized string similar to The solver interface {0} does not exist or is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverMustBeConstraintSystem">
            <summary>
              Looks up a localized string similar to Solver must be ConstraintSystem.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverMustBeSimplexSolver">
            <summary>
              Looks up a localized string similar to Solver must be SimplexSolver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverMustImplementIInteriorPointStatistics">
            <summary>
              Looks up a localized string similar to Solver must implement IInteriorPointStatistics.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverMustImplementILinearModel">
            <summary>
              Looks up a localized string similar to Solver must implement ILinearModel.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverMustImplementILinearSimplexStatistics">
            <summary>
              Looks up a localized string similar to Solver must implement ILinearSimplexStatistics.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverOptionMustBeSimplex0">
            <summary>
              Looks up a localized string similar to &apos;Solver&apos; option must be &apos;Simplex&apos;: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverParamtersCouldNotBeEmpty">
            <summary>
              Looks up a localized string similar to Simplex must receive at least one SimplexSolverParams object..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverRequiresFunctionEvaluatorToBeSpecifiedBeforeCallingSolve">
            <summary>
              Looks up a localized string similar to The solver requires FunctionEvaluator to be specified before calling solve..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverResetDuringSolve">
            <summary>
              Looks up a localized string similar to Solver has been Reset. Cannot continue solving for the next solution..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolverSolutionQuality0">
            <summary>
              Looks up a localized string similar to Solver solution quality: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SolvingMethod0">
            <summary>
              Looks up a localized string similar to Solving Method: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SOS1ConstraintsAreNotSupportedInOML">
            <summary>
              Looks up a localized string similar to SOS1 constraints are not supported in OML.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SOS2ConstraintsAreNotSupportedInOML">
            <summary>
              Looks up a localized string similar to SOS2 constraints are not supported in OML.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Sos2NeedsAtLeastTwoDecisions">
            <summary>
              Looks up a localized string similar to Right-hand clause in Sos2 must contain at least two decisions..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SOS2NotSupported">
            <summary>
              Looks up a localized string similar to Only steepest edge pricing is supported with the SOS2 models.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SOSRowNameMissing">
            <summary>
              Looks up a localized string similar to Miss SOS reference row name.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SourceModelContainsDuplicateKeys">
            <summary>
              Looks up a localized string similar to Source model contains duplicate keys.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SpansNotCompatible">
            <summary>
              Looks up a localized string similar to Spans not compatible.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SparseDomainWithIncorrectIndexes">
            <summary>
              Looks up a localized string similar to SparseDomain with incorrect indexes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StartingPoint">
            <summary>
              Looks up a localized string similar to Starting point = .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StartingPointDimensionalityDiffersFromObjectiveFunction">
            <summary>
              Looks up a localized string similar to Starting point dimensionality is not the same as the objective function.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StartingPointShouldBeNumber">
            <summary>
              Looks up a localized string similar to The starting point should be a numeric value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StartingPointShouldBeNumbers">
            <summary>
              Looks up a localized string similar to Values for starting point should be numbers.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StatisticalLowerBound01">
            <summary>
              Looks up a localized string similar to Statistical Lower Bound: {0} +- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StatisticalUpperBound01">
            <summary>
              Looks up a localized string similar to Statistical Upper Bound: {0} +- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StepCount0">
            <summary>
              Looks up a localized string similar to Step count: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticCoreFileShouldHaveOneOfThoseSuffixes0">
            <summary>
              Looks up a localized string similar to Stochastic core file should have one of the following suffixes: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticFileCannotBeFound0">
            <summary>
              Looks up a localized string similar to {0} stochastic file cannot be found.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticMeasures">
            <summary>
              Looks up a localized string similar to Stochastic Measures:.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticModelCannotContainMoreThanOneGoal">
            <summary>
              Looks up a localized string similar to Multiple goals are not allowed in stochastic models..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticModelCannotHaveSOS2Constraints">
            <summary>
              Looks up a localized string similar to SOS2 constraints are not allowed in stochastic models..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticModelCanOnlyBeSavedToAnOMLFile">
            <summary>
              Looks up a localized string similar to Stochastic models can only be saved in OML format..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticModelMustContainAGoal">
            <summary>
              Looks up a localized string similar to Stochastic models must contain a goal..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticModelsMustBeLinear">
            <summary>
              Looks up a localized string similar to Stochastic models must be linear. Verify there are no nonlinear terms in the goal or constraints..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StochasticNeedRecourseDecisionsAndRandomParameters">
            <summary>
              Looks up a localized string similar to Stochastic models need to have both recourse decisions and random parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Strategy01">
            <summary>
              Looks up a localized string similar to Strategy : {0} ({1}).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StringDomainIncompatible">
            <summary>
              Looks up a localized string similar to Incompatible symbol domain .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StringDomainNotSupported">
            <summary>
              Looks up a localized string similar to This function does not support inputs with symbol domains .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.StringIsNotAMemberOfEnumeratedDomain">
            <summary>
              Looks up a localized string similar to String is not a member of enumerated domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SumOfAllProbabilitiesShouldNotExceedOne">
            <summary>
              Looks up a localized string similar to Sum of all probabilities should not exceed 1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolAlreadyHasAScope">
            <summary>
              Looks up a localized string similar to Symbol already has a scope.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolicFactorizationTime0SecType1">
            <summary>
              Looks up a localized string similar to Symbolic factorization time = {0:F2} sec, type = {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolicFactorNonzeros0">
            <summary>
              Looks up a localized string similar to {3}: columns = {0}, nonzeros = {1}, sp = {2:F3}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolIsReserved0">
            <summary>
              Looks up a localized string similar to Expression contains the reserved symbol {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolNotFoundInDomain">
            <summary>
              Looks up a localized string similar to Symbol &quot;{0}&quot;not found in the domain of {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolScopeAlreadyBoundToAnExpression">
            <summary>
              Looks up a localized string similar to SymbolScope already bound to an expression.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymbolWithDomainCouldNotBeMadeAVariable">
            <summary>
              Looks up a localized string similar to Symbol {0} with domain {1} could not be made a Variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SymmetricSparseMatrixDoesNotSupportElementInsertion">
            <summary>
              Looks up a localized string similar to SymmetricSparseMatrix does not support element insertion.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SyntaxError012">
            <summary>
              Looks up a localized string similar to Syntax error: {0}, {1}, {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.SystemErrorCannotScheduleTasks">
            <summary>
              Looks up a localized string similar to system error cannot schedule tasks.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TableMismachedDimension">
            <summary>
              Looks up a localized string similar to Each row array of a table must have the same dimension as the column variable array .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TaskCreationFailed">
            <summary>
              Looks up a localized string similar to Task creation failed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TermHasBeenAddedToAModel01">
            <summary>
              Looks up a localized string similar to Term &apos;{0}&apos; has been added to model &apos;{1}&apos; and cannot be added to other models.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheArityOfTheTupleMustBeTheSameAsTheArityOfTheVariableTuple">
            <summary>
              Looks up a localized string similar to The arity of the tuple must be the same as the arity of the variable tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheArityOfTuplesInTheListMustBeTheSameAsTheArityOfTheVariableTuple">
            <summary>
              Looks up a localized string similar to The arity of tuples in the list must be the same as the arity of the variable tuple.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheCutIsInvalid0">
            <summary>
              Looks up a localized string similar to The cut is invalid. {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheFirstArgumentToElementOfMustBeAList">
            <summary>
              Looks up a localized string similar to The first argument to ElementOf must be a list.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheGoalCouldNotBeAddedToTheModel">
            <summary>
              Looks up a localized string similar to The goal could not be added to the model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheLowerBoundAndTheUpperBoundMustBeFiniteNumbers">
            <summary>
              Looks up a localized string similar to The lower bound and the upper bound must be finite numbers..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheMeanMustBeAFiniteNumberStandardDeviationMustBeANonNegativeNumber">
            <summary>
              Looks up a localized string similar to The mean must be a finite number and the standard deviation must be a non-negative number..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheMeanOfLogMustBeAFiniteNumberStandardDeviationOfLogMustBeANonNegativeNumber">
            <summary>
              Looks up a localized string similar to The mean of the logarithm of the distribution must be a finite number and the standard deviation of the logarithm of the distribution must be a non-negative number..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheMethodOrOperationIsNotImplemented">
            <summary>
              Looks up a localized string similar to The method or operation is not implemented..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheModelIsEmpty">
            <summary>
              Looks up a localized string similar to The model is empty.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheModelMustContainAGoal">
            <summary>
              Looks up a localized string similar to The model must contain a goal..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheNumberOfIndexPropertiesMustMatchTheNumberOfIndexSets">
            <summary>
              Looks up a localized string similar to The number of index properties must match the number of index sets..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheNumberOfValuePropertiesMustMatchTheNumberOfElementsInTheTuple">
            <summary>
              Looks up a localized string similar to The number of value properties must match the number of elements in the tuple..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThePropertyOrField0WasNotFound">
            <summary>
              Looks up a localized string similar to The property or field &apos;{0}&apos; was not found..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThePropertyOrField0WasNotFoundOnType1">
            <summary>
              Looks up a localized string similar to The property or field &apos;{0}&apos; was not found on type &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheRateMustBeAFinitePositiveNumber">
            <summary>
              Looks up a localized string similar to The rate must be a finite positive number..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThereIsAlreadyAnActiveModelInTheContext">
            <summary>
              Looks up a localized string similar to There is already an active model in the context..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThereIsNoSolutionToPropagate">
            <summary>
              Looks up a localized string similar to There is no solution to propagate.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThereShouldBeAtLeastOneScenario">
            <summary>
              Looks up a localized string similar to There should be at least one scenario.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheRowDoesNotSumTo0">
            <summary>
              Looks up a localized string similar to The row does not sum to 0. .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheSolverDoesNotSupportSos1">
            <summary>
              Looks up a localized string similar to The solver does not support Sos1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheSolverDoesNotSupportSos2">
            <summary>
              Looks up a localized string similar to The solver does not support Sos2.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheSolverSThrewAnExceptionWhileSolvingTheModel">
            <summary>
              Looks up a localized string similar to The solver(s) threw an exception while solving the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheSuccessProbabilityMustBeANonZeroProbability">
            <summary>
              Looks up a localized string similar to The success probability must be a non-zero probability..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheSuccessProbabilityMustBeAProbabilityAndTheNumberOfTrialsMustBeAPositiveNumber">
            <summary>
              Looks up a localized string similar to The success probability must be a probability and the number of trials must be a positive number..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheValue0IsNotAnAllowable1Value">
            <summary>
              Looks up a localized string similar to The value {0} is not an allowable {1} value..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TheValue0WasNotPresentInTheEnumeratedDomain">
            <summary>
              Looks up a localized string similar to The value &quot;{0}&quot; was not present in the enumerated domain..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThisCanNotExpressDomain">
            <summary>
              Looks up a localized string similar to The Term does not express a domain..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThisSolverDoesNotSupportSettingAPropertyWhileSolving">
            <summary>
              Looks up a localized string similar to This solver does not support setting a property while solving..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ThisVersionOfTheProductHasExpiredPleaseContactMicrosoftCorporationForLicensingOptions">
            <summary>
              Looks up a localized string similar to This version of the product has expired. Please contact Microsoft Corporation for licensing options..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Timeout">
            <summary>
              Looks up a localized string similar to Interrupted due to time-out or user&apos;s request.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TimeToFirstSolution">
            <summary>
              Looks up a localized string similar to Time to first Solution : .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TokensNotInSameVersion">
            <summary>
              Looks up a localized string similar to Tokens not in same version.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ToleranceDifference0">
            <summary>
              Looks up a localized string similar to Tolerance difference: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ToleranceTooLow">
            <summary>
              Looks up a localized string similar to Tolerance is too low.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TreeSearchStatsPerSec">
             <summary>
               Looks up a localized string similar to ({0} per sec)
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TreeSearchStatsTotalNbEvents010">
            <summary>
              Looks up a localized string similar to Total nb events:         {0,-10} .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TreeSearchStatsTotalNbNodes010">
            <summary>
              Looks up a localized string similar to Total nb nodes:          {0,-10} .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TreeSearchStatsTotalTime0Ms">
             <summary>
               Looks up a localized string similar to Total time:              {0}ms
            .
             </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TryGetShouldNotReturnFalse">
            <summary>
              Looks up a localized string similar to TryGet should not return false.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TupleDataDoesNotBelongToDomainSpecifiedIn01">
            <summary>
              Looks up a localized string similar to Tuple data {0} does not belong to the domain {1} specified in the Tuples definition.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Tuples0IsNotBoundToADataSource">
            <summary>
              Looks up a localized string similar to Tuples {0} is not bound to a data source.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TuplesDefinedAsARandomParameterCannotBeUsedInTableConstraint">
            <summary>
              Looks up a localized string similar to Tuples defined as a Random Parameter cannot be used in Table Constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TuplesMustBeAddedToTheModelBeforeBeingUsed">
            <summary>
              Looks up a localized string similar to Tuples must be added to the model before being used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TuplesMustIncludeAtLeastOneElement">
            <summary>
              Looks up a localized string similar to Tuples must include at least one element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TuplesParameterDataMustBeAListOfLists">
            <summary>
              Looks up a localized string similar to Tuples parameter data must be a list of lists.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TuplesParametersCannotBeIndexed">
            <summary>
              Looks up a localized string similar to Tuples parameters cannot be indexed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TwoAreNull01">
            <summary>
              Looks up a localized string similar to Both {0} and {1} are null.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.TypeOfStochasticSolution0">
            <summary>
              Looks up a localized string similar to Stochastic Solution Type: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UndefinedSubmodelInstance">
            <summary>
              Looks up a localized string similar to Undefined submodel instance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedColumnKind">
            <summary>
              Looks up a localized string similar to unexpected column kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedINTENDMarker">
            <summary>
              Looks up a localized string similar to Unexpected &apos;INTEND&apos; marker.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnExpectedNeedToBe01">
            <summary>
              Looks up a localized string similar to Unexpected term ‘{0}’. Expected: ‘{1}’.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedNeedToBe012">
            <summary>
              Looks up a localized string similar to Unexpected term ‘{0}’. Expected: ‘{1}’ or &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedNeedToBe01orEndOfFile">
            <summary>
              Looks up a localized string similar to Unexpected term ‘{0}’. Expected: ‘{1}’ or end of file.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedTerm0">
            <summary>
              Looks up a localized string similar to Unexpected term ‘{0}’..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnexpectedTermAfterTerm01">
            <summary>
              Looks up a localized string similar to Unexpected term &apos;{0}&apos; after &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownConeId0">
            <summary>
              Looks up a localized string similar to Unknown cone id: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownDataValue0">
            <summary>
              Looks up a localized string similar to Unknown data value {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownDomainEncountered">
            <summary>
              Looks up a localized string similar to Unknown domain encountered.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownDomainType">
            <summary>
              Looks up a localized string similar to Domain type is unknown .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownKindDetectedInSave">
            <summary>
              Looks up a localized string similar to Unknown kind detected in save.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownMarker">
            <summary>
              Looks up a localized string similar to Unknown marker: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownModelerType">
            <summary>
              Looks up a localized string similar to The modeler inside a Term is unknown .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownOperation0">
            <summary>
              Looks up a localized string similar to Unknown operation id: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownPluginAssembly">
            <summary>
              Looks up a localized string similar to Cannot load the plug-in solver assembly {0}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownPluginSolverParameterType">
            <summary>
              Looks up a localized string similar to Cannot find the plug-in solver parameter class {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownPluginSolverType">
            <summary>
              Looks up a localized string similar to Cannot find the plug-in solver class {0} or it does not implement {1} interface.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownQuality">
            <summary>
              Looks up a localized string similar to Unknown quality {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownRow">
            <summary>
              Looks up a localized string similar to Unknown row: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownRowVariableIndex">
            <summary>
              Looks up a localized string similar to Unknown row variable index: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownString">
            <summary>
              Looks up a localized string similar to Symbol does not belong to the symbol domain .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownSupportedMPSFieldQUADOBJ">
            <summary>
              Looks up a localized string similar to Unknown supported MPS field: QUADOBJ.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownVariable">
            <summary>
              Looks up a localized string similar to The variable given is unknown.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownVariable0">
            <summary>
              Looks up a localized string similar to Unknown variable: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknownVariableId">
            <summary>
              Looks up a localized string similar to Unknown variable id: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnknowTermType">
            <summary>
              Looks up a localized string similar to The Term has unknown type .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnmatchedSizesOfListsInSumProduct">
            <summary>
              Looks up a localized string similar to Unmatched sizes of lists in SumProduct.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnnecessaryChange">
            <summary>
              Looks up a localized string similar to Internal Error: unnecessary change on the variable .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnrecognizedCspTerm">
            <summary>
              Looks up a localized string similar to Unrecognized constraint programming solver term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnrecognizedTerm">
            <summary>
              Looks up a localized string similar to Unrecognized term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnsignedLongOperatorInputInvalid">
            <summary>
              Looks up a localized string similar to The input to an unsigned long operator must be either an integer variable or an unsigned long variable .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnsignedLongVarInvalid">
            <summary>
              Looks up a localized string similar to The given Term is not an unsigned long variable .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UnsupportedModelType">
            <summary>
              Looks up a localized string similar to Unsupported model type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.UpperTriangularCoordinateSeen">
            <summary>
              Looks up a localized string similar to upper triangular coordinate seen.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ValueInElementOfIsNotAnInteger">
            <summary>
              Looks up a localized string similar to Value in ElementOf is not an integer..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ValueIsNotLinearOrQuadratic">
            <summary>
              Looks up a localized string similar to Value is not linear or quadratic.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ValueSetCannotBeEmpty">
            <summary>
              Looks up a localized string similar to Value set cannot be empty.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.ValuesForSymbolAreLocked">
            <summary>
              Looks up a localized string similar to Values for symbol &apos;{0}&apos; are locked..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Variable0AlreadyExistsInDestinationModel">
            <summary>
              Looks up a localized string similar to Variable &apos;{0}&apos; already exists in destination model..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableAlreadyBelongsToAnotherCone">
            <summary>
              Looks up a localized string similar to Variable already belongs to another cone..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableDomainDoesNotContainCorrectIntegerValues">
            <summary>
              Looks up a localized string similar to Variable domain does not contain correct integer values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableDomainExceedsCspSolverIntegerDomain">
            <summary>
              Looks up a localized string similar to Variable domain exceeds CspSolver integer domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableHasAlreadyBeenAddedToTheModel">
            <summary>
              Looks up a localized string similar to Variable has already been added to the model: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableHasEmptyValueSet">
            <summary>
              Looks up a localized string similar to Variable has empty value set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableMustBeAddedToSolverBeforeUse">
            <summary>
              Looks up a localized string similar to Variable must be added to solver before use.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableMustBeAddedToSolverBeforeUseInConstraint">
            <summary>
              Looks up a localized string similar to Variable must be added to solver before use in constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableMustBeBasedOnAUserSymbol">
            <summary>
              Looks up a localized string similar to Variable must be based on a user symbol.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableNotFoundInSolution">
            <summary>
              Looks up a localized string similar to variable not found in solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableSeenWithUnrecognizedDomain">
            <summary>
              Looks up a localized string similar to Variable seen with unrecognized Domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VariableShouldBe0ButIs">
            <summary>
              Looks up a localized string similar to Variable {0} should be 0 but is {1}..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VersionEnterprise">
            <summary>
              Looks up a localized string similar to Enterprise.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VersionEvaluation">
            <summary>
              Looks up a localized string similar to Evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VersionExpress">
            <summary>
              Looks up a localized string similar to Express.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.VersionStandard">
            <summary>
              Looks up a localized string similar to Standard.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Violation0">
            <summary>
              Looks up a localized string similar to Violation: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.Vss0">
            <summary>
              Looks up a localized string similar to VSS: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WanderedToDualInfeasible1">
            <summary>
              Looks up a localized string similar to {0} Wandered to dual infeasible: {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WanderedToInfeasible1">
            <summary>
              Looks up a localized string similar to  pivot count: {0} Method Wandered to infeasible: {1}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WeAreMissingAnEmumForTheConstraintValueInTheFeatureExtraction">
            <summary>
              Looks up a localized string similar to Unknown feature name.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WriteMpsNeedsAModelOrSimplexSolverOptionallyFollowedByABooleanIndicatingFixedTrueOrFreeFalse">
            <summary>
              Looks up a localized string similar to WriteMps needs a Model or simplex solver, optionally followed by a boolean indicating fixed (True) or free (False)..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongArgumentPowerExpectsExponent1">
            <summary>
              Looks up a localized string similar to wrong argument: power expects exponent &gt;= 1.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongBasicVariableValue012">
            <summary>
              Looks up a localized string similar to Wrong basic variable value! {0} {1} {2}.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongDecisionDeclarationInForeach">
            <summary>
              Looks up a localized string similar to Wrong decision declaration in Foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongErrorType">
            <summary>
              Looks up a localized string similar to Can not deal with that error type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongLineInINDEPSection">
            <summary>
              Looks up a localized string similar to Wrong line in INDEP section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongLineInPERIODSSection">
            <summary>
              Looks up a localized string similar to Wrong line in PERIODS section.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongMIPNumerics">
            <summary>
              Looks up a localized string similar to MIP Solver currently has to use hybrid or exact numerics.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongNumberOfRandomNumbers01">
            <summary>
              Looks up a localized string similar to {0} random numbers are expected as input, but {1} were supplied.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongParameterAssignClause">
            <summary>
              Looks up a localized string similar to Wrong parameter assign clause.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongParameterAssignInForeachStatement">
            <summary>
              Looks up a localized string similar to Wrong parameter assign in Foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongSyntaxForDomain">
            <summary>
              Looks up a localized string similar to Wrong syntax for domain. Try to use DomainSymbol[min, max] instead..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongSyntaxParameterTwoInvocation">
            <summary>
              Looks up a localized string similar to Wrong syntax for parameter. Try to use param[set1, set2, ...] instead..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongVariableIdentifier0KeysShouldBeNonNullAndUnique">
            <summary>
              Looks up a localized string similar to Wrong variable identifier {0} (keys should be non-null and unique).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.WrongVariableType">
            <summary>
              Looks up a localized string similar to Given variable&apos;s kind is different from the version of the ConstraintSolverSolution.GetValue method called.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.XIsNull0">
            <summary>
              Looks up a localized string similar to {0} cannot be null..
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Properties.Resources.XLessThanY01">
            <summary>
              Looks up a localized string similar to {0} is less than {1}.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.BigRegister">
            <summary>
            BigRegister holds a multiprecision unsigned integer value. It is mutable and
            supports common arithmetic operations. Be careful NOT to simply assign one
            BigRegister to another, unless you really know what you are doing. The proper
            way to replicate a BigRegister is via the constructor "BigRegister(ref BigRegister reg)",
            or with reg1.Load(ref reg2). Using the ctor marks the buffer as shared so changing the
            value of one register will not affect the other. Using Load copies the contents from
            one to the other. Either way, the internal buffer isn't aliased incorrectly.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            An arbitary pecision integer 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Implicit(System.Int32)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert an int to a BigInteger
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Implicit(System.UInt32)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert an unsigned int to a BigInteger
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Implicit(System.Int64)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert a long to a BigInteger
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Implicit(System.UInt64)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert a unsinged long to a BigInteger
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(Microsoft.SolverFoundation.Common.BigInteger)~System.Int32">
            <summary>
            convert BigInteger to int 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(Microsoft.SolverFoundation.Common.BigInteger)~System.UInt32">
            <summary>
            convert BigInteger to unsigned int 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(Microsoft.SolverFoundation.Common.BigInteger)~System.Int64">
            <summary>
            convert BigInteger to long 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(Microsoft.SolverFoundation.Common.BigInteger)~System.UInt64">
            <summary>
            convert BigInteger to unsigned long 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(Microsoft.SolverFoundation.Common.BigInteger)~System.Double">
            <summary>
            convert BigInteger to double 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Explicit(System.Double)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert double to BigInteger
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_BitwiseAnd(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger And operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_BitwiseOr(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger | operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_ExclusiveOr(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger ^ operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LeftShift(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            BigInteger left shift operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_RightShift(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            BigInteger right shift operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_OnesComplement(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger ~ operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.TestBit(System.Int64)">
            <summary>
            TestBit 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Negate(Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            inplace negate a BigInteger
            </summary>
            <param name="bn"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_UnaryNegation(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            negate a BigInteger
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_UnaryPlus(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger + operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Increment(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger ++ operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Decrement(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            BigInteger -- operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Addition(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Add two BigIntegers
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Subtraction(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Minus two BigIntegers
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Multiply(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Times two BigIntegers
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Division(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Divide two BigIntegers
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Modulus(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            mod two BigIntegers
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.DivModOne(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32,Microsoft.SolverFoundation.Common.BigInteger@,Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            Divide a BigInterg by uDen, return the quotient and the remainder.
            </summary>
            <param name="bnNum"></param>
            <param name="uDen"></param>
            <param name="bnQuo"></param>
            <param name="bnRem"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.DivMod(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger@,Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            Divide a BigInterg by uDen, return the quotient and the remainder.
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <param name="bnQuo"></param>
            <param name="bnRem"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Gcd(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compute GCD of two BigIntergers
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Power(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            Compute power of two BigIntergers, and return a BigInteger
            </summary>
            <param name="bnBase"></param>
            <param name="bnExp"></param>
            <param name="bnRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Power(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Compute power of two BigIntergers and return a Rational number
            </summary>
            <param name="bnBase"></param>
            <param name="bnExp"></param>
            <param name="ratRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Power(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compute the power 
            </summary>
            <param name="bnBase"></param>
            <param name="bnExp"></param>
            <returns>a BigInteger</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.TryFactorial(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            Compute factorial of a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="bnRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Factorial(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compute factorial of a BigInteger
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            less than 
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            less than or equal to
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            greater than 
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            greater than or equal to 
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            equal 
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            not equal 
            </summary>
            <param name="bn1"></param>
            <param name="bn2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int 
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,System.Int32)">
            <summary>
            compare to an int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(System.Int32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,System.UInt32)">
            <summary>
            compare to an unsigned int
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(System.UInt32,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned int
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            compare to a long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(System.Int64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            compare to an unsigned long
            </summary>
            <param name="bn"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(System.UInt64,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by an unsigned long
            </summary>
            <param name="n"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,System.Double)">
            <summary>
            compare to a double
            </summary>
            <param name="bn"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThan(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_LessThanOrEqual(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThan(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_GreaterThanOrEqual(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Equality(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.op_Inequality(System.Double,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare by a double
            </summary>
            <param name="dbl"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.Object)">
            <summary>
            override equals comparison 
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.Object)">
            <summary>
            Compares the current number with another number (int, uint, double, long, ulong, Rational, BigInteger) and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.  
            </summary>
            <param name="obj">a number object</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.GetHashCode">
            <summary>
            override hashcode 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Check if two BigIntegers are equal 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare two BigIntegers
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.Int32)">
            <summary>
            Whether equal to int
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.Int32)">
            <summary>
            Compare with an int
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.UInt32)">
            <summary>
            Whether equal to an unsigned int
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.UInt32)">
            <summary>
            Compare to an unsigned int
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.Int64)">
            <summary>
            Whether equal to a long 
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.Int64)">
            <summary>
            Compare to a long 
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.UInt64)">
            <summary>
            Whether equal to a unsigned long 
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.UInt64)">
            <summary>
            Compare to a unsigned long 
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.Equals(System.Double)">
            <summary>
            Whether equal to a double 
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareTo(System.Double)">
            <summary>
            Compare to a double
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareFractions(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare integer fractions 
            </summary>
            <param name="bnNum1"></param>
            <param name="bnDen1"></param>
            <param name="bnNum2"></param>
            <param name="bnDen2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareFractionToBigInteger(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a fraction with a BigInteger. This does NOT assume that GCD(bnNum, bnDen) is 1.
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareFractionToLong(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,System.Int64)">
            <summary>
            Compare a fraction to a long. This does NOT assume that GCD(bnNum, bnDen) is 1.
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.CompareFractionToUlong(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger,System.UInt64)">
            <summary>
            Compare a fraction to an unsigned long. This does NOT assume that GCD(bnNum, bnDen) is 1.
            </summary>
            <param name="bnNum"></param>
            <param name="bnDen"></param>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.ToString">
            <summary>
            convert to strings 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.BigInteger.ToHexString">
            <summary>
            conver to a string in hex 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.BitCount">
            <summary>
            count of the number of bits in an integer
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.IsPowerOfTwo">
            <summary>
            is the number 2^x
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.IsZero">
            <summary>
            zero test 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.IsOne">
            <summary>
            one test 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.IsEven">
            <summary>
            eveness test 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.Sign">
            <summary>
            get sign 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.BigInteger.AbsoluteValue">
            <summary>
            get absolute value
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSolver">
            <summary> Interface for defining a linear programming solver
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolver">
            <summary> Interface for defining solvers supported by Solver Foundation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISolver.Shutdown">
            <summary> Shutdown the solver instance
            </summary>
            <remarks>Solver needs to dispose any unmanaged memory used upon this call.</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearModel">
            <summary>
            An ILinearModel instance encapsulates a linear optimization problem consisting of decision variables, 
            constraints, and goals. The LinearModel class implements ILinearModel 
            and the SimplexSolver class derives from LinearModel.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.IsQuadraticVariable(System.Int32)">
            <summary> Does the variable participate in any quadratic row
            </summary>
            <param name="vidVar"> any valid vid </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.AddRow(System.Object,System.Int32@)">
            <summary> If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.AddRow(System.Object,Microsoft.SolverFoundation.Services.SpecialOrderedSetType,System.Int32@)">
            <summary> Add a reference row for a SOS set. Each SOS set has one reference row
            </summary>
            <param name="key">a SOS key</param>
            <param name="sos">type of SOS</param>
            <param name="vidRow">the vid of the reference row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            </summary>
            <param name="key"> Variable key </param>
            <param name="vid">variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.IsRow(System.Int32)">
            <summary>
            validate if it is a row index 
            </summary>
            <param name="vid">row index</param>
            <returns>true if a row otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key
            </summary>
            <param name="key">the key value</param>
            <param name="vid">the variable index</param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown 
            </summary>
            <param name="key">the key value</param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown
            </summary>
            <param name="vid">the variable index</param>
            <returns>the variable key</returns>
            <remarks>key might be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite values for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            now the ArgumentException is thrown for this case.  
            </summary>
            <param name="vid">the variable index </param>
            <param name="numLo">lower bound</param>
            <param name="numHi">upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            set or adjust the lower bound of the variable 
            </summary>
            <param name="vid">the variable index </param>
            <param name="numLo">lower bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            set or adjust the upper bound of the variable 
            </summary>
            <param name="vid">the variable index</param>
            <param name="numHi">the upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Return the bounds for the variable 
            </summary>
            <param name="vid">the variable index</param>
            <param name="numLo">the lower bound returned</param>
            <param name="numHi">the upper bound returned</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            The default value for a vid is Indeterminate. An ILinearModel can be used to represent not just a linear model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value, represented as a Rational, and a basis status, represented as a boolean. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            In particular, invoking the Solve method of the SimplexSolver class updates the values and basis status appropriately.
            Some other solvers may ignore this initial state for rows and even for variables.
            </summary>
            <param name="vid">variable index</param>
            <param name="num">current value</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used to fetch solver result 
            </summary>
            <param name="vid">a variable index</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetValueState(System.Int32)">
            <summary>
            Get the value state of this variable 
            </summary>
            <param name="vid">a variable index</param>
            <returns>variable state</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetIgnoreBounds(System.Int32,System.Boolean)">
            <summary>
            Adjusts whether the bounds of a vid should be respected or ignored during solving. 
            By default, bounds are respected.
            </summary>
            <param name="vid">a variable index</param>
            <param name="fIgnore">whether to ignore the bounds</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetIgnoreBounds(System.Int32)">
            <summary>
            Get the flag whether is bound is ignored
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if bounds are ignored, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetBasic(System.Int32,System.Boolean)">
            <summary>
            The SetBasic method sets the basis status for a variable. The default basis status for a variable is false. 
            The SimplexSolver class updates these flags after a solve attempt.
            </summary>
            <param name="vid">a variable index</param>
            <param name="fBasic">whether set it to a basic variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetBasic(System.Int32)">
            <summary>
            Get the basis status for this variable 
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is a basic variable. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable 
            </summary>
            <param name="vid">a variable index </param>
            <param name="fInteger">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetCoefficient(System.Int32,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set the coefficient of the A matrix in the linear model. If num is zero, the entry is removed. 
            </summary>
            <param name="vidRow">a row id </param>
            <param name="vidVar">a column/variable id</param>
            <param name="num">a value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.SetCoefficient(System.Int32,Microsoft.SolverFoundation.Common.Rational,System.Int32,System.Int32)">
            <summary>
            Set the coefficient of the Q matrix on the objective row. If num is zero, the entry is removed. 
            This is used for quadratic terms on the objective row.
            </summary>
            <param name="vidRow">a goal row</param>
            <param name="num">a value </param>
            <param name="vidVar1">a column/variable id</param>
            <param name="vidVar2">another column/variable id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetCoefficient(System.Int32,System.Int32)">
            <summary>
            Return the coefficient of the A matrix in the linear model.
            </summary>
            <param name="vidRow">a row id</param>
            <param name="vidVar">a column/variable id</param>
            <returns>a coefficient value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetCoefficient(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the coefficient of the Q matrix on the objective row.
            </summary>
            <param name="goalRow">a goal row</param>
            <param name="vidVar1">a column/variable id</param>
            <param name="vidVar2">another column/variable id</param>
            <returns>a coefficient value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetRowEntryCount(System.Int32)">
            <summary>
            Return the number of non-zero coefficients for the given row index
            </summary>
            <param name="vidRow">a row id</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetRowEntries(System.Int32)">
            <summary>
            Return a collection of non-zero variable entries
            </summary>
            <param name="vidRow"></param>
            <returns>the variable collection</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetRowQuadraticEntries(System.Int32)">
            <summary>
            Return a collection of non-zero variable entries on the
            quadratic row
            </summary>
            <param name="vidRow"></param>
            <returns>the variable collection</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetVariableEntryCount(System.Int32)">
            <summary>
            Return the number of non-zero coefficients for the given variable/column index
            </summary>
            <param name="vid">a variable index</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetVariableEntries(System.Int32)">
            <summary>
            Return a collection of non-zero column entries
            </summary>
            <param name="vid">a variable index</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetSpecialOrderedSetTypeRowIndexes(Microsoft.SolverFoundation.Services.SpecialOrderedSetType)">
            <summary> Return a list of SOS1 or SOS2 rows
            </summary>
            <param name="sosType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Mark a row as a goal row 
            </summary>
            <param name="vid">a row id</param>
            <param name="pri">the priority of a goal</param>
            <param name="fMinimize">whether to minimize the goal row</param>
            <returns>the goal entry</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.ClearGoals">
            <summary>
            Clear all the goals 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row
            </summary>
            <param name="vid">a row id</param>
            <returns>true if the goal is removed. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row 
            </summary>
            <param name="vid">a row id</param>
            <returns>true if this a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.ILinearGoal@)">
            <summary>
            Check if a row id is a goal. If true, return the goal entry 
            </summary>
            <param name="vid">a row id</param>
            <param name="goal">return the goal entry</param>
            <returns>true if a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal
            </summary>
            <param name="vid">a variable index</param>
            <returns>A goal entry. Null if not a goal row</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.KeyCount">
            <summary> the number of keys, inclusive of rows and variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.Keys">
            <summary> Return the variable and row key collection.
            Indices are guaranteed to >= 0 and &lt; KeyCount.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.Indices">
            <summary> return the variable index collection, inclusive of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.IntegerIndexCount">
            <summary> return the number of integer variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.IsQuadraticModel">
            <summary> Is the model has a quadratic term on the objective function 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.RowCount">
            <summary> the number of rows in the model 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.RowKeys">
            <summary> return the row key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.RowIndices">
            <summary> return the row index collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.VariableCount">
            <summary>
            return the variable count 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.VariableKeys">
            <summary>
            return the variable key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.VariableIndices">
            <summary>
            return the variable index collection
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.IsSpecialOrderedSet">
            <summary> Is the linear model SOS
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.CoefficientCount">
            <summary>
            The number of non-zero coefficient 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.GoalCount">
            <summary>
            The number of goals in this linear model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearModel.Goals">
            <summary>
            Return the goal collection of this linear model. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary> 
            Solve the model using the given parameter instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolver.GetReport(Microsoft.SolverFoundation.Services.LinearSolverReportType)">
            <summary> Get sensitivity report  
            </summary>
            <param name="reportType">simplex report type</param>
            <returns>a linear solver report</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolver.Result">
            <summary>
            indicates the result of the solve attempt
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearEntry">
            <summary> Represent &lt;key, index, value> triplet 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearEntry.Key">
            <summary> row/variable key 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearEntry.Index">
            <summary> row/variable index (always a VID, whether for row or for variable)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearEntry.Value">
            <summary> row/variable value 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearEntry.Equals(System.Object)">
            <summary> Compare whether the values of two LinearEntry are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearEntry.op_Equality(Microsoft.SolverFoundation.Services.LinearEntry,Microsoft.SolverFoundation.Services.LinearEntry)">
            <summary> Compare whether the values of two LinearEntry are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearEntry.op_Inequality(Microsoft.SolverFoundation.Services.LinearEntry,Microsoft.SolverFoundation.Services.LinearEntry)">
            <summary> Compare whether the values of two LinearEntry are not equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearEntry.GetHashCode">
            <summary> Return the hashcode of this LinearEntry
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.QuadraticEntry">
            <summary> Represent &lt;key1, index1, key2, index2, value> Quintet 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.QuadraticEntry.Key1">
            <summary> row/variable key 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.QuadraticEntry.Index1">
            <summary> row/variable index 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.QuadraticEntry.Key2">
            <summary> row/variable key 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.QuadraticEntry.Index2">
            <summary> row/variable index 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.QuadraticEntry.Value">
            <summary> row/variable value 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.QuadraticEntry.Equals(System.Object)">
            <summary> Compare whether the values of two QuadraticEntry are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.QuadraticEntry.op_Equality(Microsoft.SolverFoundation.Services.QuadraticEntry,Microsoft.SolverFoundation.Services.QuadraticEntry)">
            <summary> Compare whether the values of two QuadraticEntry are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.QuadraticEntry.op_Inequality(Microsoft.SolverFoundation.Services.QuadraticEntry,Microsoft.SolverFoundation.Services.QuadraticEntry)">
            <summary> Compare whether the values of two QuadraticEntry are not equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.QuadraticEntry.GetHashCode">
            <summary> Return the hashcode of this QuadraticEntry
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearSolutionQuality">
            <summary>
            Indicates the quality of the "solution".
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolutionQuality.None">
            <summary> Not run, or the solver is interrupted 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolutionQuality.Approximate">
            <summary> Double precision 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolutionQuality.Exact">
            <summary> Exact arithmetic   
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SpecialOrderedSetType">
            <summary> SOS types
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SpecialOrderedSetType.SOS1">
            <summary> type 1 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SpecialOrderedSetType.SOS2">
            <summary> type 2
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearResult">
            <summary>
            The result of solving a linear model.
            Note that if the LinearSolutionQuality is not Exact, the LinearResult may not
            be definitive (ie, correct).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.Invalid">
            <summary> incomplete: model was found to be invalid
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.Interrupted">
            <summary> incomplete: the solver is interrupted 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.Optimal">
            <summary> complete: optimal value is found 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.Feasible">
            <summary> complete: model is feasible but may not be optimal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.UnboundedPrimal">
            <summary> complete: the primal form is unbounded 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.UnboundedDual">
            <summary> complete: the dual form is unbounded 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.InfeasiblePrimal">
            <summary> complete: the primal form is infeasible 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearResult.InfeasibleOrUnbounded">
            <summary> complete: the dual form is infeasible
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearValueState">
            <summary>
            Indicate the row/variable value status 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.Invalid">
            <summary> the value is not finite 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.Below">
            <summary> the value is below the lower bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.AtLower">
            <summary> the value is at the lower bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.Between">
            <summary> the value is in between the lower and upper bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.AtUpper">
            <summary> the value is at the upper bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearValueState.Above">
            <summary> the value is over the upper bound
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearGoal">
            <summary>
            Represent a linear goal variable. The Simplex solver supports multiple goals, each goal can have a priority
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IGoal">
            <summary>
            Represent a goal variable. For solver that support multiple goals, each goal can have a priority.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoal.Key">
            <summary> The goal variable key. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoal.Index">
            <summary> The variable index (vid) of this goal's row
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoal.Priority">
            <summary> The goal priority. The lower the value, the higher the priority.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoal.Minimize">
            <summary> Whether the goal is to minimize the objective row. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoal.Enabled">
            <summary> Whether the goal is enabled.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearGoal.Key">
            <summary> the goal variable key 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearGoal.Index">
            <summary> The variable index (vid) of this goal's row
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearGoal.Priority">
            <summary> the goal priority. The lower the value, the higher the priority
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearGoal.Minimize">
            <summary> whether the goal is to minimize the objective row 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearGoal.Enabled">
            <summary> whether the goal is enabled
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSolution">
            <summary>
            An ILinearSolution instance encapsulates the result of attempting to solve an ILinearModel. It contains the following information:
                . The solver’s final status, retrievable from the SolutionQuality, Result, LpResult, and MipResult properties.
                . The variable values, indicating the solver’s best attempt at an optimal feasible solution. The GetValue method provides this information.
                . Information on which variables are basic and which bounds are binding, non-binding or violated. The GetBasic and GetValueState methods provide this information.
                . Detailed information on which goals were considered and solved to optimality.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolverSolution">
            <summary> Interface for defining a solution that is specific to a solver
            </summary>
            <remarks>For future usage</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolution.GetValue(System.Int32)">
            <summary>
            Return the value for the variable 
            </summary>
            <param name="vid">a variable id</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolution.GetValueState(System.Int32)">
            <summary>
            Return the variable state
            </summary>
            <param name="vid">a variable id</param>
            <returns>the variable state</returns> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolution.GetBasic(System.Int32)">
            <summary>
            Check whehter a variable is a basic variable
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolution.GetSolutionValue(System.Int32)">
            <summary>
            get the objective value of a goal 
            </summary>
            <param name="goalIndex">goal id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolution.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get the information of a solved goal
            </summary>
            <param name="igoal"> 0 &lt;= goal index &lt; SolvedGoalCount </param>
            <param name="key">the goal row key</param>
            <param name="vid">the goal row vid</param>
            <param name="fMinimize">whether the goal is minimization</param>
            <param name="fOptimal">whether the goal is optimal</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.SolutionQuality">
            <summary>
            indicates the quality level of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.LpResult">
            <summary>
            indicates the result of solving the LP relaxation, which is essentially the model with its integrality conditions ignored
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.MipResult">
            <summary>
            indicates the result of considering the integrality conditions
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.Result">
            <summary>
            indicates the result of the solve attempt
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.MipBestBound">
            <summary> the best result from the MIP solver 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolution.SolvedGoalCount">
            <summary> number of goals being solved
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearSolverReportType">
            <summary> Different types of reports 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverReportType.None">
            <summary> No report 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverReportType.Sensitivity">
            <summary> Sensitivity report  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverReportType.Infeasibility">
            <summary> Infeasibility report 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange">
            <summary> sensitivity report range  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.Lower">
            <summary> lower bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.Current">
            <summary> current value  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.Upper">
            <summary> upper bound
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.Equals(System.Object)">
            <summary> Compare whether the values of two LinearSolverSensitivityRange are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.op_Equality(Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange,Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange)">
            <summary> Compare whether the values of two LinearSolverSensitivityRange are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.op_Inequality(Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange,Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange)">
            <summary> Compare whether the values of two LinearSolverSensitivityRange are not equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.GetHashCode">
            <summary> Return the hashcode of this LinearSolverSensitivityRange
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange.ToString">
            <summary> Return the string represntation as (current [lower, upper])
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSolverReport">
            <summary> a linear solver generic report
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport">
            <summary> This is a report for sensitivity analysis  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">A row vid.</param>
            <returns>The dual value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport.GetObjectiveCoefficientRange(System.Int32)">
            <summary> Get the coefficient range on the first goal row   
            </summary>
            <param name="vid">A variable vid.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport.GetObjectiveCoefficientRange(System.Int32,System.Int32)">
            <summary> Get the coefficient range for a goal row.
            </summary>
            <param name="vid">A variable vid.</param>
            <param name="pri">The goal index.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport.GetVariableRange(System.Int32)">
            <summary> Get the variable range.  
            </summary>
            <param name="vid">A variable vid.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSolverInfeasibilityReport">
            <summary> Infeasibility report
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSolverInfeasibilityReport.IrreducibleInfeasibleSet">
            <summary> return the infeasibility constraint set
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics">
            <summary>
            This interface provides statistical information specific to an attempt by the SimplexSolver to solve a linear model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.InnerIndexCount">
            <summary>
            The InnerIndexCount property returns the number of user and row variables used 
            internally when solving the linear model. This may be less than ILinearModel.KeyCount since variables may be eliminated by presolve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.InnerIntegerIndexCount">
            <summary>
            The InnerIntegerIndexCount property returns the number of integer user 
            and row variables used internally when solving the linear model. 
            This may be less than ILinearModel.IntegerIndexCount since variables may be eliminated by presolve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.InnerSlackCount">
            <summary>
            The InnerSlackCount property returns the number of row variables used internally when 
            solving the linear model. This may be less than the ILinearModel.RowCount, since row variables may be eliminated by presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.InnerRowCount">
            <summary>
            The InnerRowCount property returns the number of rows used internally when solving the linear model. 
            This may be less than ILinearModel.RowCount since rows may be eliminated by presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCount">
            <summary>
            The pivot count properties indicate the number of simplex pivots performed. Generally these include both major and minor pivots.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountDegenerate">
            <summary>
            The pivot count of degenerated pivots
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountExact">
            <summary>
            the pviot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountExactPhaseOne">
            <summary>
            the phase I pviot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountExactPhaseTwo">
            <summary>
            the phase II pviot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountDouble">
            <summary>
            the pviot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountDoublePhaseOne">
            <summary>
            the phase I pviot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.PivotCountDoublePhaseTwo">
            <summary>
            the phase II pviot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.FactorCount">
            <summary>
            The factor count properties indicate the number of basis matrix LU factorizations performed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.FactorCountExact">
            <summary>
            The factor count of exact arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.FactorCountDouble">
            <summary>
            The factor count of double arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.BranchCount">
            <summary>
            The BranchCount property indicates the number of branches performed when applying the branch and bound algorithm to a MILP. 
            If the model has no integer variables, this will be zero.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.Gap">
            <summary>
            Used by MIP to indicate the difference between an integer solution to a relaxed solution
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.UseExact">
            <summary>
            indicate whether the solve attempt was instructed to use exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.UseDouble">
            <summary>
            indicate whether the solve attempt was instructed to use double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.AlgorithmUsed">
            <summary>
            indicates which algorithm was used to by the solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.CostingUsedExact">
            <summary>
            Costing used for exact arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ILinearSimplexStatistics.CostingUsedDouble">
            <summary>
            costing used for double arithmetic 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective">
            <summary> A general MIP directive to provide guidance for MIP solvers
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexDirective">
            <summary>
            Directive for the simplex solver.
            </summary>
            <remarks>
            The simplex solver is suitable for linear models with real decisions.
            In the case of a model with no goals, the simplex solver will report an Optimal solution.
            By contrast the constraint programming solver reports Feasible.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Directive">
            <summary>
            A Directive represents an instruction to the SFS and/or the solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Directive.#ctor">
            <summary>Create a new instance with default values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Directive.TimeLimit">
            <summary>Time limit in milliseconds. If negative, no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Directive.WaitLimit">
            <summary>Time to wait for a result after timeout is reached, in milliseconds. If negative, no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Directive.MaximumGoalCount">
            <summary>Maximum number of goals to use, if multiple goals are supported. 
            Disabled goals are considered in this count. For example, if you have 3 goals, which from them the second is disabled. 
            Setting the MaximumGoalCount to 2 will make the first goal the only goal to be considered.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Directive.Arithmetic">
            <summary>Numerical accuracy to use during solve.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplexDirective.#ctor">
            <summary>Default constructor with default values for the simplex solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplexDirective.ToString">
            <summary>
            Returns a representation of the directive as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.Pricing">
            <summary> The pricing strategy to use.
            </summary>
            <remarks> The requested pricing strategy may not match that actually used by the solver.
            For example SteepestEdge pricing may be used if sensitivity information has been requested.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.IterationLimit">
            <summary> The limit on number of pivots. If negative, no limit. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.Algorithm">
            <summary> The algorithm to use.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.Basis">
            <summary> The basis to use.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.GetSensitivity">
            <summary>
            Whether to generate sensitivity information.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.GetInfeasibility">
            <summary>
            Whether to generate infeasibility information
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.PricingTolerance">
            <summary>
            Numerical tolerance for simplex pricing.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexDirective.VariableTolerance">
            <summary>
            Numerical tolerance for variables. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.#ctor">
            <summary>Default constructor with default values for the MIP solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.GapTolerance">
            <summary> Gets or sets the tolerance to declare an integer solution optimal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.QuickFeasibility">
            <summary> Whether or not to focus on getting quick feasibility
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.CuttingPlaneGeneration">
            <summary> Enable/disable cutting plane 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.MixedIntegerProgrammingDirective.LocalSearch">
            <summary> Enable/disable local search in Mixed Integer Solvers
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IRowVariableModel">
            <summary>
            IRowVariableModel represents optimization models consisting of decision variables and rows.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown 
            </summary>
            <param name="key"></param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key
            </summary>
            <param name="key">the key value </param>
            <param name="vid">the variable index </param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown
            </summary>
            <param name="vid">the variable index</param>
            <returns>the variable key</returns>
            <remarks>key might be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.AddRow(System.Object,System.Int32@)">
            <summary> If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.IsRow(System.Int32)">
            <summary>
            Validate if it is a row index and not a variable index.
            </summary>
            <param name="vid">row index</param>
            <returns>True if a row otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetIgnoreBounds(System.Int32,System.Boolean)">
            <summary>
            Adjusts whether the bounds of a vid should be respected or ignored during solving. 
            By default, bounds are respected.
            </summary>
            <param name="vid">a variable index</param>
            <param name="ignore">whether to ignore the bounds</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetIgnoreBounds(System.Int32)">
            <summary>
            Get the flag whether is bound is ignored.
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if bounds are ignored, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the bounds for a vid.</summary>
            <remarks>
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite values for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            and ArgumentException is thrown.  
            </remarks>
            <param name="vid">A vid.</param>
            <param name="lower">The lower bound.</param>
            <param name="upper">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the lower bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="lower">The lower bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the upper bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="upper">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary> Return the bounds for the vid.
            </summary>
            <param name="vid">A vid.</param>
            <param name="lower">The lower bound returned.</param>
            <param name="upper">The upper bound returned.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            </summary>
            <param name="key"> Variable key </param>
            <param name="vid">variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used to fetch solver result 
            </summary>
            <param name="vid">a variable index</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Sets the default value for a vid.
            </summary>
            <remarks>
            The default value for a vid is Indeterminate. An IRowVariableModel can be used to represent not just a model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value represented as a Rational. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            Some solvers may ignore this initial state for rows and even for variables.
            </remarks>
            <param name="vid">A vid.</param>
            <param name="value">The default value for the variable.</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable 
            </summary>
            <param name="vid">a variable index </param>
            <param name="integer">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableModel.GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.Indices">
            <summary> return the variable index collection, inclusive of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.Keys">
            <summary> Return the variable and row key collection.
            Indices are guaranteed to >= 0 and &lt; KeyCount.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.KeyCount">
            <summary> the number of keys, inclusive of rows and variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.RowIndices">
            <summary> Return the row index collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.RowKeys">
            <summary> Return the row key collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.RowCount">
            <summary> The number of rows in the model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.VariableIndices">
            <summary>
            return the variable index collection
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.VariableKeys">
            <summary>
            return the variable key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.VariableCount">
            <summary>
            return the variable count 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IRowVariableModel.IntegerIndexCount">
            <summary> return the number of integer variables 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MsfException">
            <summary>
            Base exception class for Microsoft Solver Foundation exceptions
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfException.#ctor">
            <summary>
            Create the default MSF exception instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfException.#ctor(System.String)">
            <summary>
            Create the MSF exception instance with given string message
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfException.#ctor(System.String,System.Exception)">
            <summary>
            Create the MSF exception instance with given string message and an inner exception instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MsfSolverConfigurationException">
            <summary> Indicates that the plugin solvers cause errors
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfSolverConfigurationException.#ctor">
            <summary>
            Create the default MsfSolverConfigurationException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfSolverConfigurationException.#ctor(System.String)">
            <summary>
            Create the MsfSolverConfigurationException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfSolverConfigurationException.#ctor(System.String,System.Exception)">
            <summary>
            Create the MsfSolverConfigurationException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfSolverConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IGoalModel">
            <summary>
            IGoalModel represents an optimization model with goals.
            </summary>
            <remarks>
            This interface is inherited by model interfaces such as ILinearModel and INonlinearModel.
            Goals are identified using integer indexes (vids). Multiple goals can be specified
            using multiple calls to AddGoal.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark a row as a goal.
            </summary>
            <param name="vid">A row id.</param>
            <param name="pri">The priority of the goal (smaller values are prioritized first).</param>
            <param name="minimize">Whether to minimize the goal row.</param>
            <returns>An IGoal object representing the goal.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row.
            </summary>
            <param name="vid">A row id.</param>
            <returns>True if this a goal row, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.IGoal@)">
            <summary>
            Check if a row id is a goal and retreive the associated IGoal. 
            </summary>
            <param name="vid">A row id.</param>
            <param name="goal">The IGoal corresponding to the vid.</param>
            <returns>True if this a goal row, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row.
            </summary>
            <param name="vid">A row id.</param>
            <returns>True if the goal was removed, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.ClearGoals">
            <summary>
            Clear all the goals .
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IGoalModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal
            </summary>
            <param name="vid">A variable id.</param>
            <returns>A goal entry. Null if the vid does not correspond to a goal.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoalModel.Goals">
            <summary>
            Return the goal collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.IGoalModel.GoalCount">
            <summary>
            The number of goals in this model.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IRowVariableSolver">
            <summary>
            IRowVariableSolver represents a solver for optimization models with goals.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IRowVariableSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary> 
            Solve the model using the given parameters.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.INonlinearSolution">
            <summary>
            An INonlinearSolution instance encapsulates the result of attempting to solve an 
            IRowVariableSolver (INonlinearSolver or ITermSolver). 
            </summary>
            <remarks>
            INonlinearSolution contains the following information:
               The solver’s final status, retrievable from Result property,
               The variable values, indicating the solver’s best attempt at an optimal feasible solution. The GetValue method provides this information.
               Detailed information on which goals were considered and solved to optimality.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearSolution.GetValue(System.Int32)">
            <summary>
            Return the value for the variable (or optionally row) with the specified vid. 
            </summary>
            <param name="vid">A variable id.</param>
            <returns>The value of the variable as a double.</returns>
            <remarks>
            This method can always be called with variable vids. Some solvers support row vids as well.
            The value may be finite, infinite, or indeterminate depending on the solution status.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearSolution.GetSolutionValue(System.Int32)">
            <summary>
            Get the objective value of a goal.
            </summary>
            <param name="goalIndex">A goal id.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearSolution.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get the information for a solved goal.
            </summary>
            <param name="goalIndex">The goal index: 0 &lt;= goal index &lt; SolvedGoalCount.</param>
            <param name="key">The goal row key.</param>
            <param name="vid">The goal row vid.</param>
            <param name="minimize">Whether the goal is minimization goal.</param>
            <param name="optimal">Whether the goal is optimal.</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearSolution.SolvedGoalCount">
            <summary>Number of goals being solved.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearSolution.Result">
            <summary>
            Indicates the type of result (e.g., LocalOptimal). 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NonlinearResult">
            <summary>
            The result of solving a nonlinear model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Invalid">
            <summary> incomplete: solver cannot finish solving. 
            This can be caused by some inconsistent functions, max iteration exceeded or other causes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Interrupted">
            <summary> incomplete: the solver is interrupted 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.LocalOptimal">
            <summary> complete: local optimal value is found 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Optimal">
            <summary>complete: global optimal value is found
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Feasible">
            <summary> complete: model is feasible but may not be optimal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Unbounded">
            <summary> complete: the model form is unbounded 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.Infeasible">
            <summary> complete: the model is infeasible 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.InfeasibleOrUnbounded">
            <summary> complete: the model is either infeasible or unbounded
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearResult.LocalInfeasible">
            <summary> complete: local infeasible value is found, but solver can not determine if the model is globally infeasible.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.INonlinearModel">
            <summary>
            INonlinearModel represents a non-linear optimization model. It has row, variables and goals, and in addition it has callback that 
            define the values and possible the gradients of the rows.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearModel.GetActiveVariables(System.Int32)">
            <summary>Specify variables that participate in the row. 
            </summary>
            <param name="rowVid">The row id.</param>
            <returns>Enumeration of active variables on rowVid</returns>
            <exception cref="T:System.ArgumentException">Thrown if rowVid is not a legal row id.</exception>
            <remarks>In the case of a model which has explicit linear terms (implements ILinearModel),
            there is no need to specify the linear terms with this call. If no call to SetActiveVariables
            has been made for the row then this method will return an empty result.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearModel.IsActiveVariable(System.Int32,System.Int32)">
            <summary>Indicates whether a variable is active in the specified row.
            </summary>
            <param name="rowVid">The row id.</param>
            <param name="varVid">The variable id.</param>
            <returns>Returns true if variable is active, otherwise false.</returns>
            <exception cref="T:System.ArgumentException">Thrown if rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearModel.SetActiveVariables(System.Int32,System.Boolean)">
            <summary>Set all variables in a row to be active (or inactive).
            </summary>
            <param name="rowVid">The row id.</param>
            <param name="active">If true, all variables become active, 
            if false all variables become inactive.</param>
            <exception cref="T:System.ArgumentException">Thrown if rowVid is not a legal row index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.INonlinearModel.SetActiveVariable(System.Int32,System.Int32,System.Boolean)">
            <summary>Sets a variable in the specified row to be active (or inactive).
            </summary>
            <param name="rowVid">The row id.</param>
            <param name="varVid">The variable id.</param>
            <param name="active">If true, the variable becomes active, 
            if false it becomes inactive.</param>
            <exception cref="T:System.ArgumentException">Thrown if rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearModel.FunctionEvaluator">
            <summary>
            Function value callback. The callback will be invoked periodically by the solver in order to obtain
            function values for different variable values.
            </summary>
            <remarks>
            The callback has several arguments.
            The first argument is the INonlinearModel being solved.
            The second is a System.Int32 representing the row (goal or constraint) id to be evaluated.
            The third is a ValuesByIndex containing the current variable values accessible by id.
            Next is a System.Boolean that indicates whether this is first evaluator call with the current variable values.
            The return value is a System.Double which should be the value of the row for the current variable 
            values.
            This callback must be set before trying to solving the model.</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearModel.GradientEvaluator">
            <summary>
            Gradient callback. The callback will be invoked periodically by the solver in order to obtain
            gradient information for different variable values.
            </summary>
            <remarks>
            The callback has several arguments.
            The first argument is the INonlinearModel being solved.
            The second is a System.Int32 representing the row (goal or constraint) id to be evaluated.
            The third is a ValuesByIndex containing the current variable values accessible by id.
            Next is a System.Boolean that indicates whether this is first evaluator call with the current variable values.
            The last argument is a ValuesByIndex object which should contain the gradient values on return.
            The callback function should set the values for all variables that were previously declared as active
            using the SetActiveVariables method.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.INonlinearSolver">
            <summary>
            INonlinearSolver represents a solver for INonlinearModel models.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearSolver.NonlinearCapabilities">
            <summary>
            The capabilities for this solver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearSolver.GradientCapability">
            <summary>
            Gradient related capabilities.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.INonlinearSolver.HessianCapability">
            <summary>
            Hessian related capabilities.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NonlinearCapabilities">
            <summary>
            Capabilities related to non-linear solvers
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearCapabilities.None">
            <summary>
            Does not support any of the specified capabilities
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearCapabilities.SupportsExplicitLinearTerms">
            <summary>
            Supports specify the linear terms explicitly
            </summary>
            <remarks>ILinearModel must be implemented for this capability</remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearCapabilities.SupportsBoundedRows">
            <summary>Supports model with constraints
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearCapabilities.SupportsBoundedVariables">
            <summary>Supports model variable bounds (boxed model)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DerivativeCapability">
            <summary>
            Capabilities related to derivatives
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DerivativeCapability.NotSupported">
            <summary>
            Not supported
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DerivativeCapability.Supported">
            <summary>
            Supported, but not required
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DerivativeCapability.Required">
            <summary>
            Required
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ValuesByIndex">
            <summary>
            Allow access to solver values using INonlinearModel indexes.
            </summary>
            <remarks>
            Use the indexer to get and set for the specified row or variable index. For example,
            <code>
            ValuesByIndex v;
            int x;
            // (code to retrieve v and x)
            Console.WriteLine("The value for vid {0} is {1}", x, v[x]);
            </code>
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValuesByIndex.#ctor">
            <summary>
            Creates ValuesByIndex instance. As no array of mapping is given, the inheritor is responsible to 
            override the indexer and implement it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValuesByIndex.#ctor(System.Int32[])">
            <summary>
            Creates a new instance using the specified mapping.
            </summary>
            <param name="indexToSolver">index to solver array mapping</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValuesByIndex.#ctor(System.Int32[],System.Double[])">
            <summary>
            Creates a new instance using the specified mapping and values.
            </summary>
            <param name="indexToSolver">Index to solver array mapping.</param>
            <param name="solverValues">Array of the solver values.</param>
            <remarks>If the same ValuesByIndex is used for each iteration, 
            then the one-argument constructor should be used instead.</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ValuesByIndex.SolverValues">
            <summary>Array of the solver values (to be used by derived classes).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ValuesByIndex.Item(System.Int32)">
            <summary>Get or set a value given the index (vid).
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModelOperation">
            <summary>
            Operation types for ITermModels.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Identity">
            <summary>
            No operation. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Minus">
            <summary>
            Unary negation.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Abs">
            <summary>
            Absolute value. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Not">
            <summary>
            Logical inversion. 0 if input is 1, 1 if input is 0. Undefined otherwise. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Sin">
            <summary>
            Sine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Cos">
            <summary>
            Cosine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Tan">
            <summary>
            Tangent. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.ArcCos">
            <summary>
            Arccosine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.ArcSin">
            <summary>
            Arcsine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.ArcTan">
            <summary>
            Arctangent. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Cosh">
            <summary>
            Hyperbolic cosine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Sinh">
            <summary>
            Hyperbolic sine. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Tanh">
            <summary>
            Hyperbolic tangent. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Exp">
            <summary>
            Exponent (base e). Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Log">
            <summary>
            Logarithm (base e). Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Log10">
            <summary>
            Logarithm (base 10). Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Sqrt">
            <summary>
            Square root. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Plus">
            <summary>
            Addition. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Times">
            <summary>
            Multiplication. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Quotient">
            <summary>
            Division. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Power">
            <summary>
            Exponentiation. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Max">
            <summary>
            Maximum. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Min">
            <summary>
            Minimum. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.And">
            <summary>
            Logical and. 1 if both inputs are 1, 0 if either input is 0, undefined otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Or">
            <summary>
            Logical or. 1 if either input is 1, 0 if both inputs are 0, undefined otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Equal">
            <summary>
            Equality. 1 if the inputs are equal, 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Unequal">
            <summary>
            Inequality. 1 if the inputs are unequal, 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Greater">
            <summary>
            Greater-than comparison. 1 if the first input is strictly larger, 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Less">
            <summary>
            Less-than comparison. 1 if the second input is strictly larger, 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.GreaterEqual">
            <summary>
            Greater-than comparison. 1 if the first input is larger or equal, 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.LessEqual">
            <summary>
            Less-than comparison. 1 if the second input is larger or equal. 0 otherwise. Binary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.If">
            <summary>
            If. If the first input is 1, the second input. If the first input is 0, the third input. If the first input is anything else, undefined. Trinary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Ceiling">
            <summary>
            Ceiling. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Floor">
            <summary>
            Floor. Unary.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelOperation.Function">
            <summary>
            Function. N-ary.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ITermModel">
            <summary>ITermModel represents optimization models consisting of terms involving decision variables.
            ITermModel is capable of representing most type of optimization models.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32)">
            <summary>
            Adds an operation row to the model. This row can be turned into a constraint by setting the bounds.
            Examples of 1-operand operations: identity, negation, not, sin, cos, tan, exp, log, abs
            Examples of 2-operand operations: plus, minus, times, quotient, pow, max, min, and, or, equality/inequalities
            Examples of 3-operand operations: if
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vid1">Vid of the first input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32)">
            <summary>Adds a binary operation to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vid1">Vid of the first input argument.</param>
            <param name="vid2">Vid of the second input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Adds an operation to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vid1">Vid of the first input argument.</param>
            <param name="vid2">Vid of the second input argument.</param>
            <param name="vid3">Vid of the third input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32[])">
            <summary>Adds an operation to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vids">The vids of the input arguments.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddVariable(System.Object,System.Int32@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean)">
            <summary>
            Adds a variable to the model, with bounds and integrality given at creation time.
            </summary>
            <param name="key">The optional key of the new variable, or null.</param>
            <param name="vid">The vid of the new variable, or of an existing variable with the same key.</param>
            <param name="lower">The lower bound.</param>
            <param name="upper">The upper bound.</param>
            <param name="isInteger">True if the new variable should be restricted to only integer values.</param>
            <returns>True if a new variable was added. False if an existing variable had the same key.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddVariable(System.Object,System.Int32@,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            Adds a variable to the model, with a fixed set of possible values.
            </summary>
            <param name="key">The optional key of the new variable, or null.</param>
            <param name="vid">The vid of the new variable, or of an existing variable with the same key.</param>
            <param name="possibleValues">An array of possible values of the new variable. The caller must not modify the array after passing it to this function.</param>
            <returns>True if a new variable was added. False if an existing variable had the same key.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.AddConstant(Microsoft.SolverFoundation.Common.Rational,System.Int32@)">
            <summary>
            Adds a constant to the model. Constants are considered rows.
            </summary>
            <param name="value">The value of the constant to create.</param>
            <param name="vid">The vid of the new constant, or the vid of an existing constant with the same value.</param>
            <returns>True if a new constant was added. False if an existing constant was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.IsOperation(System.Int32)">
            <summary>
            Tests if a vid is an operation (not a variable or constant).
            </summary>
            <param name="vid">A vid.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.IsConstant(System.Int32)">
            <summary>
            Tests if a vid is a constant (not a variable or operation).
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.GetOperation(System.Int32)">
            <summary>
            Gets the operation associated with a vid.
            </summary>
            <param name="vid">A vid.</param>
            <returns>The operation.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.GetOperandCount(System.Int32)">
            <summary>
            Gets the number of operands associated with a vid.
            </summary>
            <param name="vid">A vid.</param>
            <returns>The operand count.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.GetOperands(System.Int32)">
            <summary>
            Gets the operands associated with a vid.
            </summary>
            <param name="vid">A vid.</param>
            <returns>All the vids of the operands.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ITermModel.GetOperand(System.Int32,System.Int32)">
            <summary>
            Gets an operand associated with a vid.
            </summary>
            <param name="vid">A vid.</param>
            <param name="index">An operand index.</param>
            <returns>The vid of the operand.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ITermSolver">
            <summary>Interface for solvers of ITermModel instances.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ITermSolver.SupportedOperations">
            <summary>
            Gets the operations supported by the solver.
            </summary>
            <returns>All the TermModelOperations supported by the solver.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Rational">
             <summary>
             Non zero finite rational values are represented as a pair (num, den) with den > 0.
             The numerator and denominator are relatively prime, ie, gcd(num, den) = 1.
            
             Zero is represented as (0, 0) so that default(Rational) == 0.
             There are 4 other valid values with zero denominator:
             (1) NegativeInfinity, represented by (-1, 0).
             (2) PositiveInfinity, represented by (+1, 0).
             (3) UnsignedInfinity, represented by (+2, 0).
             (4) Indeterminate, aka NaN, represented by (+3, 0).
            
             Unlike with IEEE double arithmetic, we have 3 representations of inifinity (not 2).
             Dividing a nonzero value by zero results in an UnsignedInfinity, since 0 is itself unsigned.
             Dividing a finite value by any of the infinities results in 0.
             </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.NegativeInfinity">
            <summary>
            Negative Infinity 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.Zero">
            <summary>
            zero 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.One">
            <summary>
            one 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.PositiveInfinity">
            <summary>
            Positive Infinity 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.Indeterminate">
            <summary>
            not a number 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Rational.UnsignedInfinity">
            <summary>
            Unsigned Infinity
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.ConvertToRational(System.Object)">
            <summary>Convert a value to a Rational.
            </summary>
            <param name="obj">The value.</param>
            <returns>Rational representing the value</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Get(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Make a Rational from two BigInteger 
            </summary>
            <param name="bnNum">nominator</param>
            <param name="bnDen">denominator</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.IsInteger">
            <summary>
            Check if an integer 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.IsInteger(Microsoft.SolverFoundation.Common.BigInteger@)">
            <summary>
            If an interger. clone it 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetIntegerPart">
            <summary> Return integer part
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetFractionalPart">
            <summary>
            Return the fraction part
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetFloor">
            <summary>
            Return the floor 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetFloorResidual">
            <summary>
            Return the residual of the floor 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetCeiling">
            <summary>
            Return the ceiling 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetCeilingResidual">
            <summary>
            Return the ceiling residual 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(System.Int32)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from an int
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(System.UInt32)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from an unsigned int
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(System.Int64)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from a long 
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(System.UInt64)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from an unsigned long
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(System.Double)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from a double
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Implicit(Microsoft.SolverFoundation.Common.BigInteger)~Microsoft.SolverFoundation.Common.Rational">
            <summary>
            convert from a BigInteger
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~System.Int32">
            <summary>
            convert to an int
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~System.UInt32">
            <summary>
            convert to an unsigned int
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~System.Int64">
            <summary>
            convert to a long
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~System.UInt64">
            <summary>
            convert to an unsigned long
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~System.Double">
            <summary>
            convert to a double
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.ToDouble">
            <summary> Convert Rational value to nearest Double.
            </summary>
            <returns> The nearest Double value </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Explicit(Microsoft.SolverFoundation.Common.Rational)~Microsoft.SolverFoundation.Common.BigInteger">
            <summary>
            convert to a BigInteger
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetSignedDouble">
            <summary>
            Return as a signed double 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Negate(Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            inplace negate 
            </summary>
            <param name="num"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_UnaryNegation(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            negate 
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Addition(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Add two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Subtraction(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Substract two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Invert">
            <summary>
            invert the sign 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Multiply(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Times two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Division(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Divide two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.AddMul(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Optimize the common operation: ratAdd + ratMul1 * ratMul2.
            </summary>
            <param name="ratAdd"></param>
            <param name="ratMul1"></param>
            <param name="ratMul2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Power(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            ratEes = ratbase^ratExp
            </summary>
            <param name="ratBase"></param>
            <param name="ratExp"></param>
            <param name="ratRes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare two Rationals
            </summary>
            <param name="rat1"></param>
            <param name="rat2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.BigInteger,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="bn"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and a BigInteger
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,System.UInt32)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(System.UInt32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned int
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,System.Int64)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(System.Int64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,System.UInt64)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="rat"></param>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(System.UInt64,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and an unsigned long
            </summary>
            <param name="n"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="rat"></param>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThan(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_LessThanOrEqual(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThan(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_GreaterThanOrEqual(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Equality(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.op_Inequality(System.Double,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Compare a rational and a double
            </summary>
            <param name="dbl"></param>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.Object)">
            <summary>
            equal check
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.GetHashCode">
            <summary>
            Return hashcode 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            equal check
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            compare
            </summary>
            <param name="rat"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            equal check 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(Microsoft.SolverFoundation.Common.BigInteger)">
            <summary>
            compare 
            </summary>
            <param name="bn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.Int32)">
            <summary>
            equal check 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.Object)">
            <summary>
            Compares the current number with another number (int, uint, double, long, ulong, Rational, BigInteger) and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object. 
            </summary>
            <param name="obj">a number object</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.Int32)">
            <summary>
            compare 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.UInt32)">
            <summary>
            equal check 
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.UInt32)">
            <summary>
            compare 
            </summary>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.Int64)">
            <summary>
            equal check 
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.Int64)">
            <summary>
            compare 
            </summary>
            <param name="nn"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.UInt64)">
            <summary>
            eqaul check 
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.UInt64)">
            <summary>
            compare 
            </summary>
            <param name="uu"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.Equals(System.Double)">
            <summary>
            equal check 
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.CompareTo(System.Double)">
            <summary>
            compare to 
            </summary>
            <param name="dbl"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.ToString">
            <summary>
            conver to a string 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Rational.AppendDecimalString(System.Text.StringBuilder,System.Int32)">
            <summary>
            Append to a string
            </summary>
            <param name="sb"></param>
            <param name="cchMax"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsZero">
            <summary>
            zero test 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsOne">
            <summary>
            one test 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsFinite">
            <summary>
            Check if a finite number 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsIndeterminate">
            <summary>
            Check if nont a number
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsInfinite">
            <summary>
            Check if inifinite
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsSignedInfinity">
            <summary>
            Check if signed inifinite 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsUnsignedInfinity">
            <summary>
            Check if unsigned infinite 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsPositiveInfinity">
            <summary>
            Check if a positive infinity
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.IsNegativeInfinity">
            <summary>
            Check if a negative infinity
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.HasSign">
            <summary>
            Check if signed 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.BitCount">
            <summary>
            bit count 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.Sign">
            <summary>
            sign: +1 positive, -1 negative
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.Numerator">
            <summary>
            Return numerator 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.Denominator">
            <summary>
            Return denominator
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Rational.AbsoluteValue">
            <summary>
            Return absolute value 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexCosting">
            <summary> Different kinds of Simplex costing 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.Default">
            <summary> default 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.Automatic">
            <summary> let the solvers to pick. Usually Simplex will pick the steepest edge.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.BestReducedCost">
            <summary> compute all reduced cost 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.SteepestEdge">
            <summary> steepest edge pricing 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.Partial">
            <summary> compute partial reduced cost  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexCosting.NewPartial">
            <summary> another partial pricing 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SolverKind">
            <summary> Different kinds of solvers 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SolverKind.Simplex">
            <summary> Simplex algorithm 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SolverKind.InteriorPointCentral">
            <summary> Interior Point Primal-dual Predictor-Corrector algorithm 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexAlgorithmKind">
            <summary> define two classes Simplex algorithms 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexAlgorithmKind.Primal">
            <summary> the Primal form 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexAlgorithmKind.Dual">
            <summary> the dual form
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexVarValKind">
            <summary> different kinds of variables supported by the Simplex solver 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexVarValKind.Basic">
            <summary>
            basis 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexVarValKind.Fixed">
            <summary> fixed variable 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexVarValKind.Lower">
            <summary> variables fixed the lower bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexVarValKind.Upper">
            <summary> variables fixed at the upper bound 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexVarValKind.Zero">
            <summary> free, no bound variables 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexBasisKind">
            <summary> The kind of initial basis used.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasisKind.Slack">
            <summary> A basis using all the slack variables (default).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasisKind.Current">
            <summary> Use basis currently specified.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasisKind.Freedom">
            <summary> A basis using unfixed slacks and other maximally free variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasisKind.Crash">
            <summary> Crash basis.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation">
            <summary>
            Simplex pivoting information
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.IsDouble">
            <summary> Whether this is a double based pivot (vs Rational based).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.VarEnter">
            <summary> The entering variable index.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.VvkEnter">
            <summary> The state of the variable before entering.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.VarLeave">
            <summary> The leaving variable index.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.VvkLeave">
            <summary> The state of the leaving variable after leaving.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.Scale">
            <summary> How much the entering variable is changing by (absolute value).
            Zero (or close to it) indicates a degenerate pivot.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.Sign">
            <summary> Indicates whether the entering variable is increasing or decreasing.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.Determinant">
            <summary> The determinant of this transformation. This is the "pivot" value, or diagonal
            entry of the eta matrix. The determinant of the new basis is this value times the
            determinant of the old basis.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation.ApproxCost">
            <summary> An approximation of the reduced cost. There are no guarantees on accuracy.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SecondOrderConeRowType">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConeRowType.Conic">
            <summary>A conic row.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConeRowType.PrimaryConic">
            <summary>A primary conic.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISecondOrderConicModel">
            <summary>Encapsulates a second order conic optimization problem.
            </summary>
            <remarks>
            Second order conic (SOCP) models are distinguished from linear models by
            the use of conic constraints.  Cones come in two types: quadratic and rotated
            quadratic.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.AddRow(System.Object,Microsoft.SolverFoundation.Services.SecondOrderConeType,System.Int32@)">
            <summary> Add a reference row for a second order cone. Each cone has one reference row.
            </summary>
            <param name="key">A second order cone key</param>
            <param name="coneType">Second order cone type</param>
            <param name="vidRow">the vid of the reference row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.SetPrimaryConic(System.Int32,System.Int32)">
            <summary> Specifies a primary variable for a cone.  
            </summary>
            <param name="vidRow">The reference row for the cone.</param>
            <param name="vid">The vid of the variable.</param>
            <returns></returns>
            <remarks>
            Quadratic cones have one primary variable.  SetPrimaryConic must be called twice for rotated quadratic cones
            because they have two primary variables.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.TryGetConeFromIndex(System.Int32,Microsoft.SolverFoundation.Services.ISecondOrderCone@)">
            <summary>Gets cone information given a reference row vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.AddRow(System.Object,System.Int32,Microsoft.SolverFoundation.Services.SecondOrderConeRowType,System.Int32@)">
            <summary>Adds a new conic row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.IsConicRow(System.Int32)">
            <summary>Indicates whether a row is a conic row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.GetConicRowIndexes(System.Int32)">
            <summary> Return the rows for the specified cone.
            </summary>
            <param name="vidRow">The cone index.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.GetConicRowCount(System.Int32)">
            <summary> Return the row count for the specified cone.
            </summary>
            <param name="vidRow">The cone index.</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.Cones">
            <summary>Return the cone collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderConicModel.IsSocpModel">
            <summary> Indicates whether the model contains any second order cones.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISecondOrderCone">
            <summary>Second order cone information.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.Key">
            <summary> The cone key.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.Index">
            <summary> The cone index (cid) of this cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.ConeType">
            <summary> The second order cone type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.PrimaryVid1">
            <summary> The primary conic variable.  For a quadratic cone it is x1 where
            x1 >= || x2 ||, x1 > 0.
            </summary>
            <remarks>
            -1 means there is no primary conic variable - the cone is empty.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.PrimaryVid2">
            <summary> The secondary conic variable.  For a rotated quadratic cone it is x2 where
            x1 x2 >= || x3 ||, x1, s2 > 0.
            </summary>
            <remarks>
            -1 means either the cone is not rotated, or there are fewer than 2 conic vars.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.Vids">
            <summary> The VIDs that belong to this cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISecondOrderCone.VidCount">
            <summary> The number of VIDs that belong to this cone.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SecondOrderConeType">
            <summary> Second order cone types.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConeType.Linear">
            <summary>Linear cone.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConeType.Quadratic">
            <summary>Quadratic cone.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConeType.RotatedQuadratic">
            <summary>Rotated quadratic cone.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverCapability">
            <summary> Supported capabilities of solvers that can be plugged into Foundation
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.Undefined">
            <summary>
            Default that has value 0
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.LP">
            <summary>
            Linear programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.QP">
            <summary>
            Quadratic programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.MILP">
            <summary>
            Mixed integer linear programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.CP">
            <summary>
            Constraint programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.NLP">
            <summary>
            General nonlinear programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.MINLP">
            <summary>
            General nonlinear programming
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverCapability.MIQP">
            <summary>
            Mixed integer quadratic programming
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolverEnvironment">
            <summary> Interface for defining solver environment. Solver environment will be passed into 3rd party solvers' ctors.
            </summary>
            <remarks>For future usage</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolverParameters">
            <summary> Interface for defining solver parameter class.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISolverParameters.QueryAbort">
            <summary> Callback for ending the solve
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolverEvents">
            <summary>
            Callbacks called periodically during solving
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ISolverEvents.Solving">
            <summary>
            Callback called periodically during solving
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ISolverProperties">
            <summary> Interface for solver which support property bag like getter and setter.
            This property bag may be used in events handler.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISolverProperties.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a solver-related property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ISolverProperties.GetProperty(System.String,System.Int32)">
            <summary>Get the value of a property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <returns>The property value as a System.Object.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IReportProvider">
            <summary> Interface for defining solvers which can provide a Solver Foundation Services report
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IReportProvider.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report.
            </summary>
            <param name="context">Solver context.</param>
            <param name="solution">The solution.</param>
            <param name="solutionMapping">The solution mapping.</param>
            <returns>A report object.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolversCollection">
            <summary> Customized element collection to handle plug-in solver elements
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MsfConfigSection">
            <summary> Class that handles the plug-in solver section in the configuration file.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.MsfConfigSection.Solvers">
            <summary>Get registered solvers.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverRegistrationCollection">
            <summary>Plug-in solver registration information.
            </summary>
            <remarks>
            SolverRegistrationCollection stores information about registered third-party solvers.
            This information is accessed using the SolverContext.RegisteredSolvers property. A registration
            entry contains information such as the name of the plug-in assembly and the solver capability 
            and interface it supports. This information is stored in the SolverRegistration class.
            A single plug-in solver may have multiple SolverRegistration entries, one for each capability
            supported by the solver. Entries are added to the collection automatically when a configuration
            file is associated with the application, or by calling the Add method.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.#ctor(Microsoft.SolverFoundation.Services.PluginSolverCollection)">
            <summary>Creates a new instance.
            </summary>
            <param name="solvers">A PluginSolverCollection.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.Create">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.Add(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Adds a new solver registration entry.
            </summary>
            <param name="item">The solver registration information.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.System#Collections#Generic#ICollection{Microsoft#SolverFoundation#Services#SolverRegistration}#Clear">
            <summary>Clears the collection (not supported).
            </summary>
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.Contains(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Determine if a registration entry exists.
            </summary>
            <param name="item">The solver registration information.</param>
            <returns>Returns true if the solver has been registered.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.CopyTo(Microsoft.SolverFoundation.Services.SolverRegistration[],System.Int32)">
            <summary>Copy registration entries to an Array.
            </summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The start index.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.System#Collections#Generic#ICollection{Microsoft#SolverFoundation#Services#SolverRegistration}#Remove(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Removes a registration entry (not supported).
            </summary>
            <param name="item">The solver registration information.</param>
            <returns>A boolean value indicating whether the item was removed.</returns>
            <exception cref="T:System.NotSupportedException"/>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.GetEnumerator">
            <summary>Get an enumerator for the collection.
            </summary>
            <returns>An IEnumerator.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Get an enumerator for the collection.
            </summary>
            <returns>An IEnumerator.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.GetDirectiveType(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Return the Type of the directive associated with a registration entry.
            </summary>
            <returns>A Type object for the directive, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.GetSolvers(Microsoft.SolverFoundation.Services.SolverCapability,System.Boolean,Microsoft.SolverFoundation.Services.Directive,Microsoft.SolverFoundation.Services.ISolverEnvironment,Microsoft.SolverFoundation.Services.SolverCapabilityFlags)">
            <summary> Return the default registered ISolver instance with the given capability (could be null)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.GetSolverParams(Microsoft.SolverFoundation.Services.SolverCapability,System.Type,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Return the parameter object for the given solver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.Count">
            <summary>The number of registration entries.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistrationCollection.IsReadOnly">
            <summary>Returns a value that indicates whether the collection is read only.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverRegistration">
            <summary>Information about a registered solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.#ctor(System.String,Microsoft.SolverFoundation.Services.SolverCapability,System.String,System.String,System.String,System.String,System.String)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.#ctor(Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement)">
            <summary>Create a new instance.
            </summary>
            <param name="element">A ConfigMsfPluginSolverElement.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.ToString">
            <summary>Return a string representation of the entry.
            </summary>
            <returns>Returns a string representation of the entry.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.CompareTo(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>A value that indicates the relative order of the objects being compared.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.System#IComparable#CompareTo(System.Object)">
            <summary>Compares the current object with another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>A value that indicates the relative order of the objects being compared.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.Equals(System.Object)">
            <summary>Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="obj">An object to compare with this object.</param>
            <returns>True if the current object is equal to the other parameter; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.GetHashCode">
            <summary>Serves as a hash function for a particular type. 
            </summary>
            <returns>A hash code for the current item.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.op_Equality(Microsoft.SolverFoundation.Services.SolverRegistration,Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Test for equality.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverRegistration.op_Inequality(Microsoft.SolverFoundation.Services.SolverRegistration,Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Test for inequality.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.Name">
            <summary> Get the name. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.Capability">
            <summary> Get the capability. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.InterfaceName">
            <summary> Get the solver interface name (optional).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.AssemblyName">
            <summary> Get the fully qualified name of the solver assembly.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.SolverClassName">
            <summary> Get the class name of the solver. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.DirectiveClassName">
            <summary> Get the class name of the solver directive.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverRegistration.ParameterClassName">
            <summary> Get the class name of the solver parameters.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement">
            <summary> Individual plugin solver section handler
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.Name">
            <summary> Get the name. This is the key.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.Capability">
            <summary> Get the capability. Solverclass + capability is the key.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.Assembly">
            <summary> Get the fully qualified name of the solver assembly
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.SolverClassName">
            <summary> Get the class name of the solver. Solverclass + capability is the key.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.DirectiveClassName">
            <summary> Get the class name of the solver directive
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConfigMsfPluginSolverElement.ParameterClassName">
            <summary> Get the class name of the solver parameters
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Arithmetic">
            <summary>This specifies an arithmetic to use for numeric solving. The choice of arithmetic trades speed for accuracy.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Arithmetic.Default">
            <summary>Let the system pick an arithmetic
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Arithmetic.Exact">
            <summary>Exact arithmetic
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Arithmetic.Double">
            <summary>Double floating-point arithmetic
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.RefFunction`2">
            <summary> callback
            </summary>
            <typeparam name="S"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.RefFunction`3">
            <summary> callback
            </summary>
            <typeparam name="S1"></typeparam>
            <typeparam name="S2"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="s1"></param>
            <param name="s2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Statics.QuadSort``1(System.Double[],``0[],System.Int32,System.Int32)">
            <summary>Selection sort.
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="rgv">Keys.</param>
            <param name="items">Items.</param>
            <param name="ivFirst">First index to sort.</param>
            <param name="ivLast">Last index to sort (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Statics.HashString(System.String)">
            <summary>
            Hash the characters in a string. This MUST produce the same result
            as HashStrBldr produces for the same characters.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Statics.HashStrBldr(System.Text.StringBuilder)">
            <summary>
            Hash the characters in a string builder. This MUST produce the same result
            as HashString produces for the same characters.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.GradientEntry">
            <summary> Represent &lt; diffRowVid, varVid> tuple 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.GradientEntry.derivRowVid">
            <summary> vid of gradient entry within the extended ITermModel (always a VID)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.GradientEntry.varVid">
            <summary> variable of differentiation index (always a VID)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModelDifferentiator">
            <summary> Abstract class specifying behavior of ITermModelDifferentiators. 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelDifferentiator.termModelGradientVids">
            <summary>Holds the derivative vids for requested differentiations
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelDifferentiator.differentiatedRows">
            <summary>SORTED vids of rows requested for differentiation. Same order as rows in termModelGradientVids.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelDifferentiator.modelRowsSorted">
            <summary>Sorted vids of all rows (including variables) in the model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermModelDifferentiator.diffVarsSorted">
            <summary>Sorted vids of variables with respect to which we need to differentiate.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel)">
            <summary>Differentiates an ITermModel.
            </summary>
            <param name="model">The ITermModel to differentiate.</param>
            <remarks>Adds rows that represent derivatives of row rowVid with respect to each variable. 
            Additionally fills in a (private) data structure that specifies the vids of these new rows.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel,System.Int32)">
            <summary>
            Differentiates an ITermModel.
            </summary>
            <param name="model">The ITermModel to differentiate.</param>
            <param name="rowVid">The vids to differentiate.</param>
            <remarks>Adds rows that represent derivatives of row rowVid with respect to each variable. 
            Additionally fills in a (private) data structure that specifies the vids of these new rows.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Differentiates an ITermModel.
            </summary>
            <param name="model">The ITermModel to differentiate.</param>
            <param name="rowVids">The vids to differentiate.</param>
            <remarks>Adds rows that represent derivatives of rows in rowVids with respect to each variable. 
            Additionally fills in a (private) data structure that specifies the vids of these new rows. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel,System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>Differentiates an ITermModel.
            </summary>
            <param name="model">The ITermModel to differentiate.</param>
            <param name="rowVids">The vids to differentiate.</param>
            <param name="varVid">The vid of the variable with respect to which to differentiate.</param>
            <remarks>Adds rows that represent derivatives of rows in rowVids with respect to variable indexed by varVid. 
            Additionally fills in a (private) data structure that specifies the vids of these new rows. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel,System.Collections.Generic.IEnumerable{System.Int32},System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Differentiates an ITermModel. 
            </summary>
            <param name="model">The ITermModel to differentiate.</param>
            <param name="rowVids">The vids to differentiate.</param>
            <param name="varVids">The vids of variables with respect to which to differentiate.</param>
            <remarks>Adds rows that represent derivatives of rows in rowVids with respect to variable indexed by varVid. 
            Additionally fills in a (private) data structure that specifies the vids of these new rows. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.VerifyDifferentiated">
            <summary>Verify a model has actually been differentiated.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.ValidateModelRows(Microsoft.SolverFoundation.Services.ITermModel,System.Int32[])">
            <summary> Validates the input rows are row vids.
            </summary>
            <param name="model">An ITermModel.</param>
            <param name="rowVidsToValidate">rows whose presense in model we validate</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.ValidateModelVars(Microsoft.SolverFoundation.Services.ITermModel,System.Int32[])">
            <summary> To be called after is sorted so that binary search can be used. 
            </summary>
            <param name="model">model</param>
            <param name="varVidsToValidate">rows whose presense in model we validate</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.IsOrderGuaranteed(Microsoft.SolverFoundation.Services.ITermModel)">
            <summary>Check if model is known to have rows and variables for differentiation in order.
            </summary>
            <param name="model">The model.</param>
            <returns>True if order is guaranteed, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.GetDifferentiatedRows">
            <summary>Gets an IEnumerable of rows which were differentiated.
            </summary>
            <returns>The row vids with nonzero derivatives.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.GetDerivativeVariables(System.Int32)">
            <summary>Gets an IEnumerable of variable vids for those variables with respect to which the given row was differentiated.
            ArgumentException will be thrown if the vid is not listed in GetDifferentiatedRows().
            An empty result will be returned if the given row has no non-zero derivatives.
            <param name="rowVid">The vid of the differentiated row.</param>
            </summary>
            <returns>Variable vids with respect to which nonzero derivatives were obtained.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.GetRowGradientEntries(System.Int32)">
            <summary>Gets GradientEntry tuples which represent the variable of differentiation vid and derivative vid for a given row.
            ArgumentException will be thrown if the vid is not listed in GetDifferentiatedRows().
            An empty result will be returned if the given row has no non-zero derivatives.
            </summary>
            <param name="rowVid">The vid of the differentiated row.</param>
            <returns>GradientEntries for the nonzero gradient entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelDifferentiator.GetRowGradientEntry(System.Int32,System.Int32)">
            <summary>Gets the row index in ITermModel type which represents the derivative of a specified row wrt to a specified variable. 
            Throws an ArgumentException if the given row has no non-zero derivatives. Throws an ArgumentException if no derivative exists for the variable.
            </summary>
            <param name="rowVid">The row whose gradient component is to be retrieved.</param>
            <param name="varVid">The vid for the variable the row for the derivative with respect to which is to be gotten.</param>
            <returns> row indices into extended ITermModel type</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.VectorUtility">
            <summary> The VectorUtility class contains a number of methods useful
                      for working with vectors of double.  It specializes in
                      extension methods for the double[] type.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Params(System.Char[])">
            <summary> The convenience of "params", useful anywhere
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Params(System.Int32[])">
            <summary> The convenience of "params", useful anywhere
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Params(System.Double[])">
            <summary> The convenience of "params", useful anywhere
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Params``1(``0[])">
            <summary> The convenience of "params", useful anywhere
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.VerifyVectorsAreSameSize(System.Double[],System.Double[])">
            <summary> Throw an exeption if length of vectors is 0 or if the length of the 
            the vectors are not the same
            </summary>
            <param name="x">vector x</param>
            <param name="y">vector y</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.VerifyVectorHasNonZeroLength(System.Double[])">
            <summary>
            Throw an exeption if length of vector is 0, 
            </summary>
            <param name="x">the vector to check</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.CopyOver(System.Double[],System.Double[]@)">
            <summary> Copy x into y, reusing y if possible, creating new otherwise
            </summary>
            <param name="x"> source values </param>
            <param name="y"> array to be overwritten or created with x' values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.CopyOver(System.Double[],System.Int32,System.Double[]@)">
            <summary> Copy x into y, reusing y if possible, creating new otherwise
            </summary>
            <param name="x"> source values </param>
            <param name="sourceIndex"> copy all values from startFrom up to end </param>
            <param name="y"> array to be overwritten or created with x' values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.CopyOver(System.Double[],System.Double[]@,System.Int32)">
            <summary> Copy x into y, reusing y if possible, creating new otherwise
            </summary>
            <param name="x"> source values </param>
            <param name="count"> copy first count values, Length of result </param>
            <param name="y"> array to be overwritten or created with x' values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ZeroFill(System.Double[])">
            <summary> x[] = 0 -- (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ConstantFill(System.Double[],System.Double)">
            <summary> x[] = c -- (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ConstantFill(System.Int32[],System.Int32)">
            <summary> x[] = c -- (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Plus(System.Double[],System.Double[])">
            <summary> z[] = x[] + y[] -- pairwise (extension method)
            </summary>
            <returns> a new vector the same length as x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.SubtractInto(System.Double[],System.Double[],System.Double[])">
            <summary> z[] = x[] - y[] -- (z is preallocated) pairwize (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Increment(System.Double[],System.Double)">
            <summary> x[] += y -- add scalar y to every element of x
            </summary>
            <returns> a new vector the same length as x  </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.AreExactlyTheSame(System.Double[],System.Double[])">
            <summary> x[] == y[] -- pairwize 
            </summary>
            <returns>true if both are pairwize equal</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Minus(System.Double[],System.Double[])">
            <summary> z[] = x[] - y[] -- pairwise (extension method)
            </summary>
            <returns> a new vector the same length as x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Max(System.Double[])">
            <summary> return Max value found in x[]
            </summary>
            <returns> the maximal value in the array </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Min(System.Double[])">
            <summary> return Min value found in x[]
            </summary>
            <returns> the minimal value in the array </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Times(System.Double[],System.Double[])">
            <summary> z[] = x[] * y[] -- pairwise (extension method)
            </summary>
            <returns> a new vector the same length as x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Over(System.Double[],System.Double[])">
            <summary> z[] = x[] / y[] -- pairwise (extension method)
            </summary>
            <returns> a new vector the same length as x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.AddScaledVector(System.Double[],System.Double[],System.Double)">
            <summary> x[] += (y[] * c) -- (extension method)
            Uses the Daxpy method
            </summary>
            <returns> a new vector the same length as x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ScaleBy(System.Double[],System.Double)">
            <summary> x[] *= a        -- (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ScaleBy(System.Double[],System.Double,System.Int32,System.Int32)">
            <summary> x[] *= a        -- (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ScaleIntoMe(System.Double[],System.Double[],System.Double)">
            <summary> x[] = y[] * a        -- (extension method)
            </summary>update x[] with scaled y[]
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.InnerProduct(System.Double[],System.Double[])">
            <summary> z = x[]·y[] -- (extension method)
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Daxpy(System.Double,System.Double[],System.Double[])">
            <summary> y[] = a*x[] + y[] -- implement BLAS daxpy operation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ElemMultiply(System.Double[],System.Double[],System.Double[])">
            <summary> z[] = x[] * y[] -- pairwise (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.ElemDivide(System.Double[],System.Double[],System.Double[])">
            <summary> z[] = x[] / y[] -- pairwise (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Norm2(System.Double[])">
            <summary> a = 2-norm of vector x -- (extension method)
            </summary>
            <returns> Euclidean norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.NormInf(System.Double[])">
            <summary> a = Infinity-norm of vector x -- (extension method)
            </summary>
            <returns> Infinity-norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Concat(System.Double[],System.Double[],System.Double[])">
            <summary> z[] = [ x[]; y[] ] -- vector concatenation (pre-allocated memory)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.Split(System.Double[],System.Double[],System.Double[])">
            <summary> [ x[]; y[] ] = z[]  -- split vector z into x and y (pre-allocated memory)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.VectorUtility.AreUniqueAscending(System.Int32[],System.Int32,System.Int32)">
            <summary> Test if a sequence of integers has values all unique in ascending order
            </summary>
            <returns> true iff unique values in ascending order </returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.DoubleRaw">
            <summary> Implements IEEE Double operations that System.Math fails to provide.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.DoubleRaw.Exponent">
            <summary> Return the exponent, biased so zero has exponent -0x3FF, infinity +0x400
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.DoubleRaw.Fraction">
            <summary> Return the fraction, unsigned, implied bit restored, justified left
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.ApproximateMinDegreeWorkspace">
            <summary> A supernodal approximate minimum degree ordering algorithm.
            </summary>
            <remarks> Read Timothy Davis's book on Direct Methods for Sparse Matrices for details.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymbolicFactorWorkspace">
            <summary> Computes the symbolic factor of a symmetric sparse matrix.
            </summary>
            <remarks> Subclasses implement different symbolic factorization algorithms, e.g. AMD, Minimum Fill.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorWorkspace._M">
            <summary> The current set of coeffs in the workspace
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymbolicFactorWorkspace.Factorize">
            <summary>Computes the symbolic factorization, modifying M.
            </summary>
            <returns>Symbolic factorization information, including mapping from original to permuted columns.</returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorWorkspace.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymbolicFactorWorkspace.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Double[],Microsoft.SolverFoundation.Common.FactorizationParameters,System.Func{System.Boolean})">
            <summary> Create a new instance.
            </summary>
            <param name="M">The matrix.</param>
            <param name="colWeights">Column weights.</param>
            <param name="factorizationParameters">Factorization parameters</param>
            <param name="abort">Abort delegate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ApproximateMinDegreeWorkspace.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Double[],Microsoft.SolverFoundation.Common.FactorizationParameters,System.Func{System.Boolean})">
            <summary> Create a new instance.
            </summary>
            <param name="M">The matrix.</param>
            <param name="colWeights">Column weights.</param>
            <param name="factorizationParameters">Factorization parameters</param>
            <param name="abort">Abort delegate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ApproximateMinDegreeWorkspace.Factorize">
            <summary>Computes the symbolic factorization, modifying M.
            </summary>
            <returns>Symbolic factorization information, including mapping from original to permuted columns.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.AMD">
            <summary> Finds the AMD ordering for a matrix. 
            </summary>
            <remarks> Unlike the minimize local fill code, this method does NOT compute the structure of L.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AMD.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble)">
            <summary>Create a new instance.
            </summary>
            <param name="M">The matrix.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AMD.PlanBestOrder">
            <summary> Permute the symbolics to choose an order with low fill.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AMD.RemoveSupernodes(System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32@)">
            <summary>Detect and remove supernodes.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AMD.Postorder(System.Int32[],System.Int32[])">
            <summary> Determine the final AMD ordering based on the assembly tree.  The assembly tree
            is stored in columnStarts and is a tree that consists of all nodes/elements that were chosen 
            during the AMD procedure.  Nodes and elements that were absorbed into supernodes are not present
            in the tree.  Therefore we need to add them to the assembly tree before actually performing
            the postordering.  The postordering permutes the ordering in a way that preserves the nonzero
            structure, but gives better structure to the factor.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.AMD.Order">
            <summary>An ordering on the columns of A that results in reduced fill.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.VarSpecial">
            <summary> Track special conditions for a variable
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.VarSpecial.Unbounded">
            <summary> Unbounded variable
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.VarSpecial.NotSeparable">
            <summary> Variable has quadratic off-diagonal term(s)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.VarSpecial.QDiagonal">
            <summary> Variable has a quadratic term on the diagonal
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.FactorUtilities">
            <summary> Declare enums and extension methods for them
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.FactorUtilities.MayBeNormal(Microsoft.SolverFoundation.Common.VarSpecial)">
            <summary> Does the variable meet the requirements to be allowed in the Normal section?
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.KktBlendedFactor">
            <summary> The Karush-Kuhn-Tucker conditions on linear or quadratic
                      systems result in symmetric matrices which can be factored.
                      Blend uses a hybrid of Augmented and Normal forms.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace">
            <summary> The SymmetricFactorWorkspace is a base class for problems which
                      construct symmetric matrices and then factorizes them.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace._M">
            <summary> The current set of coeffs in the workspace
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace._maxColumnCount">
            <summary> The largest count of non-zeros in any column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace._firstDenseColumn">
            <summary> If the matrix becomes dense we can switch algorithms for speed against space
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace._diagonalFactor">
            <summary> Diagonal inner array for L D L^T = M.  Values +1 or -1.  Indexed by Inner row/col!
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace._perturbList">
            <summary> The columns and values perturbed in M when forming Cholesky
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.SetMapHazard(System.Int32[])">
            <summary> Initialize map indexes to -1 to trap misuse
            </summary>
            <param name="map"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Rehash(System.Int32@,System.Int32)">
            <summary> This hash function is used to cluster columns for supernode discovery
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.DisplayColumn(System.Int32)">
            <summary> Quick and simple string view of one column
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.DisplayColumns">
            <summary> Quick and simple string view, column-by-column, in internal order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.DisplayMappedColumns">
            <summary> Quick and simple string view, column-by-column, in client's order.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.DiagonalExponents">
            <summary> Scan the diagonal and get the binary exponents limited to 0..255.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Factorize(System.Func{System.Double[]},System.Int32)">
            <summary>Performs the symbolic factorization for a matrix.
            </summary>
            <param name="PlanProductFillIn">A method that plans the fill-in.</param>
            <param name="columnCount">Column count for factorized matrix.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.#ctor(System.Int32,Microsoft.SolverFoundation.Common.FactorizationParameters)">
            <summary> The SymmetricFactorWorkspace is a base class for problems which
                      construct symmetric matrices and then factorize them.
            </summary>
            <param name="rowColumnCount"> the rows count == columns count </param>
            <param name="factorParam">Symbolic factorization parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.UnpermutedLower">
            <summary> Construct a non-permuted copy of the current working matrix.
                      It will be trimmed to skip zeroes.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CholeskyLeftCmodCdivSparse(System.Int32,System.Int32,System.Int32[],System.Double[],System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Compute the Cmod and Cdiv operations for a single column.
                      Use left-look in a multi-thread environment.
            </summary>
            <param name="jCol"> the column to be recalculated </param>
            <param name="lastRow"> the last row value is overwritten in indexes[] so true value is passed here </param>
            <param name="map"> a per-thread scratch array to be used for mapping into the array </param>
            <param name="sums"> the new values accumulated for the column </param>
            <param name="perturbations"> tracks perturbation information for use in pivot decisions </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CholeskyLeftCmodCdivDense(System.Int32,System.Double[],System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Compute the Cmod and Cdiv operations for a single column.
                      Use left-look.
            </summary>
            <param name="jCol"> the column to be recalculated </param>
            <param name="sums"> the new values accumulated for the column </param>
            <param name="perturbations"> tracks perturbation information for use in pivot decisions </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.MakeColumnsNotReady">
            <summary> We use a word of the row indexes as a synchronization flag since this
                      is both nicely scattered to minimize cache ping-pong and must be
                      brought into cache anyway.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.WaitUntilReady(System.Int32)">
            <summary> Wait until a column we depend on has been processed by another thread.
            </summary>
            <param name="col"> the column we depend on </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CholeskyLeftThread(System.Object)">
            <summary> The left-looking Cholesky formulated for multiple threads.
            </summary>
            <param name="state"> the thread state to be used to guide this thread </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Cholesky">
            <summary> Compute the Cholesky from the combined A D A* values.
            <remarks> Initializing the problem matrix is a prerequisite </remarks>
            </summary>
            <exception cref="T:System.DivideByZeroException"> Divide by zero may occur due to pivot policy </exception>
            <exception cref="T:System.TimeoutException"> Timeout may occur if CheckAbort reports true </exception>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.ForwardSolve(Microsoft.SolverFoundation.Common.Vector,System.Double[])">
            <summary> Solve Lx = y for x
            <code>
              y[0] = y[0] / L[0,0]
              for i = 1:n-1
                y[i] = (y[i] - L[i,0:i-1]*y[0:i-1])/L[i,i]
            </code>
            see Golub &amp; Van Loan, 3.1.1, modified not to overwrite y.
            <remarks> A complete solve may be written:
                      x = BackwardSolve(ForwardSolve(y))
            </remarks>
            </summary>
            <param name="y"> rhs known values </param>
            <param name="reals"> space to accumulate Real parts </param>
            <returns> a new x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.BackwardSolve(Microsoft.SolverFoundation.Common.Vector,System.Double[])">
            <summary> Solve Ux = y for x, U is upper triangular (== L-transpose)
            <code>
              y[n-1] = y[n-1] / U[n-1,n-1]
              for i = n-2:0
                y[i] = (y[i] - U[i,i+1:n-1]*y[i+1:n-1])/U[i,i]
            </code>
            <remarks> A complete solve may be written:
                      x = BackSolve(ForwardSolve(z))
            </remarks>
            </summary>
            see Golub &amp; Van Loan, 3.1.2
            <param name="y"> y is overwritten with the result </param>
            <param name="reals"> space to accumulate Real parts </param>
            <returns> the overwritten y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Solve(Microsoft.SolverFoundation.Common.Vector)">
             <summary> Solve FactoredSymmetricM * x = z for unknown x
             </summary>
             <returns> x </returns>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Parameters">
            <summary>Factorization parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.ColumnCount">
            <summary> Count of columns in the workspace
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.OuterToInner">
            <summary> Permutation from user's column to internal column
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.InnerToOuter">
            <summary> Permutation from internal column to user's column
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.HasDenseColumns">
            <summary> If the matrix becomes dense we can switch algorithms for speed against space
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.RefinePivot">
            <summary> When a zero pivot is discovered, the remedy depends upon the usage.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.Count">
            <summary> Count the non-zeros in a factor.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.PivotPolicy">
            <summary> When a zero pivot is discovered, the remedy depends upon the usage.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CholeskyParallelizer">
            <summary> A context object used to control symbolic factorization threads
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Parallelizer">
            <summary> Set up an object to manage a level of parallelization suited to an algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Parallelizer.#ctor">
            <summary> Control parallel operation
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Parallelizer.Failed">
            <summary> Any thread may set Failed true.  All should stop if they see it has happened.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Parallelizer.Run(System.Action{System.Object},System.Int32)">
            <summary> Run a copy of the action on each thread and wait for all to finish
            </summary>
            <param name="action"> the Action to be run by each thread </param>
            <param name="maximumUsefulThreading"> Keep the investment in threading sensibly bounded </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricFactorWorkspace.CholeskyParallelizer.#ctor">
            <summary> A context object used to control symbolic factorization threads
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._A_x">
            <summary> The linear coefficient matrix for x
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._At_x">
            <summary> The transpose view of Ax
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._A_s">
            <summary> The linear coefficient matrix for s
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._At_s">
            <summary> The transpose view of As
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._Q_x">
            <summary> The quadratic coefficients for x are in Q_x.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._Q_s">
            <summary> The quadratic coefficients for s are in Q_s.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._varInfo">
            <summary> Track augmented outer columns which are unbounded.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.KktBlendedFactor._zeroPivotTolerance">
            <summary>Diagonal values smaller than this value are handled specially.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.IsUnbounded(System.Int32)">
            <summary> Report if an outer column corresponds to an unbounded variable.
            </summary>
            <param name="outerCol"></param>
            <returns> true iff the column is unbounded </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.IsQuadratic(System.Int32)">
            <summary> Report if an outer column corresponds to a quadratic variable.
            </summary>
            <param name="outerCol"></param>
            <returns> true iff the column is quadratic </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.MapToPrimal(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Double[]@)">
            <summary> Map the augmented and normal parts of a blend back into original vector
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.MapToBlend(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector@,Microsoft.SolverFoundation.Common.Vector@)">
            <summary> Map a primal vector into the separate parts of the blend
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.BuildPartialMatrix(System.Int32,System.Collections.Generic.List{System.Int32},System.Int32,System.Int32[],System.Boolean,Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32[]@,System.Double[]@)">
            <summary> Construct the row indexes and values for a partial subset of an existing matrix.
            </summary>
            <param name="slotCount"> count slots which will allow non-zeros within the matrix </param>
            <param name="starts"> where within indexes to find the start of each column </param>
            <param name="mask"> select augmented (complement, ~0) or normal (unchanged, 0) index values </param>
            <param name="colMap"> map for primal column to blend column </param>
            <param name="mapRows"> should mask apply to row values too ? </param>
            <param name="X"> the full matrix from which we are selecting either augmented or simple values </param>
            <param name="indexes"> the indexes for the new, partial matrix </param>
            <param name="values"> the values for the new, partial matrix </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.SeparateColumns(Microsoft.SolverFoundation.Common.SparseMatrixDouble,Microsoft.SolverFoundation.Common.SymmetricSparseMatrix)">
            <summary> Distinguish between the complicated and the simple columns and
                initialize the matrices and column transforms accordingly.  We want to
                separate the columns which are suitable for Normal form, from those where
                we are better to use Augmented form.
            </summary>
            <param name="A"> the existing, combined A matrix to be analyzed </param>
            <param name="Q"> the existing Q matrix to be analyzed </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.PlanProductFillin">
            <summary> Plan the fillin of the blended &lt;A,Q,Z/X> matrix.
            <remarks> This block fill is both below and above diagonal.  It is reduced to
                      below diagonal by symbolic factorization.
            </remarks>
            </summary>
            <returns> initial weighting combines integer degree with a fractional pattern-hash </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.BlendedPivotRepair(System.Int32,System.Double,System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Cause a zero pivot's row and column to be ignored.
            </summary>
            <returns> throw a DivideByZeroException </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,Microsoft.SolverFoundation.Common.SymmetricSparseMatrix,Microsoft.SolverFoundation.Common.VarSpecial[],System.Func{System.Boolean},Microsoft.SolverFoundation.Common.FactorizationParameters)">
            <summary> Construct a KKT context for the Blended form equations in Central Path IPM.
            </summary>
            <param name="A"> The (required) linear coefficients' matrix </param>
            <param name="Q"> The (optional) quadratic coefficients' matrix </param>
            <param name="varInfo"> indicates glitches affecting each variable </param>
            <param name="CheckAbort"> predicate returns false for continue, true if stop required </param>
            <param name="factorParam">Symbolic factorization parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.SetBlendedValues(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Double)">
            <summary> Prepare the blended matrix using A, Q, Z/X, and Z/S.
            </summary>
            <param name="z_x"> quadratic complementarity Z/X numerator </param>
            <param name="x"> quadratic complementarity Z/X denominator </param>
            <param name="z_s"> quadratic complementarity Z/S numerator </param>
            <param name="s"> quadratic complementarity Z/S denominator </param>
            <param name="perturbation"> perturbation to use on zero diagonals </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.KktBlendedFactor.Solve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> A complete solution of the system A*D*At x = z
            </summary>
            <returns> x = BackSubstitution(ForwardSubstitution(z)) </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.Decided">
            <summary> If the model is decided during construction, we set this.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.AugCount">
            <summary> Count of columns/rows in the left/top blocks of the Blended form
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.Ycount">
            <summary> Count of columns/rows in the right/lower blocks of the Blended form
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.SimpleCount">
            <summary> Count of Simple columns in the Blended form
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.PrimalToBlend">
            <summary> Permute the variables into hard (augmented) columns preceding simple columns.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.AugToPrimal">
            <summary> Permute from the augmented (hard) to the original primal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.KktBlendedFactor.SimpleToPrimal">
            <summary> Permute from the simple to the original primal.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions">
            <summary> Utilities and extension methods that are useful for factorization.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Resize(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32)">
            <summary>Change the number of nonzeros allocated to a SparseMatrixDouble.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.ConstantFill(System.Int32[],System.Int32)">
            <summary>Set all values to a constant.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.ConstantFill(System.Int64,System.Int32)">
            <summary>Allocate a new array with all values set to a constant.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.IdentityPermutation(System.Int32)">
            <summary>Create the identity permutation.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.InvertPermutation(System.Int32[])">
            <summary>Invert a permutation.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Mark(System.Int32[],System.Int32)">
            <summary>Mark an entry in the array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Flip(System.Int32)">
            <summary>"Flip" a value.  (This function is its own inverse.)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.CumulativeSum(System.Int32[],System.Int32[])">
            <summary>Compute the cumulative sum of c, storing in "this". c is also modified.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Add(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Double,System.Double)">
            <summary>Add sparse matrices.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.EliminationTree(Microsoft.SolverFoundation.Common.SparseMatrixDouble)">
            <summary> Computes the elimination tree of a sparse matrix.  If we regard the
            columns of A as nodes, the elimination tree represents the nonzero structure
            of the Cholesky factor L.  The elimination tree is a pruned version of the
            graph of the nonzeros of L.
            </summary>
            <param name="A">A sparse matrix.</param>
            <returns>The parent of each node in the elimination tree.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Postorder(System.Int32[])">
            <summary> Postorder the tree given by parent. The postordering permutes the matrix in a way that 
            preserves nonzero structure, but gives better structure.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.TraverseDFS(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary> Postorder traversal starting at node j.  Write indexes in post starting at index k.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Reach(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary> Compute the nonzero pattern of one row in the factorization.
            Use the elimination tree (parent) to traverse the kth row subtree.
            </summary>
            <remarks>w is temporary storage which is restored on output.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.Scatter(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Int32,System.Double,System.Int32[],System.Double[],System.Int32,Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32)">
            <summary>Scatters the elements of column col into a dense vector x, scaling by beta and filtering using (filter, limit).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.RemoveDiagonal(Microsoft.SolverFoundation.Common.SparseMatrixDouble)">
            <summary> Remove diagonal entries.
            </summary>
            <param name="A">The matrix.</param>
            <returns>The number of nonzeros in the matrix after removal.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.FactorColumnCounts(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32[],System.Int32[])">
            <summary> Compute the number of nonzero entries in each column of the Cholesky factorization of A.
            </summary>
            <param name="A">The matrix.</param>
            <param name="parent">The elimination tree of A.</param>
            <param name="post">The postordering of A.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.IsLeafInEliminationSubtree(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32@,System.Int32@)">
            <summary> Determine if j is a leaf of the ith row elimination subtree.  (Section 4.4 of Davis)
            </summary>
            <param name="i">The index of the elimination subtree</param>
            <param name="j">The index of the node to test.</param>
            <param name="first">First[j] is the first descendant of j in the subtree.</param>
            <param name="maxfirst"></param>
            <param name="prevleaf"></param>
            <param name="ancestor">The ancestor of each node.  -1 for root nodes.</param>
            <param name="isLeaf">Is 0 if j is not a leaf, is 1 if it is the first leaf, 2 if a subsequent leaf. (See Figure 4.9 in Davis.)</param>
            <param name="jLCA">The least common ancestor of j and its previous leaf, if j is a leaf.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Factorization.FactorizationExtensions.PermuteUpperTriangular(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Int32[],System.Boolean)">
            <summary> For upper-triangular A, compute C = A(p, p), given the inverse of p.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.IVector">
            <summary> A wrapper for double[] which implements algebraic operators.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Copy">
            <summary> Construct a new Vector as a copy of this
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.CopyFrom(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Copy values from another vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ToArray">
            <summary> The contents of the vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ZeroFill">
            <summary> x[] = 0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ConstantFill(System.Double)">
            <summary> v[] = c
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Max">
            <summary> Return maximum value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Min">
            <summary> Return minimumvalue
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Norm2">
            <summary> a = 2-norm of vector x.
            </summary>
            <returns> Euclidean norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.NormInf">
            <summary> a = Infinity-norm of vector x.
            </summary>
            <returns> Infinity-norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Sum">
            <summary> return sum of all values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.BigSum">
            <summary> return sum of all values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Add(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] += y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.AddConstant(System.Double)">
            <summary> v[] += y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.BigInnerProduct(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Inner product as a BigSum.
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ElementDivide(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] /= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ElementInvert(Microsoft.SolverFoundation.Common.Vector)">
            <summary> y[] = 1 / x[] -- pairwise
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ElementMultiply(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] *= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.InnerProduct(Microsoft.SolverFoundation.Common.Vector)">
            <summary> z = x[]·y[] 
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Over(System.Double)">
            <summary> v[] /= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.ScaleBy(System.Double)">
            <summary> v[] *= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Split(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> [ x[]; y[] ] = this  -- split vector into x and y (pre-allocated memory)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IVector.Subtract(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] -= y[]
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.IVector.Length">
            <summary> The length of the vector.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.IVector.Item(System.Int32)">
            <summary> Element accessor for the vector.
            </summary>
            <remarks>If performance is a concern, directly access the array using V and Start.</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace">
            <summary> The quadratic matrix is factored to check if it is positive semidefinite
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace._Q">
            <summary> The quadratic coefficients are in Q.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace.PlanProductFillin">
            <summary> Plan the fillin of the Q matrix.
            Each column is summarized as a Markowitz count (integer part) and
              a hash (fractional part) so that identical columns will cluster.
            <remarks> This block fill is both below and above diagonal. </remarks>
            </summary>
            <returns> initial weighting combines degree with a fractional pattern hash </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace.PivotInspection(System.Int32,System.Double,System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Default behavior on an invalid pivot is to throw a DivideByZeroException.
            </summary>
            <returns> throw a DivideByZeroException </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace.#ctor(Microsoft.SolverFoundation.Common.SymmetricSparseMatrix,System.Func{System.Boolean})">
            <summary> Construct a KKT context for the Normal form equations in Central Path IPM.
            </summary>
            <param name="Q"> The (optional) quadratic coefficients' matrix </param>
            <param name="CheckAbort"> predicate returns false for continue, true if stop required </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace.SetWorkspaceValues">
            <summary> Compute the augmented matrix using Q.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.QuadraticFactorWorkspace.Solve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> A complete solution of the system A*D*At x = z
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Matrix">
            <summary> A wrapper for double[][] which implements algebraic operators.
            </summary>
            <remarks>
            Dense matrix operations are not tuned for performance.  These routines should
            not be used for large matrices without further turning.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Matrix.m">
            <summary> The contents of the Matrix.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.#ctor(System.Int32,System.Int32)">
            <summary> Construct an empty Matrix of specified length
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.#ctor(System.Double[][])">
            <summary> Construct an empty Matrix of specified length
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Clone">
            <summary> Shallow copy
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.op_Implicit(System.Double[][])~Microsoft.SolverFoundation.Common.Matrix">
            <summary> Assignment conversion
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.VerifySameShape(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Throw an exception if the dimensions of the matrices do not match.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.VerifySquare">
            <summary> Throw an exception the matrix is not square.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.VerifyNonZeroLength">
            <summary> Throw an exeption if length of Matrix is 0, 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ZeroFill">
            <summary> x[] = 0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ConstantFill(System.Double)">
            <summary> x[] = c
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.FillIdentity">
            <summary> x[] = c
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.FillColumn(System.Int32,System.Int32,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> Fill a column of the matrix with a scaled vector.
            </summary>
            <param name="column">The column to fill.</param>
            <param name="rowStart">The row index where copying starts.</param>
            <param name="alpha">The scaling factor for v.</param>
            <param name="v">The input vector.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ScaleColumn(System.Int32,System.Double,System.Int32)">
            <summary> Scale a column of the matrix.
            </summary>
            <param name="column">The column to scale.</param>
            <param name="alpha">The scaling factor.</param>
            <param name="rowStart">The row index to start.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.CopyColumnTo(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary> Copy a column to a vector.
            </summary>
            <param name="v">The vector.</param>
            <param name="col">The column to copy from.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Plus(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> v[] += y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Minus(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> v[] -= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.op_Addition(Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Matrix)">
            <summary> z[] = x[] + y[] -- (z is preallocated) pairwize (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.op_Subtraction(Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Matrix)">
            <summary> z[] = x[] - y[] -- (z is preallocated) pairwize (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.op_Multiply(Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Matrix)">
            <summary> z[] = x[] * y[] -- (z is preallocated) pairwise (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.op_Multiply(Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = x[] * y[] -- (z is preallocated) pairwise (extension method)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.SumProductRight(System.Double,Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> Compute alpha x[:,j] y[j] + beta z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.SumLeftProduct(System.Double,Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> Compute alpha x[i] y[i,:] + beta z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.SumProductRight(System.Double,Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Matrix,System.Double,Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Compute alpha x y + beta z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.SumLeftProduct(System.Double,Microsoft.SolverFoundation.Common.Matrix,Microsoft.SolverFoundation.Common.Matrix,System.Double,Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Compute alpha y' x + beta z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Plus(System.Double)">
            <summary> v[] += y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Minus(System.Double)">
            <summary> v[] -= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Times(System.Double)">
            <summary> v[] *= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Over(System.Double)">
            <summary> v[] /= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.AreExactlyTheSame(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> x[] == y[] -- pairwize 
            </summary>
            <returns>true if both are pairwize equal</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Min">
            <summary>Find the minimum value in the matrix.
            </summary>
            <returns>The minimum value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.Max">
            <summary>Find the maximum value in the matrix.
            </summary>
            <returns>The maximum value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.IndexColMaxAbs(System.Int32,System.Int32)">
            <summary>Find the maximum magnitude value in a column.
            </summary>
            <returns>The maximum value in the column.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.IndexRowMaxAbs(System.Int32,System.Int32)">
            <summary>Find the maximum magnitude value in a row.
            </summary>
            <returns>The maximum value in the row.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.RankOneUpdate(Microsoft.SolverFoundation.Common.Matrix,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Microsoft.SolverFoundation.Common.Matrix,System.Int32,System.Int32,Microsoft.SolverFoundation.Common.Matrix,System.Int32,System.Int32)">
            <summary>Perform a rank-one update alpha * b * c' of a matrix, using a column in matrix B
            and row in matrix C.
            </summary>
            <param name="A">The matrix to update.</param>
            <param name="rowStart">The first row in the matrix to update.</param>
            <param name="colStart">The first column in the matrix to update.</param>
            <param name="rowCount">The number of rows to update.</param>
            <param name="colCount">The number of columns to update.</param>
            <param name="alpha">The scaling factor.</param>
            <param name="B">The matrix containing the column vector.</param>
            <param name="bRowStart">The first row in B.</param>
            <param name="b_col">The column to use in B.</param>
            <param name="C">The matrix containing the row vector.</param>
            <param name="c_row">The row to use in B.</param>
            <param name="cColStart">The first column in C.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.SwapRows(System.Int32,System.Int32)">
            <summary>Swap rows in a matrix.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.PivotRows(System.Int32[])">
            <summary>Swap rows according to the specified pivot vector.
            </summary>
            <param name="pivot">Row i will be swapped with pivot[i].  pivot is NOT a permutation.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ToString">
            <summary>Returns a string representation of the matrix.
            </summary>
            <returns>A string representation of the matrix.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ToString(System.String,System.IFormatProvider)">
            <summary>Returns a string representation of the matrix.
            </summary>
            <returns>A string representation of the matrix.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Matrix.ToStringCore(System.Int32)">
            <summary>Returns a string representation of the matrix.
            </summary>
            <returns>A string representation of the matrix.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Matrix.M">
            <summary> The contents of the Matrix.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Matrix.Item(System.Int32,System.Int32)">
            <summary> Element accessor for the Matrix.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Matrix.RowCount">
            <summary> The row count of the Matrix.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Matrix.ColumnCount">
            <summary> The column count of the Matrix.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Matrix.IsEmpty">
            <summary> Is this Matrix empty?
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.DenseLUFactor">
            <summary> Solves systems of linear equations using LU factorization.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.DenseLUFactor._zeroPivotTolerance">
            <summary>Diagonal values smaller than this value are handled specially.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.#ctor(Microsoft.SolverFoundation.Common.Matrix)">
            <summary>Create a new instance.
            </summary>
            <param name="M">The matrix to factor (rectangular is okay).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.ForwardSolve(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Solve U X = B.
            </summary>
            <param name="B">The right hand side.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.ForwardSolve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Solve U x = b.
            </summary>
            <param name="b">The right hand side (replaced with x).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.BackwardSolve(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Solve L X = B.
            </summary>
            <param name="B">The right hand side (replaced with x).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.BackwardSolve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Solve L X = B.
            </summary>
            <param name="b">The right hand side (replaced with x).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.Solve(Microsoft.SolverFoundation.Common.Matrix)">
            <summary> Solve M X = B.
            </summary>
            <param name="B">The right hand side (replaced with X).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.Solve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Solve M x = b.
            </summary>
            <param name="b">The right hand side (replaced with X).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.DenseLUFactor.Factor">
            <summary> Find the LU factorization for the matrix.
            </summary>
            <remarks> Based on algorithm 3.2.1 in Golub and Van Loan.  It is also similar to the level-2 
            algorithm used by LAPACK.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.DenseLUFactor.M">
            <summary> The factorization (U in the upper triangular portion, L in lower).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.DenseLUFactor.Pivot">
            <summary> The row pivot vector.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace">
            <summary> An inexact minimum local fill ordering algorithm.
            </summary>
            <remarks>
            Inexact minimum local fill uses the External Degree ordering as a starting point.
            This is a variation on the technique described by Meszaros in 1996.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._diagonalExponents">
            <summary> [outerCol].  if not null, influences stable permutation order.
              A value of -128 indicates a zero diagonal.
              Other values are capped at -127..127 representing the binary exponent of the diagonal element.
              A 0 value (default) is thus for a diagonal value in the range 0.5 .. 1.0.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._maxColumnCount">
            <summary> The largest count of non-zeros in any column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._firstDenseColumn">
            <summary> If the matrix becomes dense we can switch algorithms for speed against space
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.OuterToInner">
            <summary> Permutation from user's column to internal column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.InnerToOuter">
            <summary> Permutation from internal colum to user's column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._symbolics">
            <summary> [ColumnCount] During symbolic phase, track symbolic work on columns and supernodes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._denseMaps">
            <summary> The most dense columns are tracked with a bit position in these maps.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._denseMapLock">
            <summary> Only one thread may extend the maps at a time
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._denseMapCount">
            <summary> The dense columns are tracked with a bit position in this map.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace._minDegrees">
            <summary> The Symbolics are sorted in minimum degree order from which the low become candidates
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Double[],Microsoft.SolverFoundation.Common.FactorizationParameters,System.Func{System.Boolean},System.Int32[],System.Int32)">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.Factorize">
            <summary>Computes the symbolic factorization, modifying M.
            </summary>
            <returns>Symbolic factorization information, including mapping from original to permuted columns.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.VerifyEquivalence(System.Int32,System.Int32)">
            <summary> Verify the equivalence of the fill pattern of two columns.
                      Up to now we used a hash in the weights, but that is subject
                      to false matches.  This is used to eliminate the false matches.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.TrueDegree(System.Int32)">
            <summary> The first published and still best static estimate of fill degree.
                      Markowitz degree is (colCount-1) * (rowCount-1) but in the case
                      of symmetric matrix we can use just (colCount-1) called "true degree".
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.EvaluateHandicap(System.Int32,System.Int32)">
            <summary> Calculate the fill weight to be attributed to a handicap
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFill(System.Int32,System.Byte[])">
            <summary> count the neighbor-fill it will cause
            </summary>
            <param name="col"> the index of the candidate </param>
            <param name="inUse">  map of rows used by current candidate </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillDeferred(System.Int32,Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillParallelizer,System.Int32)">
            <summary> count the neighbor-fill it will cause
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.MinDegree(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary> MinDegree calculates the keys used to order the minDegree sorted dictionary
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.UpdateMinDegree(System.Int32,System.Int32,System.Int32)">
            <summary> recalculate the external degree for otherCol after a col has been taken
            </summary>
            <param name="otherCol"> The column affected by taken columns </param>
            <param name="prior"> The prior count of indexes for otherSym </param>
            <param name="revised"> The new count of indexes for otherSym </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.ApplyFill(System.Int32,System.Int32,System.Boolean[],System.Int32[])">
            <summary> Calculate the coincidences and fill cost of a newColumn,
                      counting only fill to columns not yet taken.
            <remarks> The other column must not be a supernode </remarks>
            </summary>
            <returns> Number of fills caused </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.ApplyDeferredReduction(System.Int32)">
            <summary> Calculate the coincidences and fill cost of a newColumn,
                      counting only fill to columns not yet taken.
            <remarks> The other column must not be a supernode </remarks>
            </summary>
            <returns> Number of fills caused </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CreateSymbolics(System.Double[])">
            <summary> The symbolic arrays track the columns during minimum fill calculations
            </summary>
            <param name="colWeights"> fractional value per column, derived from hashing the non-zero pattern </param>
            <returns> the recommended ordering of _symbolics </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.TakeSym(System.Int32)">
            <summary> Change a symbol (and its supernode) to Taken status
            </summary>
            <returns> the symbol index of the candidate </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.PlanBestOrder">
            <summary> Permute the symbolics to choose an order with low fill.
            </summary>
            <returns> the recommended ordering of _symbolics </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.FinalizeNewOrder(System.Int32[],System.Int32[][]@,System.Boolean[]@)">
            <summary> Convert symbolics to a final order, expanding the supernodes
            </summary>
            <param name="takenOrder"> the order yielded by PlanBestOrder </param>
            <param name="columnIndexes"> the per-column vectors which will become the new compressed column matrix </param>
            <param name="isSupernodal"> a map of which columns are in supernodes </param>
            <returns> The list of column indexes, to be used for building the Cholesky </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.BuildCholeskyLayout(System.Int32[][],System.Boolean[])">
            <summary> The final reorg is to predict all the coeff locations for the Cholesky factor.
            <remarks> PlanBestOrder is a prerequisite </remarks>
            </summary>
            <param name="columnIndexes"> the per-column vectors which will become the new compressed column matrix </param>
            <param name="isSupernodal"> a map of which columns are in supernodes </param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.ColumnCount">
            <summary> Count of columns in the workspace
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn">
            <summary> SymbolicCount[ColumnCount] array is used for minimum fill work
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._indexCount">
            <summary> the number of entries used in _indexes.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._indexes">
            <summary> the row indexes current for this column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._superNode">
            <summary> List of outer columns belonging to supernode, represented by this one.
                      The others just ride along until placement then follow the same pattern.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._mapBit">
            <summary> The most dense columns are tracked with a bit map
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._lastTaken">
            <summary> Use the count of nodes taken to label when this node was last fill-calculated
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._fill">
            <summary> Exact nearest fill, -1 if not up to date.  Only small values are closely
                      inspected, for big values it means "we don't want this column yet", so
                      save space by using a float.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._stage">
            <summary> Each column may pass through stages while order is being calculated.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._handicap">
            <summary> A handicap is used to control stable pivot order.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicColumn._degree">
            <summary> 1 + _superNode.Length
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicStage">
            <summary> Each column may pass through stages while order is being calculated.
            <remarks>
                      Ordering is important:
                      - pending column states must be less than Candidate
                      - Candidate less than Taken
                      - Taken less than Super
            </remarks>
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicStage.Default">
            <summary> The initial stage for most columns
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicStage.Taken">
            <summary> A column for which final placement has been decided
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.SymbolicStage.Super">
            <summary> A column which is part of the supernodal set of some other column
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillParallelizer">
            <summary> A context object used to control symbolic factorization threads
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillParallelizer._deferredFill">
            <summary> Deferred fill calculations are multithreaded
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillParallelizer._prevDeferredFill">
            <summary> Variable used to coordinate multithreaded calculation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MinimizeLocalFillWorkspace.CalculateFillParallelizer.RunDeferred">
            <summary> Run deferred fill calculations
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixDouble">
            <summary> A column-compressed sparse matrix has the values in contiguous order.
                      The elements are NOT guaranteed non-zero: the sparse pattern may be
                      planned to accomodate possibly non-zero elements at some stage.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1">
            <summary> A column-compressed sparse matrix has the values in contiguous order.
                      The elements are NOT guaranteed non-zero: the sparse pattern may be
                      planned to accomodate possibly non-zero elements at some stage.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrix`1">
            <summary> General base generic class for a sparse matrix of numbers
            </summary>
            <typeparam name="Number"> a type which behaves as a number, like double or Rational </typeparam>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.Row(System.Int32)">
            <summary> abstract a row of the matrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.Column(System.Int32)">
            <summary> abstract a column of the matrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.Product(Microsoft.SolverFoundation.Common.SparseMatrixRow{`0},`0[])">
            <summary> x = M[row,j]·v[j]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.Product(`0[],Microsoft.SolverFoundation.Common.SparseMatrixColumn{`0})">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.Product(Microsoft.SolverFoundation.Common.SparseMatrix{`0})">
            <summary> A[,] = this[:,j]·M[j,:]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.SumProductRight(`0,`0[],`0,`0[])">
            <summary> y[] = a·THIS[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.SumProductRight(`0,Microsoft.SolverFoundation.Common.SparseMatrix{`0},`0[],`0,`0[])">
            <summary> y[] = a·M[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.SumLeftProduct(`0,`0[],`0,`0[])">
            <summary> y[] = a·x[i]·THIS[i,:] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.SumLeftProduct(`0,`0[],Microsoft.SolverFoundation.Common.SparseMatrix{`0},`0,`0[])">
            <summary> y[] = a·x[i]·M[i,:] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrix`1.VerifySquare">
            <summary> Throw an exception the matrix is not square.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrix`1.ColumnCount">
            <summary> The number of columns
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrix`1.RowCount">
            <summary> The number of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrix`1.Item(System.Int32,System.Int32)">
            <summary> Get or set a position in the matrix.
                      There may be restrictions on the order of setting contents.
            </summary>
            <param name="row"> 0 &lt;= row &lt; N </param>
            <param name="col"> 0 &lt;= col &lt; N </param>
            <returns> the element at [row, col] </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrix`1.Count">
            <summary> The (fast) count of potentially non-zero elements.
                      This is whatever least upper bound is cheap to compute.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1._columnStarts">
            <summary> The _n+1 position starts for values and indexes of a column.
                      The _n+1th start is the final count.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1._rowIndexes">
            <summary> An index matched to every value identifies the row.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1._values">
            <summary> The values for each column are in a packed sequence located
                      by the column start.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1._T">
            <summary> The transpose view of this
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.#ctor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary> Instantiate an empty ColumnCompressedSparseMatrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.#ctor(Microsoft.SolverFoundation.Common.TripleList{`0},System.Int32,System.Int32,System.Int32[],Microsoft.SolverFoundation.Common.TripleList{`0}.DuplicatePolicy)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.#ctor(Microsoft.SolverFoundation.Common.TripleList{`0},System.Int32,System.Int32,Microsoft.SolverFoundation.Common.TripleList{`0}.DuplicatePolicy)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.CountColumnSlots(System.Int32)">
            <summary> Count the NZ slots in the column
            </summary>
            <param name="col"> which column to count </param>
            <returns> number of slots for NZs </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],`0[])">
            <summary> Instantiate a pre-planned ColumnCompressedSparseMatrix with possibly null values
            </summary>
            <param name="nRow"> the number of rows </param>
            <param name="nCol"> the number of columns </param>
            <param name="starts"> the starting positions of columns </param>
            <param name="indexes"> the row indexes </param>
            <param name="values"> optional: the values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.#ctor(System.Int32,System.Int32)">
            <summary> Instantiate a blank ColumnCompressedSparseMatrix which will be
                      planned in detail.
            </summary>
            <param name="nRow"> the number of rows </param>
            <param name="nCol"> the number of columns </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIterator(System.Int32)">
            <summary> Create a RowIter based on the transpose indexes
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.Transpose">
            <summary> Instantiate the transpose of this matrix.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowCounts">
            <summary> Tabulate a count of elements for each row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ToString">
            <summary> Represent the matrix as a string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ToStringByRow">
            <summary> Represent the matrix as a string
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.Count">
            <summary> The count of possibly non-zero elements.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter">
            <summary> A ColIter iterates the specified column for rows which have non-zeros,
                      and also the values in those locations.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0},System.Int32)">
            <summary> Creates a new iterator for the specified column.
            </summary>
            <param name="matrix">The matrix whose column is iterated.</param>
            <param name="column">The column to iterate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0},System.Int32,System.Int32)">
            <summary> Creates a new iterator for the specified column starting at a given row.
            </summary>
            <param name="matrix">The matrix whose column is iterated.</param>
            <param name="column">The column to iterate.</param>
            <param name="fromRow"> The row at which we start. </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.Advance">
            <summary> Move the iterator to the next slot.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.Row(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0})">
            <summary> Return the row index for the current slot in this column.
            </summary>
            <param name="matrix"> The matrix containing the column </param>
            <returns> The row index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.Value(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0})">
            <summary> Return the numeric value for the current row in this column.
            </summary>
            <param name="matrix"> The matrix containing the column </param>
            <returns> The numeric value in the corrent row </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.IsValid">
            <summary> Is the iterator positioned at a valid slot?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ColIter.Slot">
            <summary> Report the slot currently under the iterator.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIter">
            <summary> A RowIter iterates the transposed index to give columns
                      which have non-zeros in the specified row.  It does NOT
                      iterate values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIter.#ctor(Microsoft.SolverFoundation.Common.SparseTransposeIndexes{`0},System.Int32)">
            <summary> Creates a new iterator for the specified row of a transpose index.
            </summary>
            <param name="matrixT">The matrix transpose index in which the row is iterated.</param>
            <param name="row">The row to iterate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIter.Advance">
            <summary> Move the iterator to the next slot.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIter.Column(Microsoft.SolverFoundation.Common.SparseTransposeIndexes{`0})">
            <summary> Return the column index for the current slot in this row.
            </summary>
            <param name="matrixT"> The matrix transpose containing the row </param>
            <returns> The column index </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowIter.IsValid">
            <summary> Is the iterator positioned at a valid slot?
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowSlots">
            <summary> A RowSlots structure is used in conjunction with transposed indexes
                      and RowIter to sweep once through the matrix values in row order.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowSlots.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0})">
             <summary> Creates a new vector of slot positions ready to comb down the matrix.
                       It works only for a complete sweep starting from the first row, and
                       should be discarded when finished.
             </summary>
             <param name="matrix"> The matrix in which rows will be iterated </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowSlots.IsValid(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0},System.Int32)">
            <summary> Is the iterator positioned at a valid slot?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.RowSlots.ValueAdvance(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0},System.Int32,System.Int32)">
            <summary> Move the iterator to the next slot.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ProductParallelizer">
            <summary> A context object used to control symbolic factorization threads
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixByColumn`1.ProductDiagonalParallelizer">
            <summary> A context object used to control symbolic factorization threads
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixDouble._ratioEpsilon">
            <summary> 1/2^36 (~ 1/6e10)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseMatrixDouble._zeroEpsilon">
            <summary> 1/2^40 (~ 1/1e12)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary> Instantiate an empty SparseMatrixDouble
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32,System.Int32,System.Int32[],Microsoft.SolverFoundation.Common.TripleList{System.Double}.DuplicatePolicy)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32,System.Int32)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32,System.Int32,Microsoft.SolverFoundation.Common.TripleList{System.Double}.DuplicatePolicy)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Double[])">
            <summary> Instantiate a pre-planned SparseMatrixDouble with possibly null values
            </summary>
            <param name="nRow"> the number of rows </param>
            <param name="nCol"> the number of columns </param>
            <param name="starts"> the starting positions of columns </param>
            <param name="indexes"> the row indexes </param>
            <param name="values"> optional: the values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(System.Int32,System.Int32)">
            <summary> Instantiate a pre-planned SparseMatrixDouble.
            </summary>
            <param name="nRow"> the number of rows </param>
            <param name="nCol"> the number of columns </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary> Instantiate a pre-planned SparseMatrixDouble.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.DiagonalExponents">
            <summary> Scan the diagonal and get the binary exponents limited to 0..255.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.AllRowsInColumn(System.Int32)">
            <summary> Enumerate all the rows, above and below the diagonal.
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.AllValuesInColumn(System.Int32)">
            <summary> Enumerate all non-zero values, above and below the diagonal.
            </summary>
            <param name="col"></param>
            <returns> pairs of row,value for the non-zeros </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(Microsoft.SolverFoundation.Common.SparseMatrixRow{System.Double},System.Double[])">
            <summary> x = M[row,j]·v[j]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(System.Double[],Microsoft.SolverFoundation.Common.SparseMatrixColumn{System.Double})">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.SparseMatrixColumn{System.Double})">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(System.Double[],System.Int32,Microsoft.SolverFoundation.Common.SparseMatrixColumn{System.Double})">
            <summary> x = v[vStart + i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.ProductThread(System.Object)">
            <summary> A[,] = this[:,j]·M[j,:].  Sliced every n'th column, n == threadCount
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.CollectProductThreads(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double}.ProductParallelizer,System.Int32)">
            <summary> A[,] = this[:,j]·M[j,:].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(Microsoft.SolverFoundation.Common.SparseMatrixDouble)">
            <summary> A[,] = this[:,j]·M[j,:].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.FusedProductTransposeThread(System.Object)">
            <summary> A[,] = this[:,j]·this[j,:].  Sliced every n'th column, n == threadCount
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.FusedProductTranspose">
            <summary> result[,] = this[:,j]·this[j,:].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.FusedProductDiagonalTransposeThread(System.Object)">
            <summary> A[,] = this[:,j]·diagonal[j,j]·this[j,:].  Sliced every n'th column, n == threadCount
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.FusedADAtProduct(System.Double[])">
            <summary> result[,] = this[:,j]·D[j,j]·this[j,:].
            </summary>
            <param name="D"> Diagonal matrix, represented by a vector </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Product(Microsoft.SolverFoundation.Common.SparseMatrix{System.Double})">
            <summary> A[,] = this[:,j]·M[j,:].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.op_Multiply(Microsoft.SolverFoundation.Common.SparseMatrixDouble,Microsoft.SolverFoundation.Common.SparseMatrixDouble)">
            <summary> A[,] = M[:,j]·N[j,:]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.SumProductRight(System.Double,System.Double[],System.Double,System.Double[])">
            <summary> y[] = a·THIS[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.SumProductRight(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> y[] = a·THIS[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.op_Multiply(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Double[])">
            <summary> y[] = M[,:] * x[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.SumLeftProduct(System.Double,System.Double[],System.Double,System.Double[])">
            <summary> y[] = a·x[i]·THIS[i,:] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.SumLeftProduct(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = a·x[i]·THIS[i,:] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.IsSymmetric">
            <summary> Check if the matrix is symmetric
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.MaximumDifference(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double})">
            <summary> Report the maximum absolute value of element differences
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.EqualTo(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Double)">
            <summary> Check if the matrix is equal to within the specified tolerance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.EqualTo(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double})">
            <summary> Check if the matrix is equal, with the default tolerance 2^-40
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixDouble.EqualTo(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Int32[])">
            <summary> Check if the matrix is same as an unpermuted version
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SparseMatrixDouble.Item(System.Int32,System.Int32)">
            <summary> Get (do not set) a position in the matrix.
            </summary>
            <param name="row"> 0 &lt;= row &lt; RowCount </param>
            <param name="col"> 0 &lt;= col &lt; ColumnCount </param>
            <returns> the element at [row, col] </returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.LowerSparseMatrix">
            <summary> A column-compressed lower-triangular matrix (must be square).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary> Instantiate an empty LowerSparseMatrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.Identity(System.Int32)">
            <summary> Instantiate an identity matrix size rowColumnCount (square)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32)">
            <summary> Instantiate from a set of triples
            </summary>
            <param name="Ts"></param>
            <param name="N"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.#ctor(System.Int32,System.Int32[],System.Int32[],System.Double[])">
            <summary> Instantiate a pre-planned ColumnCompressedSparseMatrix.
            </summary>
            <param name="N"> the number of columns and rows </param>
            <param name="starts"> the starting positions of columns </param>
            <param name="indexes"> the row indexes </param>
            <param name="values"> optional: the values </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.#ctor(System.Int32)">
            <summary> Instantiate a pre-planned ColumnCompressedSparseMatrix.
            </summary>
            <param name="N"> the number of columns and rows </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.IsSymmetric">
            <summary> Check if the matrix is symmetric
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LowerSparseMatrix.Product(Microsoft.SolverFoundation.Common.LowerSparseMatrix,Microsoft.SolverFoundation.Common.LowerSparseMatrix)">
            <summary> this = A * B
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.UpperSparseMatrix">
            <summary> A column-compressed upper-triangular matrix (must be square).
                      Note this is not simply a reflection of the lower
                      triangle, since we remain column-compressed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UpperSparseMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary> Instantiate an empty UpperSparseMatrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UpperSparseMatrix.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32)">
            <summary> Instantiate from a set of triples
            </summary>
            <param name="Ts"> (row, col, value) triples </param>
            <param name="N"> count of columns (= rows) </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UpperSparseMatrix.IsSymmetric">
            <summary> Check if the matrix is symmetric
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UpperSparseMatrix.Product(Microsoft.SolverFoundation.Common.UpperSparseMatrix,Microsoft.SolverFoundation.Common.UpperSparseMatrix)">
            <summary> this = A * B
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix">
            <summary> A compact representation of a symmetric matrix.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.#ctor(System.Int32,System.Int32,System.Double)">
            <summary> Instantiate an empty SymmetricSparseMatrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.#ctor(System.Int32,System.Int32[],System.Int32[],System.Double[])">
            <summary> Instantiate an empty SymmetricSparseMatrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.#ctor(Microsoft.SolverFoundation.Common.TripleList{System.Double},System.Int32)">
            <summary> Instantiate from a set of triples
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.AllRowsInColumn(System.Int32)">
            <summary> Enumerate all the rows, above and below the diagonal.
            </summary>
            <param name="col"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.AllValuesInColumn(System.Int32)">
            <summary> Enumerate all non-zero values, above and below the diagonal.
            </summary>
            <param name="col"></param>
            <returns> pairs of row,value for the non-zeros </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.IsSymmetric">
            <summary> Check if the matrix is symmetric
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.EqualTo(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Double)">
            <summary> Check if the matrix is equal to within the specified tolerance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.EqualTo(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{System.Double},System.Int32[])">
            <summary> Check if the matrix is same as an unpermuted version
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.Product(System.Double[],Microsoft.SolverFoundation.Common.SparseMatrixColumn{System.Double})">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.Product(Microsoft.SolverFoundation.Common.SparseMatrix{System.Double})">
            <summary> A[,] = this[:,j]·M[j,:].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.Product(Microsoft.SolverFoundation.Common.SparseMatrixRow{System.Double},System.Double[])">
            <summary> x = M[row,j]·v[j]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.SumLeftProduct(System.Double,System.Double[],System.Double,System.Double[])">
            <summary> y[] = a·x[i]·THIS[i,:] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.SumProductRight(System.Double,System.Double[],System.Double,System.Double[])">
            <summary> y[] = a·THIS[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.SumProductRight(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector)">
            <summary> y[] = a·THIS[:,j]·x[j] + b·y[]
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricSparseMatrix.Item(System.Int32,System.Int32)">
            <summary> Access the value at [row, col]
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.AlgebraContext">
            <summary> Various global parameters driving Algebra algorithms
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.AlgebraContext._threadCountLimit">
            <summary> Policy limit regardless of physical limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.AlgebraContext.ThreadCountLimit">
            <summary> The ThreadCountLimit is the policy limit on threading.  It cannot
                      be set outside the range (1 .. System.Environment.ProcessorCount).
                      Values set will be silently bounded at those limits.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.AlgebraContext.PathName">
            <summary> This has been used as a debug feature to track the origin of
                      test sets such as .MPS files currently using the AlgebraContext
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Triple`1">
            <summary> Each triple represents the value at a row and column of the array.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Triple`1.Row">
            <summary> The row of the array for this value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Triple`1.Column">
            <summary> The column of the array for this value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Triple`1.Value">
            <summary> The value sited at this row, column position
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Triple`1.#ctor(System.Int32,System.Int32,`0)">
            <summary> Each triple represents the value at a row and column of the array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Triple`1.CompareTo(Microsoft.SolverFoundation.Common.Triple{`0})">
            <summary> The default comparison for IComparable&lt;>.  Only the row,column are used.
                      The value is not considered: the comparison is for the purpose of structure.
            </summary>
            <param name="b"> The other triple for which row and column are to be compared </param>
            <returns> negative, zero, or positive if this row,column is compared to b's row,column </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Triple`1.ToString">
            <summary> Formatted comma separated row, column, value
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TripleList`1">
            <summary> Triples are an exchange format for moving sparse arrays.
                      They are also a convenient buffer format for non-ordered
                      accumulation of array elements.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TripleList`1.#ctor">
            <summary> A list of {row, column, value} triples specify array contents
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TripleList`1.Add(System.Int32,System.Int32,`0)">
            <summary> Convenient form of Add which constructs the Triple
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TripleList`1.SortUnique(Microsoft.SolverFoundation.Common.TripleList{`0}.DuplicatePolicy)">
            <summary> Sort the list and handle duplicates
            </summary>
            <param name="duplicate">Policy for handling duplicates - null means use the first.</param>
            <returns> the count of remaining unique values </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TripleList`1.ToString">
            <summary> Represent a Triple&lt;> as a string
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TripleList`1.DuplicatePolicy">
            <summary> What to do when duplicate Triples are encountered.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.AccumulateUnique`1">
            <summary> This class allows accumulation of a predictably bounded
                      count of unique values from an unpredictable and likely
                      much longer sequence of values in unknown order.
            </summary>
            <typeparam name="T"> the type of values to be accumulated </typeparam>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AccumulateUnique`1.#ctor(System.Int32)">
            <summary> A bounded array of unique values to be filterred out
                      of an unbounded, unordered sequence.
            </summary>
            <param name="capacity"> At least the maximum count of unique values ever possible </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AccumulateUnique`1.Count">
            <summary> Return a count of the unique values.
            </summary>
            <returns> a count of the distinct values </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AccumulateUnique`1.Add(`0)">
            <summary> Add another value to the accumulation
            </summary>
            <param name="val"> A value to be considered </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.AccumulateUnique`1.Clear">
            <summary> Remove all contents.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.AccumulateUnique`1.Item(System.Int32)">
            <summary> Indexed access to the accumulation.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixRow`1">
            <summary> An abstraction for a row of the matrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixRow`1.Product(`0[])">
            <summary> x = M[row,j]·v[j]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixRow`1.op_Multiply(Microsoft.SolverFoundation.Common.SparseMatrixRow{`0},`0[])">
            <summary> x = M[row,j]·v[j]
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseMatrixColumn`1">
            <summary> An abstraction for a column of the matrix
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixColumn`1.Product(`0[])">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseMatrixColumn`1.op_Multiply(`0[],Microsoft.SolverFoundation.Common.SparseMatrixColumn{`0})">
            <summary> x = v[i]·M[i,column]
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseTransposeIndexes`1">
            <summary> Indexes for row-by-row structure of a column-compressed matrix
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseTransposeIndexes`1._rowStarts">
            <summary> Starts of the compressed row indexes for the transpose view of A
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseTransposeIndexes`1._colIndexes">
            <summary> Compressed row indexes for the transpose view of A
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseTransposeIndexes`1.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixByColumn{`0},System.Int32[])">
            <summary> We will use the transpose indexes of the A matrix for faster multiplication.
            </summary>
            <param name="A"> The matrix on which to build transpose indexes </param>
            <param name="rowCounts"> a count of the number of non-zeroes in each row </param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymbolicFactorResult">
            <summary> Symbolic factorization information, including mapping from original to permuted columns.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorResult.InnerToOuter">
            <summary> Permutation from internal colum to user's column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorResult.OuterToInner">
            <summary> Permutation from user's column to internal column
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorResult.FirstDenseColumn">
            <summary> The first dense column (exploited by Cholesky).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorResult.MaxColumnCount">
            <summary> The maximum number of nonzeros in any column.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.FactorizationParameters">
            <summary>Factorization parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.FactorizationParameters.DenseWindowThreshhold">
            <summary>
            If the matrix becomes dense we can switch algorithms in some places for more speed,
               a tradeoff against space.  This portion of the matrix is the "dense window".
               The start of the dense window is the first column that has at least this
               percentage of nonzeroes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.FactorizationParameters.FactorizationMethod">
            <summary>Factorization method.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.FactorizationParameters.AllowNormal">
            <summary>Factorization method.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SparseVectorCell">
            <summary> a (row, value) pair used to build sparse vectors
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseVectorCell.Index">
            <summary> the position of a value in the vector
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SparseVectorCell.Value">
            <summary> a value in a vector
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseVectorCell.#ctor(System.Int32,System.Double)">
            <summary> a (row, value) pair used to build sparse vectors
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SparseVectorCell.ToString">
            <summary> A formatted string for this
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymbolicFactorizationMethod">
            <summary>Symbolic factorization method.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorizationMethod.Automatic">
            <summary> System chooses.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorizationMethod.LocalFill">
            <summary> Minimize local fill.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymbolicFactorizationMethod.AMD">
            <summary> Approximate minimum degree.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor">
            <summary> Factorizes and solves symmetric indefinite sparse systems.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor._zeroPivotTolerance">
            <summary>Diagonal values smaller than this value are handled specially.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Func{System.Boolean},Microsoft.SolverFoundation.Common.FactorizationParameters)">
            <summary>Create a new instance.
            </summary>
            <param name="M">The coefficient matrix.</param>
            <param name="CheckAbort">CheckAbort.</param>
            <param name="factorParam">Factorization parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.ZeroPivotRepair(System.Int32,System.Double,System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Cause a zero pivot's row and column to be ignored.
            </summary>
            <returns> throw a DivideByZeroException </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.Solve(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Solves the linear system without iterative refinement.
            </summary>
            <param name="rhs">The righthand side.</param>
            <returns>The solution vector.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.Solve(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary> Solves the linear system without iterative refinement.
            </summary>
            <param name="rhs">The righthand side.</param>
            <param name="solution">The preallocated solution vector.</param>
            <param name="maxIR">The maximum number of iterative refinements (currently ignored)</param>
            <returns>The number of iterative refinements performed (currently zero).</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.Fill">
            <summary>Fill the coefficient matrix in preparation for a solve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SymmetricIndefiniteFactor.ZeroPivots">
            <summary>Number of zero pivots encountered during factorization.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Vector">
            <summary> A wrapper for double[] which implements algebraic operators.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.#ctor(System.Int32)">
            <summary> Construct an empty vector of specified length
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.#ctor(System.Double[])">
            <summary> Construct a vector with the specified values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.#ctor(System.Double[],System.Int32)">
            <summary> Construct a vector with the specified values and start index.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.#ctor(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary> Construct a vector with the specified values and start index.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ToString">
            <summary> format values as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.VerifySameLength(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Throw an exeption if the length of the vectors are not the same
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.VerifyMinimumLength(System.Int32)">
            <summary> Throw an exeption if length of the vector is too small.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.VerifyNonZeroLength">
            <summary> Throw an exception if length of vector is 0.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ZeroFill">
            <summary> x[] = 0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Max">
            <summary> Return maximum value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Min">
            <summary> Return minimum value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.BigInnerProduct(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Inner product as a BigSum.
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Sum">
            <summary> return sum of all values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.BigSum">
            <summary> return sum of all values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.IsNullOrEmpty(Microsoft.SolverFoundation.Common.Vector)">
            <summary>Determines if a vector is null or length 0.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Add(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = x[] + y[] -- pairwize
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Subtract(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = x[] - y[] -- pairwize
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ElementMultiply(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = x[] * y[] -- (z is preallocated) pairwise
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ElementDivide(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z[] = x[] / y[] -- (z is preallocated) pairwise
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Daxpy(System.Double,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> y[] += (alpha * x[]) 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ScaledSum(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> z = (alpha * x) + (beta * y)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Add(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] += y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Subtract(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] -= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ElementMultiply(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] *= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ElementDivide(Microsoft.SolverFoundation.Common.Vector)">
            <summary> v[] /= y[]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ToArray">
            <summary> The contents of the vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Norm2">
            <summary> a = 2-norm of vector x.
            </summary>
            <returns> Euclidean norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.NormInf">
            <summary> a = Infinity-norm of vector x.
            </summary>
            <returns> Infinity-norm of vector x </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ConstantFill(System.Double)">
            <summary> v[] = c
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.AddConstant(System.Double)">
            <summary> v[] += y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ScaleBy(System.Double)">
            <summary> v[] *= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Over(System.Double)">
            <summary> v[] /= y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.ElementInvert(Microsoft.SolverFoundation.Common.Vector)">
            <summary> y[] = 1 / x[] -- pairwise
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.InnerProduct(Microsoft.SolverFoundation.Common.Vector)">
            <summary> z = x[]·y[] 
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Pivot(System.Int32[])">
            <summary>Swap entries according to the specified pivot vector.
            </summary>
            <param name="pivot">Entry i will be swapped with pivot[i].  pivot is NOT a permutation.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Permute(System.Int32[])">
            <summary> Permute from v[i] to v[fromTo[i]]
            </summary>
            <param name="fromTo"> the fromTo[] vector is an exact 1:1 pairing </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Copy">
            <summary> Construct a new Vector as a copy of this
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.CopyFrom(Microsoft.SolverFoundation.Common.Vector)">
            <summary> Copy values from another vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Copy(Microsoft.SolverFoundation.Common.Vector,System.Int32,Microsoft.SolverFoundation.Common.Vector,System.Int32,System.Int32)">
            <summary> Copy values from another vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Vector.Split(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> [ x[]; y[] ] = this  -- split vector into x and y (pre-allocated memory)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Vector.Start">
            <summary>The start index (usually 0).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Vector.Item(System.Int32)">
            <summary> Element accessor for the vector.
            </summary>
            <remarks>If performance is a concern, directly access the array using V and Start.</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Vector.Length">
            <summary> The length of the vector.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SubVector">
            <summary> A continuous section of a Vector.
            </summary>
            <remarks>For some operations it may be slightly more efficient to use a Vector.  The advantage 
            of working with SubVector is that no memory is allocated.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SubVector.#ctor(Microsoft.SolverFoundation.Common.Vector,System.Int32,System.Int32)">
            <summary>Create a new instance from a Vector.
            </summary>
            <param name="vector">The vector.</param>
            <param name="start">The first index from the Vector.</param>
            <param name="count">The number of elements in the SubVector.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SubVector.ToArray">
            <summary> The contents of the vector.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.SubVector.Length">
            <summary> The length of the vector.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.BigSum">
            <summary> BigSum is designed to add/subdract doubles with better cancellations.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.IBufList`1">
            <summary>
            Supports incremental access and direct access.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IBufList`1.TryGet(System.Int32,`0@)">
            <summary>
            Trys to fetch the item at index i. Returns false if i is too large.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.IBufList`1.Item(System.Int32)">
            <summary>
            Fetch the item at index i. Throw if i is too large.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.IBufList`1.LowerCount">
            <summary>
            A lower bound on the count. Indices less than this are guaranteed
            to be valid.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.BufList`1">
            <summary>
            Buffers items of type T from an IEnumerator.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.NoBufList`1">
            <summary>
            This is a forward only buffer
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InfeasibleModelException">
            <summary> The model given has been found to contain a construction error.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InfeasibleModelException.#ctor">
            <summary>
            Create the default InfeasibleModelException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InfeasibleModelException.#ctor(System.String)">
            <summary>
            Create the InfeasibleModelException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InfeasibleModelException.#ctor(System.String,System.Exception)">
            <summary>
            Create the InfeasibleModelException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InfeasibleModelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.ModelException">
            <summary> The model given has been found to contain a construction error.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelException.#ctor">
            <summary>
            Create the default ModelException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelException.#ctor(System.String)">
            <summary>
            Create the ModelException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelException.#ctor(System.String,System.Exception)">
            <summary>
            Create the ModelException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.EmptyModelException">
            <summary> The model given has been found to contain a construction error.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.EmptyModelException.#ctor">
            <summary>
            Create the default EmptyModelException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.EmptyModelException.#ctor(System.String)">
            <summary>
            Create the EmptyModelException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.EmptyModelException.#ctor(System.String,System.Exception)">
            <summary>
            Create the EmptyModelException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.EmptyModelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">
            <summary> The data given has been found to be invalid for the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidModelDataException.#ctor">
            <summary>
            Create the default InvalidModelDataException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidModelDataException.#ctor(System.String)">
            <summary>
            Create the InvalidModelDataException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidModelDataException.#ctor(System.String,System.Exception)">
            <summary>
            Create the InvalidModelDataException instance with given string message and an inner exception instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidModelDataException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TimeLimitReachedException">
            <summary>
            Time limit has reached or user has asked to Abort
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TimeLimitReachedException.#ctor">
            <summary>
            Create the default TimeLimitReachedModelException instance with message defined in Resources.Aborted
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TimeLimitReachedException.#ctor(System.String)">
            <summary>
            Create the TimeLimitReachedException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TimeLimitReachedException.#ctor(System.String,System.Exception)">
            <summary>
            Create the TimeLimitReachedException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TimeLimitReachedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.ModelTooLargeException">
            <summary>
            Time limit has reached or user has asked to Abort
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelTooLargeException.#ctor">
            <summary>
            Create the default ModelTooLargeException instance with message defined in Resources.ModelTooLarge
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelTooLargeException.#ctor(System.String)">
            <summary>
            Create the ModelTooLargeException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelTooLargeException.#ctor(System.String,System.Exception)">
            <summary>
            Create the ModelTooLargeException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ModelTooLargeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InvalidTermException">
            <summary>
            Indicates that a term of the model could not be represented for a specific solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidTermException.#ctor">
            <summary>
            Create the default InvalidTermException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidTermException.#ctor(System.String)">
            <summary>
            Create the InvalidTermException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidTermException.#ctor(System.String,System.Exception)">
            <summary>
            Create the InvalidTermException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidTermException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.InvalidTermException.ErrorTerm">
            <summary>
            The term that caused the error.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.UnsolvableModelException">
            <summary>
            This exception type indicates that no solver was found to solve a model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UnsolvableModelException.#ctor">
            <summary>
            Create the default UnsolvableModelException instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UnsolvableModelException.#ctor(System.String)">
            <summary>
            Create the UnsolvableModelException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UnsolvableModelException.#ctor(System.String,System.Exception)">
            <summary>
            Create the UnsolvableModelException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.UnsolvableModelException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.UnsolvableModelException.InnerExceptions">
            <summary>
            An array of exceptions thrown from individual solvers.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MsfLicenseException">
            <summary>
            Indicates that the model is too large for this edition of Microsoft Solver Foundation.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfLicenseException.#ctor">
            <summary>
            Create the default MsfLicenseException instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfLicenseException.#ctor(System.String)">
            <summary>
            Create the MsfLicenseException instance with the given message string.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfLicenseException.#ctor(System.String,System.Exception)">
            <summary>
            Create the MsfLicenseException instance with the given message string and inner exception.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfLicenseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">
            <summary>Indicates that an invalid property name was specified in an event handler.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor">
            <summary>
            Create the default instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor(System.String)">
            <summary>
            Create the default instance with the specified message.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor(System.String,Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason)">
            <summary>
            Create the InvalidSolverPropertyException instance with the given message string.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor(System.String,System.Exception)">
            <summary>
            Create the InvalidSolverPropertyException instance with the given message string and inner exception.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor(System.String,System.Exception,Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason)">
            <summary>
            Create the InvalidSolverPropertyException instance with the given message string and inner exception.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException.Reason">
            <summary>The reason why the property is invalid.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason">
            <summary>
            Possible reasons for InvalidSolverPropertyException.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason.SolverDoesNotSupportEvents">
            <summary>
            This solver don't support event handling at all
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason.EventDoesNotSupportSetProperty">
            <summary>
            While solving, this solver does not support setting operation
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason.InvalidPropertyName">
            <summary>
            The specific property is not supported by this solver
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.InvalidSolverPropertyReason.EventDoesNotSupportProperty">
            <summary>
            This property cannot be used with the current event
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.OmlParseExceptionReason">
            <summary>Possible reasons for OmlParseException.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.NotSpecified">
            <summary>Unspecified reason.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.DuplicateName">
            <summary>Duplicate name.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.ExpressionCannotBeConvertedIntoTerm">
            <summary>The expression could not be converted into a term.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidAnnotation">
            <summary>Invalid annotation.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidArgumentCount">
            <summary>The wrong number of arguments was provided to an operator.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidArgumentType">
            <summary>The argument type is invalid or does not match.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidDataBinding">
            <summary>Invalid data binding.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidDecision">
            <summary>Invalid decision.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidDomain">
            <summary>Invalid domain specification.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidFilterCondition">
            <summary>Invalid condition in a Foreach or ForeachWhere.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidGoal">
            <summary>Invalid goal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidName">
            <summary>An invalid identifier was specified.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidIterator">
            <summary>Invalid iterator expression.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidIndex">
            <summary>Invalid index.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidIndexCount">
            <summary>Invalid index count.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidLabel">
            <summary>An invalid label was specified.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidParameter">
            <summary>Invalid parameter.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidSos">
            <summary>Invalid SOS.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidSet">
            <summary>Invalid set.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.InvalidTuples">
            <summary>Invalid tuples specification.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.SubmodelError">
            <summary>Am element in a submodel section is invalid.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.OmlParseExceptionReason.UnexpectedTerm">
            <summary>An unexpected term was encountered.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation">
            <summary>Information about the location of OML parse errors.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation.ToString">
            <summary>Returns a string representation of the instance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation.LineStart">
            <summary>The line number where the parse error begins.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation.ColumnStart">
            <summary>The column number where the parse error begins.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation.LineEnd">
            <summary>The line number where the parse error ends.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseExceptionLocation.ColumnEnd">
            <summary>The column number where the parse error ends.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.OmlParseException">
            <summary>An exception that is thrown when an OML model has invalid syntax.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.OmlParseException.#ctor(System.String)">
            <summary>Create a new instance with the specified message.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.OmlParseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor to support serialization.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseException.Location">
            <summary>Information about where the error occurs.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.OmlParseException.Reason">
            <summary>Information about the reason for the exception.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.MsfFatalException">
            <summary>
            Indicates that Microsoft Solver Foundation encountered a fatal error.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfFatalException.#ctor">
            <summary>
            Create the default MsfFatalException instance with message defined in Resources.FatalError
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfFatalException.#ctor(System.String)">
            <summary>
            Create the MsfFatalException instance with the given message string
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfFatalException.#ctor(System.String,System.Exception)">
            <summary>
            Create the MsfFatalException instance with the given message string and inner exception
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.MsfFatalException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> Construct exception during serialization 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.InfeasibleException">
            <summary> The problem seems to have no solution within bounds.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.InfeasibleException.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SimplexThreadAbortException">
            <summary> A worker thread has had to terminate.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.CompactQuasiNewtonException">
            <summary>
            Internal exception that is thrown whenever CQN terminates without an optimal result.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.CompactQuasiNewtonException.#ctor(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType)">
            <summary>
            Initiate exception with enum for the type of error
            </summary>
            <param name="error">which error occured</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.HashTable`1">
            <summary>
            Not for the faint of heart.
            A hash table that doesn't actually store the key. This requires callers to provide
            a comparison delegate and hash value. GetHashCode is never called.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.HashTable`1.Get``1(``0,System.UInt32,System.Func{``0,`0,System.Boolean},`0@)">
            <summary>
            Look for the item. Calls back on the comparison function to determine
            a match.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.HashTable`1.Add(System.UInt32,`0)">
            <summary>
            Adds the item. Does NOT check for whether the item is already present.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.HashTable`1.GrowTable">
            <summary>
            This is called when the average depth is 2. It then quadruples the number
            of buckets, reducing the average depth to 1/2.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Heap`1">
            <summary>
            Implements a heap - for implementing priority queues.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.#ctor(System.Func{`0,`0,System.Boolean})">
            <summary> A Heap structure gives efficient access to the ordered next element.
            </summary>
            <param name="fnReverse"> tests true if first element should be after the second </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.#ctor(System.Func{`0,`0,System.Boolean},System.Int32)">
            <summary> A Heap structure gives efficient access to the ordered next element.
            </summary>
            <param name="fnReverse"> tests true if first element should be after the second </param>
            <param name="capacity"> the maximum capacity of the heap </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.Clear">
            <summary> Discard all elements currently in the heap
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.Pop">
            <summary> Remove and return the first element in the heap
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.Add(`0)">
            <summary> Add a new element to the heap
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Heap`1.ToArrayUnsorted">
            <summary> Returns all the current elements of the heap in
                      an array, with no guaranteed order.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Heap`1.FnReverse">
            <summary> Func tests true if first element should be after the second
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Heap`1.Count">
            <summary> Current count of elements remaining in the heap
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Heap`1.Top">
            <summary> Peek at the first element in the heap
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.IndexedHeap">
            <summary>
            Implements a heap of integers that is indexed, to track whether a value
            is in the heap.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.ILogSource">
            <summary>
            Specifies the methods that a class doing logging should implement.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ILogSource.AddListener(System.Diagnostics.TraceListener,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Adds a listener to the list of listeners. The listener will receive log messages that have the correct mask.
            </summary>
            <remarks>
            If the listener is already in the list of listeners, the mask is updated.
            If the mask is empty, the listener is removed from the list of listeners. This is equivalent to calling RemoveListener.
            </remarks>
            <param name="listener"></param>
            <param name="ids"></param>
            <returns>True if the listener is added to the list of listeners; false if the listener is already in the list.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ILogSource.RemoveListener(System.Diagnostics.TraceListener)">
            <summary>
            Removes a listener from the list of listeners.
            </summary>
            <remarks>
            Removing a listener that has not been added has no effect.
            </remarks>
            <param name="listener"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Lexer">
            <summary>
            The lexer. This is effectively a template. Call LexSource to get an Enumerable of tokens.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.VerbatimLiteralExpected">
            <summary> VerbatimLiteralExpected
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.IntOverflow">
            <summary> ErrObj IntOverflow
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.FloatOverflow">
            <summary> ErrObj FloatOverflow
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.UnterminatedString">
            <summary> ErrObj UnterminatedString
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.NewlineInConst">
            <summary> ErrObj NewlineInConst
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.CharConstEmpty">
            <summary> ErrObj CharConstEmpty
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.CharConstTooLong">
            <summary> ErrObj CharConstTooLong
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.BadEscape">
            <summary> ErrObj BadEscape
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.BadChar">
            <summary> ErrObj BadChar
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.Lexer.UnterminatedComment">
            <summary> UnterminatedComment
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.#ctor(Microsoft.SolverFoundation.Common.NormStr.Pool)">
            <summary> The constructor. Caller must provide the name pool and key word table.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.GetDecVal(System.Char)">
            <summary>
            Get the value of a decimal digit.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.GetHexVal(System.Char)">
            <summary>
            Get the value of a hexadecimal digit.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.GetUniEscape(System.UInt32)">
            <summary>
            Convert the given uint to a unicode escape.
            Note that the uint contains raw hex - not a surrogate pair.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.ChNext">
            <summary>
            Advance to the next character and return it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.ChPeek(System.Int32)">
            <summary>
            Return the ich character without advancing the current position. Assumes (and asserts) that
            the buffer is large enough for everything from the current character to the peeked character.
            This model doesn't support unbounded look ahead.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.StartTok">
            <summary>
            Marks the beginning of the current token.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.ReportError(Microsoft.SolverFoundation.Common.ErrObj)">
            <summary>
            Called to embed an error token in the stream.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.GetNextToken">
            <summary>
            Form and return the next token. Returns null to signal end of input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.GetEof">
            <summary>
            Call once GetNextToken returns null if you need an Eof token.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.FetchTokens">
            <summary>
            Form and enqueue the next token and associated tokens (errors and newlines).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexPunc">
            <summary>
            Called to lex a punctuator.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexNumLit">
            <summary>
            Called to lex a numeric literal or a Dot token.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexHexInt">
            <summary>
            Lex a hex literal optionally followed by an integer suffix. Asserts the current
            character is a hex digit.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexDecInt(Microsoft.SolverFoundation.Common.IntLitKind)">
            <summary>
            Lex a decimal integer literal. The digits must be in _sb.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexFloatNum(Microsoft.SolverFoundation.Common.BigInteger,System.Char,System.Boolean)">
            <summary>
            Lex a real literal (eg, float, double or decimal). The characters should be in _sb.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexIntSuffix">
            <summary>
            Lex an optional integer suffix (eg, U or L).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexFloatSuffix">
            <summary>
            Lex an optional real suffix (eg, F, D, M).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexStrLit">
            <summary>
            Lex a string or character literal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.FLexEscChar(System.Boolean,System.UInt32@)">
            <summary>
            Lex a character escape. Returns true if successful (ch is valid).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.ConvertToSurrogatePair(System.UInt32,System.Char@,System.Char@)">
            <summary>
            Convert the pair of characters to a surrogate pair.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexIdent">
            <summary>
            Lex an identifier.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexComment">
            <summary>
            Lex a comment.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexSpace">
            <summary>
            Lex a sequence of spacing characters.
            Always returns null.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexLineTerm">
            <summary>
            Lex a line termination character. Transforms CRLF into a single LF.
            Updates the line mapping.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexPreProc">
            <summary>
            Lex a pre-processing directive. The default implementation doesn't
            handle pre-processing.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.LexOther">
            <summary>
            Skip over an error character. Always returns null.
            REVIEW shonk: Should we skip over multiple?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.Eof">
            <summary>
            Whether we've hit the end of input yet. If this returns true, ChCur will be zero.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Lexer.LexerImplBase.ChCur">
            <summary>
            The current character. Zero if we've hit the end of input.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Lexer.UniCatFlags">
            <summary>
            Bit masks of the UnicodeCategory enum. A couple extra values are defined
            for convenience for the C# lexical grammar.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.LineMapper">
            <summary> Maps from character location to (path, line, column). This is normally populated
            by filtering a token stream.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LineMapper.#ctor(Microsoft.SolverFoundation.Common.ITextVersion)">
            <summary> Maps from character location to (path, line, column). This is normally populated
            by filtering a token stream.
            </summary>
            <param name="tvr"> text version </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LineMapper.AddNewLine(Microsoft.SolverFoundation.Common.NewLineToken)">
            <summary> Add a new line
            </summary>
            <param name="tok"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LineMapper.MapSpanToPos(Microsoft.SolverFoundation.Common.TextSpan,Microsoft.SolverFoundation.Common.SrcPos@)">
            <summary> map a span to a position
            </summary>
            <param name="span"></param>
            <param name="spos"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LineMapper.MapToLineCol(System.Int32,System.String@,System.Int32@,System.Int32@)">
            <summary> Map to line and column
            </summary>
            <param name="ichSrc"></param>
            <param name="path"></param>
            <param name="line"></param>
            <param name="col"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.LineMapper.DefaultPath">
            <summary> default path
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.SrcPos">
            <summary> This is the verbose data structure. A TextPos can be resolved to one of these with the
            help of a line mapper / lexer.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.spanRaw">
            <summary> the span of text
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.pathMin">
            <summary> path of minimum
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.pathLim">
            <summary> Path for limit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.lineMin">
            <summary> Line minimum
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.colMin">
            <summary> Column minimum
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.lineLim">
            <summary> Line limit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.SrcPos.colLim">
            <summary> Column limit
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.SrcPos.ToString">
            <summary> Convert the source position to a formatted string
            </summary>
            <returns> the formatted representation </returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.IText">
            <summary> A TextVersionImpl that also has access to the actual text.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.IText.GetReader(System.Int32)">
            <summary> Get a TextReader.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.IText.Version">
            <summary> Get the version.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.ITextVersion">
            <summary>
            Used to identify a version of a text stream and map between different
            versions of the same text stream. Doesn't guarantee access to the actual text.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ITextVersion.SameStream(Microsoft.SolverFoundation.Common.ITextVersion)">
            <summary> Indicates whether the ITextVersion refers to the same underlying stream as another ITextVersion.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ITextVersion.SameVersion(Microsoft.SolverFoundation.Common.ITextVersion)">
            <summary> Indicates whether two ITextVersions have the same version.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ITextVersion.MapSpan(Microsoft.SolverFoundation.Common.TextSpan@)">
            <summary> MapSpan.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.ITextVersion.MapToSame(Microsoft.SolverFoundation.Common.TextSpan@,Microsoft.SolverFoundation.Common.TextSpan@)">
            <summary> MapToSame.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.ITextVersion.Path">
            <summary> The path.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TextSpan">
            <summary> Represents a span of text in a text buffer.
            This needs to be very compact. Every token has one of these.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TextSpan.#ctor(Microsoft.SolverFoundation.Common.ITextVersion,System.Int32,System.Int32)">
            <summary> constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TextSpan.AssertValid">
            <summary> Do internal consistency check
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TextSpan.op_Addition(Microsoft.SolverFoundation.Common.TextSpan,Microsoft.SolverFoundation.Common.TextSpan)">
            <summary> Compute the union of the two spans.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TextSpan.ToString">
            <summary> Represent as a formatted string
            </summary>
            <returns> the string representation </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TextSpan.MapToSame(Microsoft.SolverFoundation.Common.TextSpan@,Microsoft.SolverFoundation.Common.TextSpan@)">
            <summary> Map to same
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TextSpan.IsValid">
            <summary> Check if valid
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TextSpan.Version">
            <summary> get text version
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TextSpan.Min">
            <summary> get the minimum
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TextSpan.Lim">
            <summary> get the limit
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.MoveTo(System.Int32)">
            <summary> Move to
            </summary>
            <param name="itok"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.TidNext">
            <summary> next token's ID
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.TokMove">
            <summary> Token move
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.TokMove(System.Int32)">
            <summary> Token move
            </summary>
            <param name="ctok"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.TokPeek(System.Int32)">
            <summary> Peek without taking
            </summary>
            <param name="ditok"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenCursor.TidPeek(System.Int32)">
            <summary> Peek without taking
            </summary>
            <param name="ditok"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TokenCursor.ItokCur">
            <summary> current token
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TokenCursor.TokCur">
            <summary> current token
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.TokenCursor.TidCur">
            <summary> current token ID
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TokenFilter">
            <summary> Filters out tokens based on a predicate.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokenFilter.Filter(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Token},Microsoft.SolverFoundation.Common.RefFunction{Microsoft.SolverFoundation.Common.Token,System.Boolean})">
            <summary> The one and only entry point. Filters out tokens based on a predicate.
            Note that the "predicate" may also transform the token or otherwise act on it.
            </summary>
            <param name="rgtok">The source token stream.</param>
            <param name="pred">The delegate to invoke on each token. If it returns true, the token is yielded.</param>
            <returns>The filtered token stream.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.Token">
            <summary> Lexical tokens
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.#ctor(Microsoft.SolverFoundation.Common.TokKind)">
            <summary> construct
            </summary>
            <param name="tid"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.#ctor(Microsoft.SolverFoundation.Common.TokKind,Microsoft.SolverFoundation.Common.TextSpan)">
            <summary> constructor
            </summary>
            <param name="tid"></param>
            <param name="span"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.SetExtents(Microsoft.SolverFoundation.Common.TextSpan)">
            <summary> set extents
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.GetSpan(Microsoft.SolverFoundation.Common.ITextVersion,Microsoft.SolverFoundation.Common.TextSpan@)">
            <summary> Get Span
            </summary>
            <param name="tvr"></param>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.ImmediatelyBefore(Microsoft.SolverFoundation.Common.Token)">
            <summary> Test if before
            </summary>
            <param name="tokAfter"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.op_LessThan(Microsoft.SolverFoundation.Common.Token,Microsoft.SolverFoundation.Common.Token)">
            <summary> token comparison
            </summary>
            <param name="tok1"></param>
            <param name="tok2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.op_GreaterThan(Microsoft.SolverFoundation.Common.Token,Microsoft.SolverFoundation.Common.Token)">
            <summary> token comparison
            </summary>
            <param name="tok1"></param>
            <param name="tok2"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.As``1">
            <summary> coerce to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.ToString">
            <summary> Convert to string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Token.DumpString">
            <summary> formatted string representation
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Token.Kind">
            <summary> ID of token
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Token.Nested">
            <summary> test or set Nested
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.Token.Span">
            <summary> get the span
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.NewLineToken">
            <summary> Lexer newline token
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NewLineToken.#ctor">
            <summary> Constructor
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.NewLineToken.Nested">
            <summary> test or set Nested
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TokKindEnum">
            <summary>
            Identifies the kind of token. All values are defined by one of the token
            info classes, eg, TokKind.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.TokKind">
            <summary> Kind of token
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NoneId">
            <summary> NoneId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.IdentId">
            <summary> IdentId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CommentId">
            <summary> CommentId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.IntLitId">
            <summary> IntLitId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DecimalLitId">
            <summary> DecimalLitId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CharLitId">
            <summary> CharLitId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.StrLitId">
            <summary> StrLitId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AddId">
            <summary> AddId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AddAddId">
            <summary> AddAddId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AddEquId">
            <summary> AddEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubId">
            <summary> SubId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubSubId">
            <summary> SubSubId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubEquId">
            <summary> SubEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubGrtId">
            <summary> SubGrtId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtId">
            <summary> GrtId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtGrtId">
            <summary> GrtGrtId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtGrtEquId">
            <summary> GrtGrtEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtEquId">
            <summary> GrtEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssId">
            <summary> LssId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssLssId">
            <summary> LssLssId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssLssEquId">
            <summary> LssLssEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssEquId">
            <summary> LssEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AndId">
            <summary> AndId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AndAndId">
            <summary> AndAndId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AndEquId">
            <summary> AndEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.OrId">
            <summary> OrId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.OrOrId">
            <summary> OrOrId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.OrEquId">
            <summary> OrEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.MulId">
            <summary> MulId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.MulEquId">
            <summary> MulEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DivId">
            <summary> DivId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DivEquId">
            <summary> DivEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NotId">
            <summary> NotId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NotEquId">
            <summary> NotEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.EquId">
            <summary> EquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.EquEquId">
            <summary> EquEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ModId">
            <summary> ModId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ModEquId">
            <summary> ModEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.XorId">
            <summary> XorId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.XorEquId">
            <summary> XorEquId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.QuestId">
            <summary> QuestId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.QuestQuestId">
            <summary> QuestQuestId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ColonId">
            <summary> ColonId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ColonColonId">
            <summary> ColonColonId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.TildeId">
            <summary> TildeId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DotId">
            <summary> DotId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CommaId">
            <summary> CommaId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SemiId">
            <summary> SemiId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.HashId">
            <summary> HashId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DollarId">
            <summary> DollarId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.BackSlashId">
            <summary> BackSlashId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.BackTickId">
            <summary> BackTickId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CurlOpenId">
            <summary> CurlOpenId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CurlCloseId">
            <summary> CurlCloseId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ParenOpenId">
            <summary> ParenOpenId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ParenCloseId">
            <summary> ParenCloseId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SquareOpenId">
            <summary> SquareOpenId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SquareCloseId">
            <summary> SquareCloseId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.EofId">
            <summary> EofId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NewLineId">
            <summary> NewLineId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ErrorId">
            <summary> ErrorId
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.None">
            <summary> None
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Ident">
            <summary> Ident
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Comment">
            <summary> Comment
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.IntLit">
            <summary> IntLit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DecimalLit">
            <summary> DecimalLit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CharLit">
            <summary> CharLit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.StrLit">
            <summary> StrLit
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Add">
            <summary> Add
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AddAdd">
            <summary> AddAdd
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AddEqu">
            <summary> AddEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Sub">
            <summary> Sub
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubSub">
            <summary> SubSub
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubEqu">
            <summary> SubEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SubGrt">
            <summary> SubGrt
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Grt">
            <summary> Grt
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtGrt">
            <summary> GrtGrt
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtGrtEqu">
            <summary> GrtGrtEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.GrtEqu">
            <summary> GrtEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Lss">
            <summary> Lss
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssLss">
            <summary> LssLss
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssLssEqu">
            <summary> LssLssEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.LssEqu">
            <summary> LssEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.And">
            <summary> And
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AndAnd">
            <summary> AndAnd
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.AndEqu">
            <summary> AndEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Or">
            <summary> Or
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.OrOr">
            <summary> OrOr
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.OrEqu">
            <summary> OrEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Mul">
            <summary> Mul
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.MulEqu">
            <summary> MulEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Div">
            <summary> Div
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.DivEqu">
            <summary> DivEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Not">
            <summary> Not
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NotEqu">
            <summary> NotEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Equ">
            <summary> Equ
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.EquEqu">
            <summary> EquEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Mod">
            <summary> Mod
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ModEqu">
            <summary> ModEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Xor">
            <summary> Xor
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.XorEqu">
            <summary> XorEqu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Quest">
            <summary> Quest
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.QuestQuest">
            <summary> QuestQuest
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Colon">
            <summary> Colon
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ColonColon">
            <summary> ColonColon
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Tilde">
            <summary> Tilde
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Dot">
            <summary> Dot
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Comma">
            <summary> Comma
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Semi">
            <summary> Semi
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Hash">
            <summary> Hash
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Dollar">
            <summary> Dollar
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.BackSlash">
            <summary> BackSlash
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.BackTick">
            <summary> BackTick
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CurlOpen">
            <summary> CurlOpen
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.CurlClose">
            <summary> CurlClose
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ParenOpen">
            <summary> ParenOpen
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.ParenClose">
            <summary> ParenClose
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SquareOpen">
            <summary> SquareOpen
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.SquareClose">
            <summary> SquareClose
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.NewLine">
            <summary> NewLine
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Error">
            <summary> Error
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Common.TokKind.Eof">
            <summary> Eof
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.TokKind.ToString">
            <summary> string representation of this
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.LogIdSet">
            <summary>
            Represents a set of logging ids.
            Currently this only supports id values from 0 to 63, but will likely be extended
            to support arbitrary non-negative ids.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.#ctor(System.Int32)">
            <summary>
            Set log id
            </summary>
            <param name="id"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.#ctor(System.Int32,System.Int32)">
            <summary>
            Set logging range 
            </summary>
            <param name="id1"></param>
            <param name="id2"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.#ctor(System.Int32[])">
            <summary>
            Set logging range
            </summary>
            <param name="rgid"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_OnesComplement(Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Computes the set-wise complement of the LogIdSet.
            </summary>
            <param name="ids">a set of log ids</param>
            <returns>a log id set </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_BitwiseOr(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Computes the set-wise union of the LogIdSets.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_ExclusiveOr(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Computes the set-wise symmetric difference of the LogIdSets.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_Division(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Computes the set-wise difference of the LogIdSets.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_BitwiseAnd(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Computes the set-wise intersection of the LogIdSets.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.Union(Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            union two log id sets
            </summary>
            <param name="ids"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.SymmetricDifference(Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            
            </summary>
            <param name="ids"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.Contains(System.Int32)">
            <summary>
            Check whether id is in the set 
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.ContainsAny(Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Check if a subset 
            </summary>
            <param name="set">a subset</param>
            <returns>true if it is a subset. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.Add(System.Int32)">
            <summary>
            Add the log id to the set 
            </summary>
            <param name="id">a log id</param>
            <returns>a new log set</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.Remove(System.Int32)">
            <summary>
            Remove the log id from the set
            </summary>
            <param name="id">a log id</param>
            <returns>a new log set</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_Addition(Microsoft.SolverFoundation.Common.LogIdSet,System.Int32)">
            <summary>
            Add a log id to the set
            </summary>
            <param name="ids">a log set id</param>
            <param name="id">a log id</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_Subtraction(Microsoft.SolverFoundation.Common.LogIdSet,System.Int32)">
            <summary>
            Remove a log id from the set 
            </summary>
            <param name="ids">a log set</param>
            <param name="id">a log id</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.Equals(System.Object)">
            <summary> Compare whether two LogIdSets are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_Equality(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary> Compare whether two LogIdSets are value equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.op_Inequality(Microsoft.SolverFoundation.Common.LogIdSet,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary> Compare whether two LogIdSets are not value equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogIdSet.GetHashCode">
            <summary> Return the hashcode of this LogIdSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.LogIdSet.None">
            <summary>
            no logging 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.LogIdSet.All">
            <summary>
            log all 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.LogIdSet.IsEmpty">
            <summary>
            Gets whether the LogIdSet is empty.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.NormStr">
            <summary>
            Normalized string type, used for string pooling.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.#ctor(System.UInt32,System.String)">
            <summary>
            NormStr's can only be created by the Pool.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.ToString">
            <summary>Returns the string representation.
            </summary>
            <returns>A System.String.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.GetHashCode">
            <summary>Serves as a hash function for NormStr.
            </summary>
            <returns>A hash code for the current NormStr.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.op_Implicit(Microsoft.SolverFoundation.Common.NormStr)~System.String">
            <summary>Converts to a string object.
            </summary>
            <param name="name">A NormStr.</param>
            <returns>A System.String.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.NormStr.Empty">
            <summary>
            The one and only empty NormStr.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Common.NormStr.IsEmpty">
            <summary>
            Indicates whether the instance represent an empty string.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.NormStr.Pool">
            <summary>
            a NormStr pool
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.Pool.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.Pool.Add(System.String)">
            <summary>
            Make sure the given string has an equivalent NormStr in the pool
            and return it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.Pool.Get(System.String)">
            <summary>
            If the string has an equivalent NormStr in the pool return it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.Pool.GetCore(System.String,System.Boolean)">
            <summary>
            Make sure the given string has an equivalent NormStr in the pool
            and return it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.NormStr.Pool.Add(System.Text.StringBuilder)">
            <summary>
            Make sure the given string builder has an equivalent NormStr in the pool
            and return it. This method is almost identical to the previous.
            Unfortunately, the code can't really be shared.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.SetHeadBits">
            <summary>
            This sets the head bits correctly and sets _ivLim minimally.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.BuildInverse">
            <summary>
            This builds the inverse.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.ForceMap(System.Int32,System.Int32)">
            <summary>
            Forces ivSrc to map to ivDst. If ivCur currently maps to ivDst, this
            is equivalent to Swap(ivSrc, ivCur).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.Apply``1(``0[])">
            <summary>
            This moves item rgv[iv] to rgv[this[iv]].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.ApplyInverse``1(``0[])">
            <summary>
            This moves item rgv[this[iv]] to rgv[iv].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.Permutation.ApplyInvCore``1(``0[],System.Int32[])">
            <summary>
            This moves item rgv[rgivMap[iv]] to rgv[iv]. This assumes
            rgivMap has the same head list as _rgiv (and _rgivInv).
            In fact, this is currently only called with rgivMap set to
            _rgiv or _rgivInv.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Common.LogSource">
            <summary>
            Sends information to the Listeners.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.#ctor(System.String)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.AddListener(System.Diagnostics.TraceListener,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Adds a listener. If the listener is already registered, its LogIdSet is updated.
            If the LogIdSet is empty, the listener is removed.
            Returns true iff the listener was newly added (not removed or updated).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.RemoveListener(System.Diagnostics.TraceListener)">
            <summary>
            Removes a listener. If the listener is not currently registed,
            has no affect.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.ShouldLog(System.Int32)">
            <summary>
            Checks whether an event should be logged.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32)">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32,System.String)">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32,System.String,System.Object)">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32,System.String,System.Object,System.Object)">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Common.LogSource.LogEvent(System.Int32,System.String,System.Object[])">
            <summary>
            Logs an event.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.BindingUtilities">
            <summary>Helper methods for Parameter and Decision data binding.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.SetBinding``1(Microsoft.SolverFoundation.Services.Parameter,``0)">
            <summary>Bind a parameter to a scalar value.
            </summary>
            <param name="parameter">A Parameter (which should have no index sets).</param>
            <param name="data">The scalar value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.SetBinding``1(Microsoft.SolverFoundation.Services.Parameter,System.Collections.Generic.IEnumerable{``0})">
            <summary>Bind an indexed parameter to an IEnumerable of values.
            </summary>
            <param name="parameter">A Parameter (which should have one index set).</param>
            <param name="data">An IEnumerable containing the data.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.SetBinding``1(Microsoft.SolverFoundation.Services.Parameter,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Bind an indexed parameter to a table.
            </summary>
            <param name="parameter">A Parameter (which should have two index sets).</param>
            <param name="data">An IEnumerable containing the data. Each entry contains values for the first index.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.SetBinding(Microsoft.SolverFoundation.Services.Parameter,System.Collections.Generic.IEnumerable{System.Object[]})">
            <summary>Bind an indexed parameter to an IEnumerable.
            </summary>
            <remarks>The first slot in each element of values is assumed to store the value. The remaining slots
            store the indexes.
            </remarks>
            <param name="parameter">A Parameter.</param>
            <param name="data">An IEnumerable containing the indexes and values. The first entry of each item in the IEnumerable contains the value; the remaining entries are indexes.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.GetValuesByIndex(Microsoft.SolverFoundation.Services.Decision)">
            <summary>Gets the values for a decision with one index Set.
            </summary>
            <returns>An IEnumerable containing the values.</returns>
            <remarks>The values are returned ordered by index.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BindingUtilities.GetValuesByFirstIndex(Microsoft.SolverFoundation.Services.Decision)">
            <summary>Gets the values for a decision with two index Sets.
            </summary>
            <returns>An IEnumerable containing the values, grouped by the first index.</returns>
            <remarks>The values are returned ordered by index.</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.BindingUtilities.ArrayWrapper">
            <summary>An object array wrapper to support data binding.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Variable.#ctor(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.Domain,System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="dom"></param>
            <param name="vid"></param>
            <param name="dataOut">string for data out after solving</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Variable.SolverId">
            <summary>
            Id related to this variables on Solver
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.AddGoalsToGoalsList(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation},Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Verify that all args are Minimize Or maximize and add them
            </summary>
            <param name="goalsSections"></param>
            <param name="goalInvocation"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.SubsituteValueTables(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation},System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Makes a Substitution for the ValueSets and ValueTables and apply to goals and constraints
            </summary>
            <param name="constraintsSections">section of constraints of the model</param>
            <param name="goalSections">section of goal(Minimize/Maximize) of the model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.CreateValueTables(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Go over the parameters sections and create the needed ValueSets and ValueTables
            </summary>
            <param name="paramsSections">section of parameters of the model</param>
            <returns>true if succeeded, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.CanBeAssignedToParameter(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.Domain)">
            <summary>
            Return true if the expression is constant, false otherwise.
            </summary>
            <param name="expression"></param>
            <param name="domain"></param>
            <returns>true if Constant false otherwize</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.BindData(Microsoft.SolverFoundation.Rewrite.Invocation,System.String@,Microsoft.SolverFoundation.Rewrite.Expression@)">
            <summary>
            Calls for the delegate which suppose to bind the data to the ValueTabres parameters
            </summary>
            <param name="inputSection">section of Input of the model</param>
            <param name="strError">out string to be used when error</param>
            <param name="exprError">out expression to be used when error</param>
            <returns>true if succeeded, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.ExcelBindData(Microsoft.SolverFoundation.Rewrite.Invocation,System.Int32,System.String@,Microsoft.SolverFoundation.Rewrite.Expression@)">
            <summary>
            Calls the excel delegate which suppose to bind the data to the ValueTabres parameters 
            </summary>
            <param name="inputSection">section of Input of the model</param>
            <param name="ivSub">first bind clause in Invocation</param>
            <param name="strError">out string to be used when error</param>
            <param name="exprError">out expression to be used when error</param>
            <returns>true if succeeded, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.ExpandAndAddConstraintsToModel(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Expand each constraint and add to the model
            </summary>
            <param name="constraintsSections">Constraints sections of the model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.ExpandAndAddGoalsToModel(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Expand each goal and add to the model
            Remark: the order of the goals matters
            </summary>
            <param name="goalSections">Minimize/Maximize sections of the model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.ExpandAndAddVariablesToModel(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Expand variables which are "set-indexed" and add all variables to the model
            </summary>
            <param name="decisionsSections">list of all Decisions sections</param>
            <returns>false if something is wrong, true otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.IsForeachOverSets(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>
            Checks Foreach statement
            Can be used before or after substitue
            </summary>
            <param name="foreachExp"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.IsDomain(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>
            Check if the expression seems to be domain expression
            </summary>
            <param name="dom"></param>
            <returns>true if the expression looks like domain expression, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.DomainFromExpression(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary> Gets Domain from an Expression
            </summary>
            <param name="dom">domain expression</param>
            <returns>null if something is wrong, the new domain otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.DomainFromExpression(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Symbol)">
            <summary> Gets Domain from an Expression
            </summary>
            <param name="dom">domain expression</param>
            <param name="exprName">Name expression (for user-named domains such as Enum)</param>
            <returns>null if something is wrong, the new domain otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.DomainFromExpression(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.Model@)">
            <summary> Gets Domain from an Expression
            </summary>
            <param name="dom">domain expression</param>
            <param name="submodel">submodel object if the domain expression is actually a submodel name</param>
            <returns>the SFS domain; null if the domain expression actually refers to a submodel; 
            something is wrong if both submodel is null and returns null</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.DomainFromExpression(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Symbol,Microsoft.SolverFoundation.Services.Model@)">
            <summary>
            Gets Domain from an Expression
            REVIEW shahark: for now this method dosn't deal with list of strings, it does not clear on the side of 
            the ValueSets and ValueTable if those are really fully support.
            </summary>
            <param name="dom">domain expression</param>
            <param name="exprName">Name expression (for user-named domains such as Enum)</param>
            <param name="submodel">submodel object if the domain expression is actually a submodel name</param>
            <returns>the SFS domain; null if the domain expression actually refers to a submodel; 
            something is wrong if both submodel is null and returns null</returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ConcreteModel.SfsModelExtractor._exprStrings">
            <summary>
            This comes from the parser, and maps the Expression for a constraint or goal (not including
            the Rule[] if there is one) to the actual source text for that Expression.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.SfsModelExtractor.TryRemoveRecourse(Microsoft.SolverFoundation.Rewrite.Expression@)">
            <summary> Try to remove Recourse from an expression.
            </summary>
            <param name="expr">The expression to be modified.</param>
            <returns>Returns true if Recourse was stripped off.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.SfsModelExtractor.ConvertNamedConstant(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.Domain)">
            <summary>
            Take a Parameter in the form "P = const" or "Foreach[..., P = const]" (possibly nested)
            and create a NamedConstantTerm object to represent it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.SfsModelExtractor.FindNamedConstantIterators(Microsoft.SolverFoundation.Rewrite.Expression,System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.IterationTerm}@,System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.Set}@)">
            <summary>
            Unwraps a series of nested Foreach statements "Foreach[..., Foreach[..., P[x,y] = expr]]"
            and extracts the iterators and the inner expression "P[x,y] = expr".
            </summary>
            <param name="exprParam"></param>
            <param name="allIterTerms"></param>
            <param name="allIterSets"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConcreteModel.SfsModelExtractor.GetIndexSets(Microsoft.SolverFoundation.Rewrite.Expression@)">
            <summary>
            </summary>
            <returns>Either full or empty List, but never null</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Constraint">
            <summary> A Constraint encapsulates a term and its role as a constraint in the model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Constraint._name">
            <summary>
            The name of this constraint. Must be unique.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Constraint.#ctor(Microsoft.SolverFoundation.Services.SolverContext,System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Constructs a new constraint.
            </summary>
            <param name="name">The constraint's name. Must be unique.</param>
            
            <param name="term">The term tree the constraint encapsulates.</param>
            <param name="context">Solver context</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Constraint.IsSecondStage">
            <summary>
            Check if the constraints is second stage
            </summary>
            <returns>true iff (Recourse decision participates or random parameter participates)</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Constraint.Name">
            <summary>
            The name of the constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Constraint.Expression">
            <summary>
            The expression of the constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Constraint.Description">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Constraint.Enabled">
            <summary>
            Whether to enable the constraint.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ITermVisitor`2">
            <summary>
            The Visitor pattern implemented for Term.
            </summary>
            <typeparam name="Result"></typeparam>
            <typeparam name="Arg"></typeparam>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DataBindingSupport">
            <summary>
            This class contains static functions to support data binding.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DataBindingSupport.MakeAccessorDelegate``2(System.String,Microsoft.SolverFoundation.Services.Domain,System.Type)">
            <summary>
            Create a delegate which extracts a given field from an object, including casting it to the result type.
            </summary>
            <typeparam name="T">The type of the object.</typeparam>
            <typeparam name="TResult">The type of the result.</typeparam>
            <param name="valueField">The name of the field to extract.</param>
            <param name="domain">The domain of the field to extract.</param>
            <param name="intermediateType">Intermediate result type (optional).</param>
            <returns>A delegate.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">The property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Decision">
            <summary> A group of decision variables for which a solver finds values.
            </summary>
            <remarks>
            Decisions are output variables determined by a solver. All decisions have a Domain
            which determine the range of acceptable values.
            A decision may be single-valued (scalar), or multi-valued (a table). To create a 
            single-valued decision, pass in a zero-length indexSets array. If indexSets has nonzero 
            length, each element represents a set of values over which the decision is indexed. For 
            example, if there are two index sets, then this decision takes two indexes, one from the 
            first set and one from the second set. The total number of decisions is the product of the
            sizes of all the index sets.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Term">
            <summary> A term used in a model decision, formula, goal or constraint.
            </summary>
            <remarks>
            Terms may represent data such as constants, decisions, or parameters. Terms may also
            represent operations that combine other Term objects, for example arithmetic or logical
            operations. The Model class has static methods that produce terms for many standard
            mathematical operations.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.#ctor">
            <summary>
            Internal constructor to ensure external users cannot subclass from Term or any derived classes of Term (such as Decision)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Multiply(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent multiplication
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Addition(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent addition
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Subtraction(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent subtraction
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_UnaryNegation(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent negation
            </summary>
            <param name="term"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Division(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent division
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThan(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent less-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThan(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent greater-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThanOrEqual(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent less-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent greater-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Equality(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent equality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Inequality(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent inequality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Equality(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent equality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Equality(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent equality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Inequality(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent inequality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Inequality(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent inequality
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThan(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent less-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThan(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent less-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThanOrEqual(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent less-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LessThanOrEqual(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent less-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThan(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent greater-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThan(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent greater-than
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Services.Term,System.String)">
            <summary>
            Represent greater-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_GreaterThanOrEqual(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent greater-than-or-equal
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.CreateBinaryComparison(Microsoft.SolverFoundation.Services.Operator,Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Helper function for creating binary comparisons. This is much faster than using the generic
            (params) CreateInvocationTerm.
            </summary>
            <param name="head"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_BitwiseAnd(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent Boolean and
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_BitwiseOr(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent Boolean or
            </summary>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_LogicalNot(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Represent Boolean negation
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Implicit(System.Double)~Microsoft.SolverFoundation.Services.Term">
            <summary>
            Constant double term
            </summary>
            <param name="value">The constant value</param>
            <returns>A new Term</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Implicit(System.String)~Microsoft.SolverFoundation.Services.Term">
            <summary>
            Constant string term
            </summary>
            <param name="value">The constant value</param>
            <returns>A new Term</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Implicit(System.Boolean)~Microsoft.SolverFoundation.Services.Term">
            <summary>
            Constant boolean term
            </summary>
            <param name="value">The constant value</param>
            <returns>A new Term</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.op_Implicit(Microsoft.SolverFoundation.Common.Rational)~Microsoft.SolverFoundation.Services.Term">
            <summary>
            Constant Rational term
            </summary>
            <param name="value">The constant value</param>
            <returns>A new Term</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Term.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.IsModelIndependentTerm">
            <summary>
            Whether the term can be used in any models. Example of such terms are: constant terms, operator terms whose inputs are all constants.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.TermType">
            <summary>
            The subclass of term (for fast switching)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.ValueClass">
            <summary>
            The type of this term (boolean, numeric, enumerated, etc.)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.Structure">
            <summary>
            Some information about the structure of the term (used for model analysis)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.IsNumeric">
            <summary>
            True if this is numeric or boolean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Term.EnumeratedDomain">
            <summary>
            If this is an enumerated term, this contains its domain (for getting the enumerated strings).
            If this isn't an enumerated term, it contains either the domain or null.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IVariable">
            <summary>
            Represents an object which recieves a value as a result of solving.
            This interface is internal because it exposes NL Symbols.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IVariable.SetValue(Microsoft.SolverFoundation.Common.Rational,System.Object[])">
            <summary>
            Set the value (or one of the values) of the object. Called after solving.
            </summary>
            <param name="value">The value to set.</param>
            <param name="indexes"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IDataBindable">
            <summary>
            An object which needs to be handled during data binding, either because it contains data which is read during hydration
            or because it will recieve data during solve.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IDataBindable.DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Reads data from a data source and binds it to the object.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IDataBindable.PropagateValues(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Pushes values changes back to the data source.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String)">
            <summary>
            Create a new decision. The decision may be a single value (scalar), or multiple values (a table).
            To create a single-value decision, pass in a zero-length indexSets array.
            If indexSets has nonzero length, each element of it represents a set of values which this decision
            is indexed by. For example, if there are two index sets, then this decision takes two indexes, one from the
            first set and one from the second set.
            The total number of decisions is the product of the sizes of all the index sets.
            </summary>
            <param name="domain">The set of values each element of the decision can take, such as Model.Real</param>
            <param name="name">A name for the decision. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            Create a new decision. The decision may be a single value (scalar), or multiple values (a table).
            To create a single-value decision, pass in a zero-length indexSets array.
            If indexSets has nonzero length, each element of it represents a set of values which this decision
            is indexed by. For example, if there are two index sets, then this decision takes two indexes, one from the
            first set and one from the second set.
            The total number of decisions is the product of the sizes of all the index sets.
            </summary>
            <param name="domain">The set of values each element of the decision can take, such as Model.Real</param>
            <param name="name">A name for the decision. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar decision.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.#ctor(System.String,Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            A shallow copy constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.SetIndexSet(System.Int32,Microsoft.SolverFoundation.Services.Set)">
            <summary>Re-sets the ith index set (refreshing the cache).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Binds the decision to data. A decision does not need to be bound to data. If it is, the data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. The sequence must contain one object
            for each decision.
            
            The data is written when Context.PropagateDecisions is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which will be assigned the value of the data decisions.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">The property or field is not writable.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Binds the decision to data. A decision does not need to be bound to data. If it is, the data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. The sequence must contain one object
            for each decision.
            
            The data is written when Context.PropagateDecisions is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which will be assigned the value of the data decisions.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data decisions, one for
            each index set which was provided when the Decision was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">The property or field is not writable.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
            <remarks>
            The "n" format causes the decision names to be printed rather than values.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.ToString(System.IFormatProvider)">
            <summary> Returns a string that represents the current Decision.
            </summary>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.ToString">
            <summary>Returns a string that represents the current Decision.
            </summary>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.ToString(System.Object[])">
            <summary>Unlike the public ToString() this one uses the decision name and not its value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.ToDouble">
            <summary>
            Convert the (single) value to a double-precision floating-point number
            </summary>
            <returns>The value of the decision as double-precision floating-point</returns>
            <exception cref="T:System.InvalidCastException">Thrown if the decision has no value or multiple values.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the value is not numeric.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.GetString(System.Object[])">
            <summary>
            Convert the (indexed) value to a string
            </summary>
            <param name="indexes">The indexes of the value to get.</param>
            <returns>The value of the decision as string</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no value for the given indexes.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the number of indexes given does not match the number expected.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.GetDouble(System.Object[])">
            <summary>
            Convert the (indexed) value to a double-precision floating-point number
            </summary>
            <param name="indexes">The indexes of the value to get.</param>
            <returns>The value of the decision as double-precision floating-point</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no value for the given indexes.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the number of indexes given does not match the number expected.</exception>
            <exception cref="T:System.InvalidCastException">Thrown if the value is not numeric.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.GetValue(System.Object[])">
            <summary>
            Gets a value from the underlying ValueTable
            </summary>
            <param name="indexes">The indexes of the value to get. They do not need to be translated to canonical form.</param>
            <returns>The Rational value.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if there is no value for the given indexes.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the number of indexes given does not match the number expected.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.SetInitialValue(Microsoft.SolverFoundation.Common.Rational,System.Object[])">
            <summary>
            Provides a hint value which is close to the optimal value of the decision. Some solvers may
            be able to use the hint to find solutions faster.
            </summary>
            <param name="value">The initial value</param>
            <param name="indexes">The indexes of the value to set</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.GetValues">
            <summary>
            Returns a sequence of (value, indexes) elements for this decision. Each element is an array
            where the first element is the result value, and the remaining elements are the index values.
            </summary>
            <returns>A sequence of (value, indexes) elements for this decision</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.BoolValue(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Converts the internal value to a boolean, as appropriate for the domain.
            </summary>
            <param name="value"></param>
            <returns>The boolean result.</returns>
            <exception cref="T:System.InvalidCastException">Thrown if the value is not boolean.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.DoubleValue(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.InvalidCastException">Thrown if the value is not numeric.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Decision.CreateBinding">
            <summary>
            Creates a new DecisionBinding wrapping this. Only integer and enumerated decisions that are not indexed may be bound.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Decision.IndexSets">
            <summary>
            The index sets passed in when this object was created.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Decision.Binding">
            <summary>
            A LINQ binding to a database column to write the values to
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Decision.Item(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Term indexed by one or more indexes 
            </summary>
            <param name="indexes">The indexes for the particular term</param>
            <returns>A Term that represents the indexed Decision.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Decision.Name">
            <summary>
            The name of the decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Decision.Description">
            <summary>
            A description.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RecourseDecision">
            <summary> RecourseDecisions are Decisions that are made in response to the realization of a RandomParameter.
            </summary>
            <remarks>
            Recourse decisions are sometimes called "second-stage" because such decisions can be made 
            only after the randomness is resolved.  Each RecourseDecision has an underlying Decision 
            for each second stage problem.  Example: the weather may be modeled using a ScenariosParameter. 
            If the weather turns out to be dry, we may not be able to produce enough of a certain crop 
            and may need to purchase it from someone else.  In this case, the purchase amount is a recourse decision.  
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String)">
            <summary>Create a new non-indexed recourse decision. 
            </summary>
            <param name="domain">The set of values each element of the decision can take, such as Model.Real</param>
            <param name="name">A name for the decision. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            Create a new indexed recourse decision. The recourse decision may be a single-valued (scalar), or multi-valued (a table).
            To create a single-valued decision, pass in a zero-length indexSets array.
            If indexSets has nonzero length, each element of it represents a set of values which this decision
            is indexed by. For example, if there are two index sets, then this decision takes two indexes, one from the
            first set and one from the second set.
            The total number of decisions is the product of the sizes of all the index sets.
            </summary>
            <param name="domain">The set of values each element of the decision can take, such as Model.Real</param>
            <param name="name">A name for the decision. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar decision.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.SetIndexSet(System.Int32,Microsoft.SolverFoundation.Services.Set)">
            <summary>Re-sets the ith index set (refreshing the cache).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.Reset">
            <summary>Reset second-stage decision information.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.ToString">
            <summary>
            Convert the value to a string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.CalculateSecondStageResults">
            <summary>
            This is called by the hydrator after all values of the inner decisions was set
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.SetSecondStageResult(System.Double[],System.Object[])">
            <summary>Set the second stage result summary (avg, min, max)
            </summary>
            <remarks>This is called during solving when using decomposition, or after solving finished
            when using DE</remarks>
            <param name="results">avg, min, max</param>
            <param name="keys"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.GetSecondStageResults(System.Object[])">
            <summary>Gets the up to date second stage results (avg, min, max)
            </summary>
            <param name="keys"></param>
            <returns>resluts if exist, null otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RecourseDecision.InitCurrentDecision">
            <summary>
            Gets the underlying decision ready, so it can have the value when solving.  
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RecourseDecision.IndexSets">
            <summary>
            The index sets passed in when this object was created.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RecourseDecision.CurrentSecondStageDecision">
            <summary>
            When setting the CurrentSecondStageDecision this decision is kept
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RecourseDecision.Item(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Term indexed by one or more indexes 
            </summary>
            <param name="indexes">The indexes for the particular term</param>
            <returns>A Term that represents the indexed recourse decision.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RecourseDecision.Name">
            <summary>
            The name of the decision.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RecourseDecision.Description">
            <summary>
            A description.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DecisionBinding">
            <summary>
            Wraps a Decision for SolverContext.Probe.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DecisionBinding.Fix(System.Int32)">
            <summary>
            Fixes this decision to a specific value for purposes of probing. Only feasible solutions where this decision
            takes the given value will be considered during probing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DecisionBinding.Fix(System.String)">
            <summary>
            Fixes this decision to a specific value for purposes of probing. Only feasible solutions where this decision
            takes the given value will be considered during probing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DecisionBinding.Unfix">
            <summary>
            Undoes the result of a previous call to Fix().
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DecisionBinding.Int32FeasibleValues">
            <summary>
            Returns the feasible values of this decision after a call to SolverContext.Probe.
            </summary>
            <exception cref="T:System.InvalidCastException">Thrown if the domain of the decision is not integer.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DecisionBinding.StringFeasibleValues">
            <summary>
            Returns the feasible values of this decision after a call to SolverContext.Probe.
            </summary>
            <exception cref="T:System.InvalidCastException">Thrown if the domain of the decision is not enumerated.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DecisionBinding.Decision">
            <summary>
            The underlying Decision wrapped by this DecisionBinding.
            </summary>
        </member>
        <member name="E:Microsoft.SolverFoundation.Services.DecisionBinding.PropertyChanged">
            <summary>
            Called when the feasible values of this decision change. May be called multiple times during a call to solve.
            Note that the list of feasible values may be incomplete when this is called. Code called from this event must
            not modify the model or fix/unfix a DecisionBinding.
            </summary>
        </member>
        <member name="E:Microsoft.SolverFoundation.Services.DecisionBinding.ValueFeasibilityKnown">
            <summary>
            Called when a specific value of this decision is determined to be definitely feasible or infeasible.
            This will be called exactly once for each possible value of the decision.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexPricing">
            <summary>The pricing strategy to use for simplex.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexPricing.Default">
            <summary> Use whatever pricing the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexPricing.SteepestEdge">
            <summary> Use steepest edge pricing
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexPricing.ReducedCost">
            <summary> Use reduced cost pricing
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexPricing.Partial">
            <summary> Use partial pricing
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexAlgorithm">
            <summary>
            The algorithm to use for simplex.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexAlgorithm.Default">
            <summary> Use whatever algorithm the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexAlgorithm.Primal">
            <summary> Use primal simplex
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexAlgorithm.Dual">
            <summary> Use dual simplex
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexBasis">
            <summary>
            The basis to use for simplex.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexBasis.Default">
            <summary> Use whatever basis the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexBasis.Crash">
            <summary> Use crash basis
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexBasis.Slack">
            <summary> Use slack basis
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexBasis.Freedom">
            <summary> Use freedom basis
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.InteriorPointSymbolicOrdering">
            <summary> Select the manner in which the IPM solver performs symbolic factorizations of
            matrices.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointSymbolicOrdering.Automatic">
            <summary> Automatic (let the solver choose).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointSymbolicOrdering.MinimizeFill">
            <summary> Attempt to minimize estimated fill.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointSymbolicOrdering.AMD">
            <summary> Approximate minimum degree.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.InteriorPointMethodAlgorithm">
            <summary>Algorithm types for IPM.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointMethodAlgorithm.Default">
            <summary> Use whatever algorithm the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointMethodAlgorithm.PredictorCorrector">
            <summary> Use Predictor Corrector
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointMethodAlgorithm.HomogeneousSelfDual">
            <summary> Use Homogeneous Self Dual
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointMethodAlgorithm.PredictorMultiCorrector">
            <summary> Use Predictor multi-corrector
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective">
            <summary>
            A directive for the interior point (IPM) solver.
            </summary>
            <remarks>
            The IPM solver is suitable for linear, quadratic, and second order conic models with real decisions.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.#ctor">
            <summary>
            Create a new IPM directive with default values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.GapTolerance">
            <summary> The gap tolerance. If set to 0, the solver will select a default.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.Algorithm">
            <summary> The algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.SymbolicOrdering">
            <summary> The type of matrix ordering to apply.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.PresolveLevel">
            <summary> The level of presolve the IPM solver will apply.
            -1 means default or automatic, 0 means no presolve, >0 full.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointMethodDirective.IterationLimit">
            <summary> The maximum number of iterations. If negative, no limit.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective">
            <summary>Directive for the hybrid local search solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective.#ctor">
            <summary>
            Directive for the local search solver
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective.RunUntilTimeout">
            <summary>
            Specifies that the Solve() method should continuously keep searching
            until aborted. In this case improved solutions are returned by callbacks.
            False by default. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective.PresolveLevel">
            <summary>Presolve level. -1 means automatic, 0 means no presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.HybridLocalSearchDirective.EqualityTolerance">
            <summary>
            Tolerance for values to be different and still considered equal. Set negative for default.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConstraintProgrammingAlgorithm">
            <summary>
            The algorithm to use for CSP
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ConstraintProgrammingAlgorithm.Default">
            <summary>
            Use whatever algorithm the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ConstraintProgrammingAlgorithm.TreeSearch">
            <summary> Use tree search
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ConstraintProgrammingAlgorithm.LocalSearch">
            <summary>
            Use local search
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection">
            <summary>
            Heuristic to use for variable selection in CSP
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.Default">
            <summary>
            Use whatever heuristic the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.MinimalDomainFirst">
            <summary>
            Enumeration that chooses a variable with smallest domain
            </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.DeclarationOrder">
            <summary>
            Enumeration following the declaration order of the variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.DynamicWeighting">
            <summary>
            Weigh variables dynamically according to their dependents and current domain sizes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.ConflictDriven">
            <summary>
            Enumeration based on conflict analysis following a variant 
            of the VSIDS heuristic used in SAT solvers
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.ImpactPrediction">
            <summary>
            Enumeration based on a forecast of the impact 
            of the decision
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchVariableSelection.DomainOverWeightedDegree">
            <summary>
            Enumeration based on the "domain over weighted degree"
            </summary> 
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TreeSearchValueSelection">
            <summary>
            Heuristic to use for value selection in CSP
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchValueSelection.Default">
            <summary>
            Use whatever heuristic the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchValueSelection.SuccessPrediction">
            <summary>
            Value enumeration based on a prediction of the success
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchValueSelection.ForwardOrder">
            <summary>
            Value enumeration that follows the order of the values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TreeSearchValueSelection.RandomOrder">
            <summary>
            Value enumeration that picks uniformly at random
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection">
            <summary>
            Heuristic to use for move selection in CSP
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.Default">
            <summary>
            Use whatever heuristic the solver thinks is best
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.Greedy">
            <summary>
            Violation-guided greedy move
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.SimulatedAnnealing">
            <summary>
            Simulated annealing
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.GreedyNoise">
            <summary>
            Violation-guided greedy with noise
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.Tabu">
            <summary>
            Violation-guided greedy with noise and tabu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LocalSearchMoveSelection.Gradients">
            <summary>
            Gradient-guided with tabu and escape strategy
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective">
            <summary>
            A directive for the constraint programming (CSP) solver.
            </summary>
            <remarks>
            The CSP solver is suitable for models that involve finite discrete domains and
            combinatorial constraints.
            In the case of a model with no goals, the constraint programming solver will report a Feasible solution.
            By contrast the simplex solver reports Optimal.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.#ctor">
            <summary>
            Create a new CSP directive with default values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.Algorithm">
            <summary>
            The algorithm to use
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.VariableSelection">
            <summary>
            Heuristic for selecting decisions to branch on
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.ValueSelection">
            <summary>
            Heuristic for selecting decision value to test first
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.MoveSelection">
            <summary>
            Heuristic for selecting local search moves
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.RestartEnabled">
            <summary>
            Whether to enable the solver to restart from the beginning if it isn't making progress
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.PrecisionDecimals">
            <summary>
            Number of decimal digits of precision (0 to 4)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective.UserOrderVariables">
            <summary>
            A list of decisions to branch on first
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DecompositionType">
            <summary>
            Indicates how decomposition techniques should be used to solve stochastic models.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DecompositionType.Automatic">
            <summary>
            Let the solver decide whether to use decomposition.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DecompositionType.Disabled">
            <summary>
            Do not use decomposition. Form the deterministic equivalent instead.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.DecompositionType.Enabled">
            <summary>
            Use decomposition.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticDirective">
            <summary>Controls stochastic solution settings.
            </summary>
            <remarks>
            The stochastic directive is suitable for linear models that contain recourse
            decisions and random parameters.
            Sampling options are set using the SolverContext.SamplingParameters property.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticDirective.#ctor">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticDirective.MaximumScenarioCountBeforeSampling">
            <summary>
            When there are more than MaximumScenarioCountBeforeSampling scenarios,
            sampling will be used instead of enumeration.
            Use -1 for automatic mode (Default)
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticDirective.DecompositionType">
            <summary>Whether to use decomposition or the deterministic equivalent.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective">
            <summary>
            A directive for the  Compact Quasi Newton (CQN) solver.
            </summary>
            <remarks>
            The CQN solver is suitable for unconstrainted, unbounded non-linear models with real decisions.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective.#ctor">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective.Tolerance">
            <summary>The solver terminates when the geometrically-weighted average improvement 
            falls below the Tolerance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective.IterationsToRemember">
            <summary>
            Number of previous iterations to remember for estimate of Hessian (m), (default is 17).
            </summary>
            <remarks>
            Higher values lead to better approximations to Newton's method, 
            but use more memory, and requires more time to compute direction.  
            The optimal setting of IterationsToRemember is problem specific,
            depending on such factors as how expensive is function evaluation
            compared to choosing the direction, how easily approximable is the 
            function's Hessian, etc.  A range of 15 to 20 is usually reasonable 
            but if necessary even a value of 2 is better than gradient descent.
            </remarks>    
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonDirective.IterationLimit">
            <summary>The maximum number of solver iterations.
            </summary>
            <remarks>
            If the iteration limit is exceeded, the solver will return CompactQuasiNewtonSolutionQuality.Error.
            The default is Int32.MaxValue.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NelderMeadDirective">
            <summary>
            A directive for the NelderMeadSolver.
            </summary>
            <remarks>
            The Nelder-Mead solver is suitable for unconstrainted, unbounded non-linear models with real decisions.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NelderMeadDirective.#ctor">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NelderMeadDirective.ToString">
            <summary>
            Returns a representation of the directive as a string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadDirective.Tolerance">
            <summary>The solver terminates when the size of the Nelder-Mead simplex falls below the Tolerance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadDirective.IterationLimit">
            <summary>The maximum number of solver iterations.
            </summary>
            <remarks>
            If the iteration limit is exceeded, the solver will return an unknown status.
            The default is Int32.MaxValue.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadDirective.StartMethod">
            <summary>How to initialize the starting point.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadDirective.TerminationSensitivity">
            <summary>The termination policy.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DistributedValue">
            <summary> Random distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DistributedValue.ScenariosCount">
            <summary> The number of possible realizations.
            </summary>
            <remarks> Int32.MaxValue for non degenerate continuous distributions.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DistributedValue.CurrentSample">
            <summary> The most recently sampled value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DistributedValue.Scenarios">
            <summary> All possible scenarios (if there is a finite number of them).
            </summary>
            <remarks>This is the default impl for continuous distribution</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DistributedValue.Distribution">
            <summary> The underlying distribution.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DiscreteScenariosValue">
            <summary> Distribution given by a fixed number of scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.AddScenario(Microsoft.SolverFoundation.Services.Scenario)">
            <summary> Add a scenario to the distributed value.
            </summary>
            <param name="scenario"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.AddScenario(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary> Add a scenario to the distributed value.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.ValidateScenarios">
            <summary>Validates the sum of probabilities is unity.
            </summary>
            <remarks> Should be called after all scenarios are provided.
            shahark: Side effect - The underlying distribution will be initiated here
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.ToString(System.Int32)">
            <summary> Returns a string representation of the first maxCount scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.ScenariosCount">
            <summary> The number of possible realizations.
            </summary>
            <remarks> Int32.MaxValue for continuous distributions.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteScenariosValue.Scenarios">
            <summary> All possible scenarios.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Scenario">
            <summary>Simple struct for (probability, value) pairs.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Scenario.Probability">
            <summary> Probability to get the specific value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Scenario.Value">
            <summary> The value for this scenario.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.#ctor(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Create a new instance given the scenario probability and value.
            </summary>
            <param name="probability">Probability</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.IsValidScenarioValue(Microsoft.SolverFoundation.Common.Rational)">
            <summary>Determine whether a value is valid for a scenario.
            </summary>
            <param name="value">The scenario value.</param>
            <returns>Returns true if it is valid.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.Equals(System.Object)">
            <summary>Determine whether two scenarios are equal.
            Scenarios are equal if both their probability and value are equal.
            </summary>
            <param name="obj">object to compare to</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.op_Equality(Microsoft.SolverFoundation.Services.Scenario,Microsoft.SolverFoundation.Services.Scenario)">
            <summary>Determine whether two scenarios are equal.
            Scenarios are equal if both their probability and value are equal.
            </summary>
            <param name="first">First scenario</param>
            <param name="second">Second scenario</param>
            <returns>True if equal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.op_Inequality(Microsoft.SolverFoundation.Services.Scenario,Microsoft.SolverFoundation.Services.Scenario)">
            <summary>Determine whether two scenarios are not equal.
            Scenarios are equal if both their probability and value are equal.
            </summary>
            <param name="first">First scenario</param>
            <param name="second">Second scenario</param>
            <returns>True if not equal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Scenario.GetHashCode">
            <summary>Return hash code for the scenario
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateValue.#ctor(System.Int32,System.Int32)">
            <summary>Create a new instance.
            </summary>
            <param name="lowerBound">Lower bound (inclusive).</param>
            <param name="upperBound">Upper bound (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateValue.ScenariosCount">
            <summary> The number of possible realizations.
            </summary>
            <remarks> Int32.MaxValue for continuous distributions.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateValue.Scenarios">
            <summary> All possible scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateValue.ScenariosCount">
            <summary> The number of possible realizations.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateValue.Scenarios">
            <summary> All possible scenarios.
            </summary>
            <remarks>The scenarios are in the order of 0, numberOfTrials, 1, numberOfTrials - 1, and so on</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalUnivariateValue.ToString">
            <summary> Returns a string representation of the distribution.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.UnivariateDistribution">
            <summary> A probability distribution of one random variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution.SampleDouble(System.Double[])">
            <summary> Sample the distribution.
            </summary>
            <param name="randomNumbers">uniform random numbers needed for sampling</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution.SampleDouble(System.Func{System.Double})">
            <summary>Sample the distribution, using a delegate for retrieving unifom numbers
            </summary>
            <param name="generateUniformNumber">Delegate for getting uniform numbers</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
            <remarks>The kurtosis coefficient is sometimes shifted by 3 to make the normal value 0.  This method
            returns the unshifted value.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.RandomNumberNeeded">
            <summary>
            How many random numbers (in interval [0,1]) the distribution needs in order
            to generate a random number from the distribution.
            (Default is 1.)
            -1 is the value for a dynamic (not a priori known) number 
            of random numbers needed
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UnivariateDistribution.SupportsLatinHypercube">
            <summary>Can the distribution be sampled with LHC 
            Default is that only distribution that needs exactly one uniform 
            random number can be sampled with LHC
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.UnivariateDistribution`1">
            <summary> A univariate distribution whose sampled values are of a specified type.
            </summary>
            <typeparam name="TotalOrder">The type for sampled values.</typeparam>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.Density(`0)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.CumulativeDensity(`0)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
            <param name="probability">The probability.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.Sample(System.Double[])">
            <summary> A pseudorandom sample drawn, with replacement, from the population.
            </summary>
            <remarks>Default implementation is to use Quantile (inverse CDF for sampling) using the first
            random number. This is the inverse transform technique
            </remarks>
            <param name="randomNumbers">A list of values needed to generate the sample.</param>
            <returns>The sampled value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.SampleDouble(System.Double[])">
            <summary> Samples from the distribution and returns the result as a double.
            </summary>
            <param name="randomNumbers">A list of values needed to generate the sample.</param>
            <returns>The sampled value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UnivariateDistribution`1.CheckSampleArgs(System.Double[])">
            <summary>
            Checks arguments for Sample(params double[] randomNumbers) method.
            </summary>
            <param name="randomNumbers">A list of values needed to generate the sample.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution">
            <summary>A normal (Gaussian) distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.#ctor(System.Double,System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="mean">Location</param>
            <param name="standardDeviation">Scale</param>
            REVIEW shahark: Basically standardDeviation should be bigger than 0. We want to allow 0 so a stochastic
            parameter can be switched to a deterministic one easily
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Density(System.Double)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.CumulativeDensity(System.Double)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NormalUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ScenariosDistribution">
            <summary>
            Discrete sceanrios distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosDistribution.Density(System.Double)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosDistribution.CumulativeDensity(System.Double)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenariosDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenariosDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenariosDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenariosDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UniformUnivariateDistribution`1.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.UniformUnivariateDistribution`1.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.#ctor(System.Int32,System.Int32)">
            <summary>Create a new instance.
            </summary>
            <param name="lowerBound">Lower bound (inclusive).</param>
            <param name="upperBound">Upper bound (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Density(System.Int32)">
            <summary>PMF (Probability mass function)
            </summary>
            <param name="x">value (integer number)</param>
            <returns>Probability mass</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.CumulativeDensity(System.Int32)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (integer number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Quantile(System.Double,System.Double)">
            <summary>
            The inverse cumulative distribution.
            </summary>
            <param name="probability"></param>
            <param name="epsilon">Threshold</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Sample(System.Double[])">
            <summary> A pseudorandom sample drawn, with replacement, from the population.
            </summary>
            <remarks>Implementation uses Quantile (inverse CDF for sampling) with the first
            random number. This is the inverse transform technique. It will call it with zero tolerance
            so randomNumbers[0] which is even slightly bigger than the bounds between two number yields the bigger
            one
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DiscreteUniformUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.#ctor(System.Double,System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="lowerBound">Lower bound (inclusive)</param>
            <param name="upperBound">Upper bound (inclusive)</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.Density(System.Double)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.CumulativeDensity(System.Double)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ContinuousUniformUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution">
            <summary>An Exponential distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.#ctor(System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="rate">Rate</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Density(System.Double)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.CumulativeDensity(System.Double)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ExponentialUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution">
            <summary>A geometric distribution.
            <remarks>
            The probability distribution is of the number Y = X - 1 of Bernoulli trials 
            failures before the first success, supported on the set { 0, 1, 2, 3, ... }.
            Note that there is different convention which prefer to define the distribution 
            instead supported on the set {1, 2, 3, ... } as the first successed trial
            </remarks>  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.#ctor(System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="successProbability">Probability for success</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Density(System.Int32)">
            <summary>PMF (Probability mass function)
            </summary>
            <param name="x">value (integer number)</param>
            <returns>Probability mass</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.CumulativeDensity(System.Int32)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.QuantileCore(System.Double)">
            <summary>Returns Quantile without casting to integer 
            called from Quantile and Sample methods
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.QuantileAsInt32(System.Double,System.String)">
            <summary>Checks if double result of quantile can be case to 32 bit integer. 
            If not throw an exception. 
            </summary>
            <param name="result"></param>
            <param name="errorMessage">Different error massage for sampling and quantile</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException"></exception>
            <returns>result converted to 32 bit integer</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.GeometricUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution">
            <summary>A Binomial distribution.
            <remarks>
            Binomial distribution is the discrete probability distribution of the 
            number of successes in a sequence of n Bernoulli trials 
            </remarks>  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.#ctor(System.Int32,System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="numberOfTrials">Number of trials</param>
            <param name="successProbability">Probability for success</param>
            <remarks>If the case of : numberOfTrials * min(successProbability, 1 - successProbability) >= 10 
            the distribution cannot be sampled with Latin hypercube method
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Density(System.Int32)">
            <summary>PMF (Probability mass function)
            </summary>
            <param name="x">value (integer number)</param>
            <returns>Probability mass</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.CumulativeDensity(System.Int32)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
            <remarks>This is linear in numberOfTrials, min(successProbability, 1 - successProbability)
            and probability. May take a long time for distribitions with large numberOfTrials
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.SampleDouble(System.Func{System.Double})">
            <summary>Sample the distribution, using a delegate for retrieving unifom numbers
            </summary>
            <param name="generateUniformNumber">Delegate for getting uniform numbers</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.AcceptanceRejection(System.Func{System.Double})">
            <summary>For large n
            Doesn't seem to be very good for np > 30000
            Algorithm from W. Hormann: "The Generation of Binomial Random Variables"
            </summary>
            <remarks>This is algorithm BTRD (Binomial Transformed Rejection with Decomposition, have nothing
            to do with bender's decomposition)
            </remarks>
            <param name="generateUniformNumber"></param>
            <returns>sampled integer from the distribution</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.MapProbability(System.Double)">
            <summary>When _successProbability is bigger than 1/2 we work with
            1-_successProbability, so we need to take the complementary of probability
            for Qualtile calculation
            </summary>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.MapResult(System.Int32)">
            <summary>When _successProbability is bigger than 1/2 we work with
            1-_successProbability, so we need to map back when having the result
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BinomialUnivariateDistribution.RandomNumberNeeded">
            <summary>
            -1 is the value for a dynamic (not a priori known) number 
            of random numbers needed
            If np is small we return 1 and use the inverse CDF
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution">
            <summary>A log normal distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.#ctor(System.Double,System.Double)">
            <summary> Create a new instance.
            </summary>
            <param name="meanLog">Mean of the variable’s natural logarithm</param>
            <param name="standardDeviationLog">Standard deviation of the variable’s natural logarithm</param>
            REVIEW shahark: Basically standard deviation should be bigger than 0. We want to allow 0 so a stochastic
            parameter can be switched to a deterministic one easily
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Density(System.Double)">
            <summary>PDF (Probability density function)
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability density</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.CumulativeDensity(System.Double)">
            <summary>Compute the cumulative distribution function for the specified value.
            </summary>
            <param name="x">value (Real number)</param>
            <returns>Probability</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Quantile(System.Double)">
            <summary> The inverse cumulative distribution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Mean">
            <summary> The mean.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Variance">
            <summary> The variance (square of the standard deviation).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Skewness">
            <summary> The lopsidedness of the distribution as defined by the third moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.Kurtosis">
            <summary> The measure of the 'skinnyness' of the distribution,
            defined by the fourth moment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.MeanLog">
            <summary>Mean of the variable’s natural logarithm
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LogNormalUnivariateDistribution.StdLog">
            <summary>Standard deviation of the variable’s natural logarithm
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DistributionUtilities">
            <summary>
            Utility methods for calculating PDFs etc.
            </summary>
            <remarks>
            These routines are good enough for the distributions but the need some tuning if
            very accurate results are needed.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.ValidateProbability(System.Double)">
            <summary>Determines if a value is a valid probability.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.ValidateCumulativeDensityValue(System.Double)">
            <summary>Determines if a value is a valid input to CumulativeDensity.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.IsNonzeroProbability(Microsoft.SolverFoundation.Common.Rational)">
            <summary>Determines if a value is within the range of valid probability values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.GreaterThanOne(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>Determines if a value exceeds one by more than a tolerance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.LessThanOne(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>Determines if a value is less than one by more than a tolerance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.EqualsOne(Microsoft.SolverFoundation.Common.Rational,System.Double)">
            <summary>Determines if a value is equal to one within a specified tolerance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.StirlingCorrectionTerm(System.Int32)">
            <summary>Correction terms for strinling (Fc)
            </summary>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.Gamma(System.Double)">
            <summary>
            Return the gamma function for x. Consider the more slowly growing LogGamma function instead.
            </summary>
            <remarks>
            Based on Lanczos, C. 1964, SIAM Journal on Numerical Analysis, ser. B, vol. 1, pp. 86–96.
            </remarks>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.LogGamma(System.Double)">
            <summary>
            Return the log of the gamma function for x. Because the gamma function grows so rapidly this is often
            a more useful function than the gamma function.
            </summary>
            <remarks>
            Based on Lanczos, C. 1964, SIAM Journal on Numerical Analysis, ser. B, vol. 1, pp. 86–96.
            </remarks>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.ErrorFunction(System.Double)">
            <summary>
            The error function erf.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.IncompleteGamma(System.Double,System.Double)">
            <summary>
            The incomplete gamma function (regularized gamma functions, P(a, x)).
            </summary>
            <param name="a"></param>
            <param name="x"></param>
            <returns></returns>
            <remarks>P(a, x) = LowerIncompleteGammaFunction(a, x)/ Gamma(a) </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.InverseCumulativeStandardNormal(System.Double)">
            <summary>
            The probit function or inverse cummulative of standard (mean 0, variance 1)
            normal density function.
            </summary>
            <param name="probability"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributionUtilities.CumulativeDensityStandardNormal(System.Double)">
            <summary>Cummulative density of standard (mean 0, variance 1)
            normal distribution.
            </summary>
            <param name="x">real number</param>
            <returns>commulative probability</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Domain">
            <summary> A Domain represents the set of possible values for a Decision or Parameter.
            </summary>
            <remarks>
            Domains determine the range of acceptable values for a Decision or Parameter. A Domain
            instance is created by calling a static method on the Domain class. Frequently
            used domains include Domain.Real and Domain.Integer. The domains of decisions and 
            parameters are considered in determining which solvers may be used to solve a model.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.RealRange(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            A domain representing a real value in a restricted range
            </summary>
            <param name="min">The minimum value in the range.</param>
            <param name="max">The maximum value in the range.</param>
            <returns>A domain representing the range.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.IntegerRange(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            A domain representing an integer value in a restricted range.
            </summary>
            <param name="min">The minimum value in the range.</param>
            <param name="max">The maximum value in the range.</param>
            <returns>A domain representing the range.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.Set(System.Int32[])">
            <summary>A domain representing values from a discrete set.
            </summary>
            <param name="values">The values in the set.</param>
            <returns>A domain representing the discrete set.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.Set(Microsoft.SolverFoundation.Common.Rational[])">
            <summary>A domain representing values from a discrete set.
            </summary>
            <param name="values">The values in the set.</param>
            <returns>A domain representing the discrete set.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.Enum(System.String[])">
            <summary>
            A domain representing a choice between a group of strings
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.GetOrdinal(System.String)">
            <summary>
            Looks up the index of a string in an enum domain.
            
            This is a helper function which is used internally. It is not intended to be called by user code.
            </summary>
            <param name="value">The string to look up.</param>
            <returns>The index.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.#ctor(Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean,System.String[],Microsoft.SolverFoundation.Common.Rational[],System.Boolean)">
            <summary>
            Construct a new domain. See comments on properties of this class for restrictions on parameters.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.TryCastToDouble(System.Object,System.Double@)">
            <summary>
            Try to convert a boxed builtin value to a double using a lossless conversion.
            </summary>
            <param name="value">A boxed value.</param>
            <param name="dblValue">The converted double.</param>
            <returns>True if the conversion succeeded. False if the input was not a boxed value, or could not be converted losslessly.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.IsValidValue(System.Object)">
            <summary>
            Tests whether a boxed value is a member of this domain. For enumerated domains, tests whether
            the value is a member of the underlying (numeric) domain, rather than a member of the possible strings.
            
            REVIEW shahark: The data check is done seperatly for the Random Parameters. The value here is the just the IDistributedValue
            itself and not each scenario (for example when dealing with scenarios)
            There should be domain type that fits here, then the check can be done
            </summary>
            <param name="value">The value to test.</param>
            <returns>True if the value is a member of the domain.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.IsValidDistributedValue">
            <summary>
            Always returns true, the data check is done in the IDistributedValue impl
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.IsValidStringValue">
            <summary>
            Tests whether a string is a member of this domain. For enumerated domains, returns false, because a
            string is not a member of the underlying (numeric) domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Domain.IsValidDoubleValue(System.Double)">
            <summary>
            Tests whether a number is a member of this domain. For enumerated domains, tests whether
            the value is a member of the underlying (numeric) domain.
            </summary>
            <param name="dblValue"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Real">
            <summary>
            A domain representing any real value
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.DistributedValue">
            <summary>
            A domain representing any DistributedValue
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.RealNonnegative">
            <summary>
            A domain representing any positive real value or zero
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Integer">
            <summary>
            A domain representing any integer value
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.IntegerNonnegative">
            <summary>
            A domain representing any positive integer or zero
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Boolean">
            <summary>
            A domain representing a true or false value
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Any">
            <summary>
            A domain representing any number or string
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Probability">
            <summary>
            A domain representing probability
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.MinValue">
            <summary>
            The minimum possible value of an element of the domain. Double.NegativeInfinity for no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.MaxValue">
            <summary>
            The maximum possible value of an element of the domain. Double.PositiveInfinity for no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.IntRestricted">
            <summary>
            If true, elements of the domain must be exact integers (that is, (int)x == x).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.EnumeratedNames">
            <summary>
            If non-null, an array of strings which are used in place of numbers when inputting/outputting values of this domain.
            If set then IntRestricted must be true, and MinValue and MaxValue must be legal indexes into the array.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.Name">
            <summary>
            If non-null, the name of this domain.  Otherwise a default name based on the domain's other properties will be used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Domain.IsNumeric">
            <summary>
            Returns true if this value is numeric or boolean.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NumericRangeDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NumericRangeDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NumericSetDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NumericSetDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DistributedDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DistributedDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.EnumDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.EnumDomain.GetOrdinal(System.String)">
            <summary>
            Looks up the index of a string in an enum domain.
            
            This is a helper function which is used internally. It is not intended to be called by user code.
            </summary>
            <param name="value">The string to look up.</param>
            <returns>The index.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.EnumDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BooleanDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.BooleanDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.AnyDomain.ToString">
            <summary>
            Returns a string resembling the OML syntax which constructs this domain. Not guaranteed to parse as OML.
            </summary>
            <returns>A string.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.AnyDomain.ValueClass">
            <summary>
            The type which a value that is an element of this domain can take.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Model,System.Action{Microsoft.SolverFoundation.Services.ProbedDecisionHandle},System.Action{Microsoft.SolverFoundation.Services.ProbedDecisionHandle,Microsoft.SolverFoundation.Common.Rational,System.Boolean})">
            <summary>
            Creates a domain narrowing worker. The domain narrowing worker 'owns' the model while it exists; the model shouldn't
            be changed. Might implement a check to prevent changes while domain narrowing is ongoing. The model can be released
            by calling Dispose() explicitly.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.AddProbedDecision(Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Takes a decision and creates a corresponding ProbedDecisionHandle which is used for domain narrowing.
            The decision must be unindexed.
            </summary>
            <param name="decision"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.FixProbedDecision(Microsoft.SolverFoundation.Services.ProbedDecisionHandle,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Marks a UI decision as being fixed to a specific value. If the decision is an enum, the input should
            be on the underlying numeric range. If called on an already-fixed decision, overwrites the previous fixed value.
            </summary>
            <param name="handle"></param>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.UnfixProbedDecision(Microsoft.SolverFoundation.Services.ProbedDecisionHandle)">
            <summary>
            Undoes the result of FixUIDecision so that a decision is once again free to vary.
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.DoProbe(System.Func{System.Boolean},Microsoft.SolverFoundation.Services.Directive[])">
            <summary>
            Does domain probing. Each time the values of a probed decision changes, or a probed decision gets final values,
            calls _domainConsumerHook with that ProbedDecisionHandle. Returns when probing is complete.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.ResetValues">
            <summary>
            Clear the possible values of all probed decisions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.ResetDomains">
            <summary>
            Set the domains of all variables in the solver to the base (either the full domain if unfixed, or the fixed value).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.CreateTask(Microsoft.SolverFoundation.Services.ConstraintProgrammingDirective)">
            <summary>
            Bind the data to the model, creates the task and initiates the solver reference
            </summary>
            <param name="directive"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.FindWinningDirective(System.Func{System.Boolean},Microsoft.SolverFoundation.Services.Directive[])">
            <summary>
            Find the winning directive from the given directives and ensure no local search algorithm is used
            </summary>
            <return>A ConstraintProgrammingDirective instance. Either a default one or a winning one. Will never be null.</return>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.TryAllValues(Microsoft.SolverFoundation.Services.DomainProbingWorker.ProbedDecisionData,System.Func{System.Boolean})">
            <summary>
            Take a probed decision which isn't fixed and try every value which isn't already known to be good. After doing that,
            we know that we have found every possible value of that decision for which a feasible solution exists.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.SetBaseDomainAfterPresolve">
            <summary> Set base domains of probed decisions after presolve. Certain values may have been removed from presolve. Need to fire events for these values.
            </summary>
            <remarks>This method is called only when Presolve does not find that the model is infeasible</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.Presolve(System.Func{System.Boolean})">
            <summary> Perform a special round of propagation to eliminate conflicting values from domains of bound decisions
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.Solve(System.Func{System.Boolean})">
            <summary>
            Solve with the solver domains as currently set, and add the results to the appropriate value sets
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.RegisterSolutionValues(Microsoft.SolverFoundation.Services.SolverQuality,Microsoft.SolverFoundation.Services.SolverContext.TaskSummary)">
            <summary>
            Add all values from a solution to the appropriate value sets
            </summary>
            <param name="quality"></param>
            <param name="summary"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.RegisterValue(Microsoft.SolverFoundation.Services.DomainProbingWorker.ProbedDecisionData,Microsoft.SolverFoundation.Services.SolverContext.TaskSummary)">
            <summary>
            Get the current value of a UI decision from the solver and add it to the value set
            </summary>
            <param name="resultProbedDecision"></param>
            <param name="summary"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.SetToBaseDomain(Microsoft.SolverFoundation.Services.DomainProbingWorker.ProbedDecisionData)">
            <summary>
            Set the domain of a probed decision in the solver to its full domain if it's unfixed, or its fixed value if it's fixed.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.GetDecision(Microsoft.SolverFoundation.Services.ProbedDecisionHandle)">
            <summary>
            Returns the Decision associated with a ProbedDecisionHandle
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.GetValues(Microsoft.SolverFoundation.Services.ProbedDecisionHandle)">
            <summary>
            Gets the current possible set of values of a ProbedDecisionHandle
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DomainProbingWorker.FinishedNarrowing(Microsoft.SolverFoundation.Services.ProbedDecisionHandle)">
            <summary>
            Returns true if the current set of values for a ProbedDecisionHandle is final
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DomainProbingWorker.Abort">
            <summary>
            Can be set to abort DoNarrowing()
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.GoalKind">
            <summary>Maximize or minimize.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.GoalKind.Maximize">
            <summary>
            Maximize the goal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.GoalKind.Minimize">
            <summary>
            Minimize the goal.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Goal">
            <summary> A Goal encapsulates a term and its role as a goal in the model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Goal._value">
            <summary>
            The current value of the goal. Unspecified if the model has not been solved.
            Because the model may be transformed prior to solving, we need to be careful that the goal gets the right value.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Goal.#ctor(Microsoft.SolverFoundation.Services.SolverContext,System.String,Microsoft.SolverFoundation.Services.GoalKind,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Construct a new goal object
            </summary>
            <param name="name">The name of the goal. Must be unique within a model.</param>
            <param name="direction">GoalKind.Minimize or GoalKind.Maximize</param>
            
            <param name="term">The term encapsulated by the goal</param>
            <param name="context">Solver context</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Goal.Microsoft#SolverFoundation#Services#IVariable#SetValue(Microsoft.SolverFoundation.Common.Rational,System.Object[])">
            <summary>
            Save the value of the goal. The value given should be the value as specified by the goal's expression.
            </summary>
            <param name="value">The value</param>
            <param name="indexes">An empty array</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Goal.ToInt32">
            <summary>
            Value of the goal as an integer
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Goal.ToDouble">
            <summary>
            Value of the goal as a double
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Goal.ToString">
            <summary>
            Gets a string representation of the value of this goal.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Kind">
            <summary>
            Direction of goal (minimization or maximization)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Name">
            <summary>
            The name of the goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Expression">
            <summary>The goal expression as a System.String.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Description">
            <summary>
            A comment.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Enabled">
            <summary>
            Whether to enable the goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Order">
            <summary>
            The order of the goal (lower numbers mean higher priority).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Goal.Direction">
            <summary>
            GoalKind.Minimize or GoalKind.Maximize
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearModel">
            <summary>The representation of an MILP problem in terms of rows and variables.
            </summary>
            <remarks>
            Rows and Variables are both identified by a key.
            A key can be any object. Rows and variables are also accessed via an index.
            Note that indices are not necessarily contiguous!
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RowVariableModel">
            <summary>
            RowVariableModel is the implementation of a basic optimization model 
            consisting of decision variables and rows.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._ridLim">
            <summary> Number of rows
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._vidLim">
            <summary> Number of variables + rows
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.m_cvidInt">
            <summary> Number of integer variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.m_mpkeyvid">
            <summary> Map from key to variable index
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpvidvi">
            <summary> Map from variable index to VarInfo
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpvidnumLo">
            <summary> Map from variable index to lower bound
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpvidnumHi">
            <summary> Map from variable index to upper bound
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpvidnum">
            <summary> Map from variable index to current value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpvidflags">
            <summary> Map from variable index to flags
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel._mpridvid">
            <summary> Map from row index to variable index
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>
            The IEqualityComparer's are for the internal dictionaries from key to row/variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.HasFlag(System.Int32,Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags)">
            <summary>
            M4 internal
            </summary>
            <param name="vid"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetFlag(System.Int32,Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags)">
            <summary>
            M4 internal
            </summary>
            <param name="vid"></param>
            <param name="flag"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.ClearFlag(System.Int32,Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags)">
            <summary>
            M4 internal
            </summary>
            <param name="vid"></param>
            <param name="flag"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.AssignVidFlag(System.Int32,Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags,System.Boolean,System.Int32@)">
            <summary>
            M4 internal
            </summary>
            <param name="vid"></param>
            <param name="flag"></param>
            <param name="fSet"></param>
            <param name="cvid"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key.
            </summary>
            <param name="key">the key value </param>
            <param name="vid">the variable index </param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown.
            </summary>
            <param name="key"></param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown.
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.AddRow(System.Object,System.Int32@)">
            <summary>
            If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.IsRow(System.Int32)">
            <summary>
            Validate if the index is a row index.
            </summary>
            <param name="vid">row index</param>
            <returns>true if a row otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetIgnoreBounds(System.Int32,System.Boolean)">
            <summary>
            Adjusts whether the bounds of a vid should be respected or ignored during solving. 
            By default, bounds are respected.
            </summary>
            <param name="vid">a variable index</param>
            <param name="ignore">whether to ignore the bounds</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetIgnoreBounds(System.Int32)">
            <summary>
            Get the flag whether is bound is ignored.
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if bounds are ignored, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the bounds for a row.
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite value for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            now the ArgumentException is thrown for this case.  
            </summary>
            <param name="vid">the variable index </param>
            <param name="lower">lower bound</param>
            <param name="upper">upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the lower bound of the variable. 
            </summary>
            <param name="vid">the variable index </param>
            <param name="lower">lower bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the upper bound of the variable. 
            </summary>
            <param name="vid">the variable index</param>
            <param name="upper">the upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Return the bounds for the variable. 
            </summary>
            <param name="vid">the variable index</param>
            <param name="lower">the lower bound returned</param>
            <param name="upper">the upper bound returned</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            </summary>
            <param name="key"> Variable key </param>
            <param name="vid">variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the value for the specified vid.
            The default value for a vid is Indeterminate. An ILinearModel can be used to represent not just a linear model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value, represented as a Rational, and a basis status, represented as a boolean. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            In particular, invoking the Solve method of the SimplexSolver class updates the values and basis status appropriately.
            Some other solvers may ignore this initial state for rows and even for variables.
            </summary>
            <param name="vid">a variable index</param>
            <param name="value">current value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used to fetch solver results.
            </summary>
            <param name="vid">a variable index</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable. 
            </summary>
            <param name="vid">a variable index </param>
            <param name="integer">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to set, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableModel.GetProperty(System.String,System.Int32)">
            <summary>Get a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to get, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <returns>The value.</returns>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.KeyCount">
            <summary>
            The number of keys in the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.Keys">
            <summary>
            Return the variable and row key collection.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.Indices">
            <summary>
            Return the variable index collection.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.RowKeys">
            <summary>
            Return the row key collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.RowIndices">
            <summary>
            Return the row index collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.RowCount">
            <summary>
            The number of rows in the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.VariableCount">
            <summary>
            Return the variable count .
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.VariableKeys">
            <summary>
            Return the variable key collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.VariableIndices">
            <summary>
            Return the variable index collection.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.IntegerIndexCount">
            <summary>
            The number of integer variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableModel.IsMipModel">
            <summary> Return true if the model is mip, otherwise false.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags">
            <summary>
            variable type flags 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags.Integer">
            <summary>
            integer variable type 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags.Basic">
            <summary>
            Basic variable type 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags.IgnoreBounds">
            <summary>
            variable without bounds ignored
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowVariableModel.VidFlags.Conic">
            <summary>
            Conic variable type
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel.m_cvidBasic">
            <summary> Number of variables labeled as "basic"
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._matModel">
            <summary> The complete coefficient matrix, including objective(s) and
                      a variable for each row. Implicitly A.x = 0, where A is _matSrc,
                      the dot indicates matrix product, and x is the vector of variables
                      (user and slack).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._qpModel">
            <summary> This is a CoefMatrix to record quadratic Coef
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel.m_qpRowVar">
            <summary> This remembers which goal variable has the QP form
                      Right now, we only support a single goal count 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._mpvidQid">
            <summary> This maps vid to Qid, if zero means not used in the quadratic.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._mpqidVid">
            <summary> This maps qid to vid, if zero means not used in the quadratic.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._qidLim">
            <summary> number of quadratic coefficient
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._mpvidgoal">
            <summary>  The mapping from vid to goal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._sos1Rows">
            <summary> A list of SOS1 reference row
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.LinearModel._sos2Rows">
            <summary> A list of SOS2 reference row
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>
            The IEqualityComparer's are for the internal dictionaries from key to row/variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.IsQuadraticVariable(System.Int32)">
            <summary> Return true if the variable referenced by vid is part of a quadratic row, otherwise false
            </summary>
            <param name="vidVar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.InitModel(System.Collections.Generic.IEqualityComparer{System.Object},System.Int32,System.Int32,System.Int32)">
            <summary> Allocate clean data structures for a new model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.LoadLinearModel(Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary> Inject the given LinearModel into this model, removing all previous information.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.IsRowRemoved(System.Int32)">
            <summary>
            Test if a row has been deleted.
            </summary>
            <param name="vidRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.RemoveRow(System.Int32)">
            <summary>
            Delete the row represented by vidRow.
            </summary>
            <param name="vidRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.AddRow(System.Object,System.Int32@)">
            <summary>
            If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.AddRow(System.Object,Microsoft.SolverFoundation.Services.SpecialOrderedSetType,System.Int32@)">
            <summary> Add a reference row for a SOS set. Each SOS set has one reference row.
            </summary>
            <param name="key">a SOS key</param>
            <param name="sos">type of SOS</param>
            <param name="vidRow">the vid of the reference row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetSpecialOrderedSetTypeRowIndexes(Microsoft.SolverFoundation.Services.SpecialOrderedSetType)">
            <summary> Return a list of SOS1 or SOS2 row indexes.
            </summary>
            <param name="sosType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.SetBasic(System.Int32,System.Boolean)">
            <summary>
            The SetBasic method sets the basis status for a variable. The default basis status for a variable is false. 
            The SimplexSolver class updates these flags after a solve attempt.
            </summary>
            <param name="vid">a variable index</param>
            <param name="fBasic">whether set it to a basic variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetBasic(System.Int32)">
            <summary>
            Get the basis status for this variable.
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is a basic variable. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetValueState(System.Int32)">
            <summary>
            Get the value state of this variable. 
            </summary>
            <param name="vid">a variable index</param>
            <returns>variable state</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.IsSosRow(System.Int32,Microsoft.SolverFoundation.Services.SpecialOrderedSetType)">
            <summary> check if the row is SOS row
            </summary>
            <param name="vidRow">assumed to be vid of a row</param>
            <param name="sosType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.SetCoefficient(System.Int32,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set the coefficient of the A matrix in the linear model. If num is zero, the entry is removed. 
            </summary>
            <remarks>Coefficient cannot be zero for a row of special ordered set type 2</remarks>
            <param name="vidRow">a row id </param>
            <param name="vidVar">a column/variable id</param>
            <param name="num">a value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.SetCoefficient(System.Int32,Microsoft.SolverFoundation.Common.Rational,System.Int32,System.Int32)">
            <summary>
            Set the coefficient of the Q matrix on the objective row. If num is zero, the entry is removed. 
            This is used for quadratic terms on the objective row.
            </summary>
            <param name="vidRow">a goal row</param>
            <param name="num">a value </param>
            <param name="vidVar1">a column/variable id</param>
            <param name="vidVar2">another column/variable id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetCoefficient(System.Int32,System.Int32)">
            <summary>
            Return the coefficient of the A matrix in the linear model.
            </summary>
            <param name="vidRow">a row id</param>
            <param name="vidVar">a column/variable id</param>
            <returns>a coefficient value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetCoefficient(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the coefficient of the Q matrix on the objective row.
            </summary>
            <param name="goalRow">a goal row</param>
            <param name="vidVar1">a column/variable id</param>
            <param name="vidVar2">another column/variable id</param>
            <returns>a coefficient value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetRowEntryCount(System.Int32)">
            <summary>
            Return the number of non-zero coefficients for the given row index
            </summary>
            <param name="vid">a row id</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetRowEntries(System.Int32)">
            <summary>
            Return a collection of non-zero variable entries
            </summary>
            <param name="vidRow"></param>
            <returns>the variable collection</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetRowValues(System.Int32)">
            <summary> Get the entries for this row, including vid, key, and coeff value.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetRowQuadraticEntries(System.Int32)">
            <summary>
            Return a collection of non-zero variable entries on the
            quadratic row.
            </summary>
            <param name="vidRow"></param>
            <returns>the variable collection</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetColValues(System.Int32)">
            <summary> Get column entries not including entries in goal rows.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetVariableEntryCount(System.Int32)">
            <summary> Return the number of non-zero coefficients for the given variable/column index.
            </summary>
            <param name="vid">a variable index</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetVariableEntries(System.Int32)">
            <summary> Return a collection of non-zero column entries, including any goal-row entries.
            </summary>
            <param name="vidVar">a variable index</param>
            <returns>number of non-zero entries</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Mark a row as a goal row.
            </summary>
            <param name="vid">a row id</param>
            <param name="pri">the priority of a goal</param>
            <param name="fMinimize">whether to minimize the goal row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.ClearGoals">
            <summary>
            Clear all the goals. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row.
            </summary>
            <param name="vid">a row id</param>
            <returns>true if the goal is removed. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row. 
            </summary>
            <param name="vid">a row id</param>
            <returns>true if this a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.ILinearGoal@)">
            <summary>
            Check if a row id is a goal. If true, return the goal entry.
            </summary>
            <param name="vid">a row id</param>
            <param name="goal">return the goal entry</param>
            <returns>true if a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal.
            </summary>
            <param name="vid">a variable index</param>
            <returns>A goal entry. Null if not a goal row</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModel.Preallocate(System.Int32,System.Int32,System.Int32)">
            <summary>Preallocate storage for the model.
            </summary>
            <param name="cols"></param>
            <param name="rows"></param>
            <param name="nonzeroes"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.IsQuadraticModel">
            <summary> Return true if the model is quadratic, otherwise false.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.IsSpecialOrderedSet">
            <summary> Is the linear model SOS?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.RowIndices">
            <summary>
            Return the row index collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.CoefficientCount">
            <summary>
            The number of non-zero coefficients. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.GoalCount">
            <summary>
            The number of goals in this linear model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearModel.Goals">
            <summary>
            Return the goal collection of this linear model. 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearTask">
            <summary>
            This is the Linear task to be used for solving models. 
            It has integer keys.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Task.CreateTask(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Directive,Microsoft.SolverFoundation.Services.ModelGenerator,System.Boolean)">
            <summary>
            The main factory call for creating task
            </summary>
            <param name="context"></param>
            <param name="directive"></param>
            <param name="generator"></param>
            <param name="mpsWrite"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Task.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolverParameters,Microsoft.SolverFoundation.Services.Directive)">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Task.GetSolverProperty(System.String,Microsoft.SolverFoundation.Services.Decision,System.Object[])">
            <summary>Get the value of a model- or decision-level property.
            </summary>
            <param name="property">The name of the property to get, see SolverProperties.</param>
            <param name="decision">The decision. In the case of a solver-level property this argument should be null.</param>
            <param name="indexes">The decision indexes. In the case of a solver-level property this argument should be an empty array.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Task.SetSolverProperty(System.String,Microsoft.SolverFoundation.Services.Decision,System.Object[],System.Object)">
            <summary>Set the value of a model- or decision-level property.
            </summary>
            <param name="property">The name of the property to get, see SolverProperties.</param>
            <param name="decision">The decision. In the case of a solver-level property this argument should be null.</param>
            <param name="indexes">The decision indexes. In the case of a solver-level property this argument should be an empty array.</param>
            <param name="value">The value.</param>
            <returns>The value.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Task.TermWithContext">
            <summary>
            This class serves to hide the semantics of Term.EvaluationContext from users. The effective evaluation
            context of a TermWithContext is immutable, even after exit from a CallForEachInput.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Task.TermWithContext.#ctor(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term.EvaluationContext)">
            <summary>
            Create a new TermWithContext
            </summary>
            <param name="term"></param>
            <param name="context">The initial evaluation context. It must not change during the lifetime of the TermWithContext.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearTask.IsMipModel">
            <summary>
            This is called the Task creation process.
            It should be ommited when (sfs) model analysis is on.
            Even before that, there can be a parameter says if Mip is allowed
            just like we have for QP, so filling the model with throw
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.ILinearSolver,Microsoft.SolverFoundation.Services.ISolverParameters,Microsoft.SolverFoundation.Services.Directive)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.UpdateGoal(Microsoft.SolverFoundation.Services.Goal,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Add the new second stage decisions with their coefficients to the goal, and update the first stage decisions coefficients
            </summary>
            <param name="goal">the only goal</param>
            <param name="id">the goal id</param>
            <param name="currentScenarioProbability"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.AddGoal(Microsoft.SolverFoundation.Services.Goal,System.Int32)">
            <summary>
            REVIEW shahark: might abstract that more, as just one line is different from the base impl
            </summary>
            <param name="goal">the only goal</param>
            <param name="priority">always 0</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.AddGoal(Microsoft.SolverFoundation.Services.Goal,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Called by the model generator to add a goal
            </summary>
            <param name="goal"></param>
            <param name="priority"></param>
            <param name="currentProbability">When adding goal to master this will be 1
            when setting the goals of the slaves this will be the actual probability of the scenario</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.IsDecision(Microsoft.SolverFoundation.Services.Term)">
            <summary>Stochastic considers RecourseDecision as well as Decision.
            </summary>
            <param name="term"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.GetDecision(Microsoft.SolverFoundation.Services.Task.TermWithContext)">
            <summary>Get a Decision, taking into account RecourseDecisions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.GetDecision(Microsoft.SolverFoundation.Services.Task.TermWithContext,Microsoft.SolverFoundation.Services.IndexTerm)">
            <summary>Get a Decision, taking into account RecourseDecisions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearStochasticTask.Init(Microsoft.SolverFoundation.Services.StochasticModelGenerator,System.Int32)">
            <summary>Called by the model generator before starting to populate the task
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearStochasticTask.StochasticDirective">
            <summary>Stochastic directive (if any).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearStochasticTask.NonzeroCount">
            <summary>NonzeroCount of the linear model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearStochasticTask.RowCount">
            <summary>RowCount of the linear model
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearStochasticTask.TaskType">
            <summary>The type of stochastic task.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Model">
            <summary> Model allows construction, elaboration, and modification of models with
                      arithmetic and logical expressions and constraints expressed over domains
                      of boolean, integer, and real variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.CreateSubModel(System.String)">
            <summary>
            Construct a submodel inside the current Model
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveSubModel(Microsoft.SolverFoundation.Services.Model)">
            <summary>
            Remove a submodel from the current Model.
            </summary>
            <returns>Returns null if the given submodel does not exist in current Model,
            otherwise the given submodel.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.CreateInstance(System.String)">
            <summary>
            Create an instance of this Model.
            </summary>
            <param name="name">The name of the SubmodelInstance to be created.</param>
            <returns>An instantiation of the current Model. This instantiation inherits all Decisions, Constraints, and Goals
            defined in this Model</returns>
            <remarks>The root model created by SolverContext.CreateModel() cannot call CreateInstance</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.CreateInstance(System.String,System.String,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.SubmodelInstance)">
            <summary>
            Create an instance of this model and add the instance to the given model
            </summary>
            <param name="baseName">The base name for the instance</param>
            <param name="name">The name of the instance</param>
            <param name="model">To which the instance will be added</param>
            <param name="instance">The instance to which this newly created one is a member</param>
            <returns>An instance of this model</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ReplaceSet(Microsoft.SolverFoundation.Services.Set,Microsoft.SolverFoundation.Services.Set)">
            <summary>
            Replace a Set with another Set everywhere it appears in the model
            </summary>
            <param name="oldSet"></param>
            <param name="newSet"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddParameter(Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>
            Add a Random parameter to the model (for stochastic programming).
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the parameter has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddParameter(Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Add a parameter to the model.
            </summary>
            <param name="parameter">The parameter to add.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the parameter has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddParameters(Microsoft.SolverFoundation.Services.Parameter[])">
            <summary>
            Add a group of parameters to the model.
            </summary>
            <param name="parameters">The parameters to add.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the parameter has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddParameters(Microsoft.SolverFoundation.Services.RandomParameter[])">
            <summary>
            Add a group of random parameters to the model (for stochastic programming).
            </summary>
            <param name="parameters">The RandomParameters to add.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the parameter has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ReplaceParameter(Microsoft.SolverFoundation.Services.Parameter,Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Replace a Parameter with another Parameter everywhere it appears in the model
            </summary>
            <param name="oldParameter"></param>
            <param name="newParameter"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ReplaceParameter(Microsoft.SolverFoundation.Services.RandomParameter,Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>
            Replace a Parameter with another Parameter everywhere it appears in the model
            </summary>
            <param name="oldParameter"></param>
            <param name="newParameter"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveParameter(Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Remove an unused Parameter from the model
            </summary>
            <param name="parameter">The parameter to remove.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveParameter(Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>
            Remove an unused RandomParameter from the model.
            </summary>
            <param name="parameter">The parameter to remove.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddTuples(Microsoft.SolverFoundation.Services.Tuples[])">
            <summary>
            Add a group of tuples to the model.
            </summary>
            <param name="tuples">The tuples to add.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddTuple(Microsoft.SolverFoundation.Services.Tuples)">
            <summary>
            Add a tuples object to the model.
            </summary>
            <param name="tuple">The tuple to add.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddDecision(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>
            Add a RecourseDecision to the model (for stochastic programming).
            </summary>
            <param name="decision">The RecourseDecision to add.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the decision has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddDecision(Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Add a decision to the model.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the decision has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddDecisions(Microsoft.SolverFoundation.Services.Decision[])">
            <summary>
            Add a group of decisions to the model.
            </summary>
            <param name="decisions">The decisions to add.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the decision has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddDecisions(Microsoft.SolverFoundation.Services.RecourseDecision[])">
            <summary>
            Add a group of RecourseDecisions to the model (for stochastic programming)
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the decision has already been added to a different model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ReplaceDecision(Microsoft.SolverFoundation.Services.Decision,Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Replace a Decision with another Decision everywhere it appears in the model
            </summary>
            <param name="oldDecision"></param>
            <param name="newDecision"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ReplaceDecision(Microsoft.SolverFoundation.Services.RecourseDecision,Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>
            Replace a Decision with another Decision everywhere it appears in the model
            </summary>
            <param name="oldDecision"></param>
            <param name="newDecision"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveDecision(Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Remove an unused Decision from the model.
            </summary>
            <param name="decision">The decision to remove.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveDecision(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>
            Remove an unused RecourseDecision from the model.
            </summary>
            <param name="decision">The decision to remove.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddConstraint(System.String,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Add a constraint to the model.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the model is invalid.</exception>
            <remarks>
            The term should evaluate to a boolean result.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddConstraint(System.String,System.String)">
            <summary>
            Add a constraint by parsing an OML expression
            </summary>
            <param name="name"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddConstraints(System.String,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Add a group of constraints to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveConstraint(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>
            Remove a constraint from the model.
            </summary>
            <param name="constraint"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddGoal(System.String,Microsoft.SolverFoundation.Services.GoalKind,System.String)">
            <summary>
            Add a goal by parsing an OML expression
            </summary>
            <param name="name"></param>
            <param name="direction"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddGoal(System.String,Microsoft.SolverFoundation.Services.GoalKind,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Add a goal to the model.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if the model is invalid.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AddGoals(System.String,Microsoft.SolverFoundation.Services.GoalKind,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Add a group of goals to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveGoal(Microsoft.SolverFoundation.Services.Goal)">
            <summary>
            Remove a goal from the model
            </summary>
            <param name="goal"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.RemoveGoals(Microsoft.SolverFoundation.Services.Goal[])">
            <summary>
            Remove a group of goals from the model
            </summary>
            <param name="goals"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.VerifyCompatibleInputs(Microsoft.SolverFoundation.Services.Operator,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Verify that either all inputs are numeric, or all inputs are symbols with compatible domains.
            </summary>
            <param name="terms"></param>
            <param name="head"></param>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.VerifyNumericInputs(Microsoft.SolverFoundation.Services.Operator,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Verify that all inputs are numeric (including boolean).
            </summary>
            <param name="terms"></param>
            <param name="head"></param>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.VerifySingleValue(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Verify that the input is a single value (not a ForEach).
            </summary>
            <param name="term"></param>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.BindData(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Read in all late-bound data and construct a substitution table that includes the data in the model.
            </summary>
            <returns>A substitution table which should be applied to the expressions in the model to hydrate them.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sum(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Addition
            </summary>
            <param name="terms"></param>
            <returns>The sum of the inputs.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sum(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Addition
            </summary>
            <param name="term1"></param>
            <param name="term2"></param>
            <returns>The sum of the inputs.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Difference(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Subtraction
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>The difference of the inputs.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Product(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Multiplication
            </summary>
            <param name="terms"></param>
            <returns>The product of the inputs.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Quotient(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Division
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>The quotient of the inputs.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Power(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Exponentiation
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>The first input raised to the power of the second input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Negate(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Arithmetic negation.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The negation of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Abs(Microsoft.SolverFoundation.Services.Term)">
            <summary>Absolute value
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The absolute value of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Min(Microsoft.SolverFoundation.Services.Term[])">
            <summary>The Min operation.
            </summary>
            <param name="terms">The arguments to the operation.</param>
            <returns>The minimum value of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Max(Microsoft.SolverFoundation.Services.Term[])">
            <summary>The Max operation.
            </summary>
            <param name="terms">The arguments to the operation.</param>
            <returns>The minimum value of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Exp(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Exponentiation
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>E raised to the power of the second input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sqrt(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Square root
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The (positive) square root of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Cos(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Cosine.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The cosine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sin(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Sine.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The sine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Tan(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Tangent.
            </summary>
            <param name="term">The input term.</param>
            <returns>The tangent of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ArcCos(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Arc cosine.
            </summary>
            <param name="term">The input term.</param>
            <returns>The arc cosine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ArcSin(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Arc sine.
            </summary>
            <param name="term">The input term.</param>
            <returns>The arc sine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ArcTan(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Arc tangent.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The arc tangent of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Cosh(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Hyperbolic cosine
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The hyperbolic cosine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sinh(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Hyperbolic sine.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The hyperbolic sine of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Tanh(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Hyperbolic tangent.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The hyperbolic tangent of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Log(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Natural logarithm.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The natural log of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Log10(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Base 10 logarithm.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The base 10 log of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Ceiling(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Ceiling.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The ceiling of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Floor(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Floor.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>The floor of the input.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given input.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.If(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Conditional term (trinary).
            </summary>
            <param name="condition">A term representing the condition for the operation.</param>
            <param name="resultTrue">The term representing the evaluation result when the condition is true.</param>
            <param name="resultFalse">The term representing the evaluation result when the condition is false.</param>
            <returns>If the first input is true the second input is returned, otherwise the third input is returned.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Equal(Microsoft.SolverFoundation.Services.Term[])">
            <summary>Equality.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if all the inputs are equal, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AllDifferent(Microsoft.SolverFoundation.Services.Term[])">
            <summary>All-different.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if all the inputs are pairwise different, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Less(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Less-than.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if the inputs are strictly increasing, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.LessEqual(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Less-than-or-equal.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if the inputs are increasing or equal, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Greater(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Greater-than
            </summary>
            <param name="terms"></param>
            <returns>1 if the inputs are strictly decreasing, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.GreaterEqual(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Greater-than-or-equal.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if the inputs are decreasing or equal, 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.And(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Boolean conjunction.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if all the inputs are true (nonzero), 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Or(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Boolean disjunction.
            </summary>
            <param name="terms">The input terms for the operation.</param>
            <returns>1 if any of the inputs is true (nonzero), 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Not(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Boolean negation.
            </summary>
            <param name="term">A term representing the input argument to the operation.</param>
            <returns>1 if the input is false (zero), otherwise 0.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Implies(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Logical implication.
            </summary>
            <param name="antecedent">The antecedent term for the implication.</param>
            <param name="consequence">The consequence term for the implication.</param>
            <returns>1 if the antecedent is false (zero) or the consequence is true (nonzero), 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.AtMostMofN(System.Int32,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            At most m inputs are true.
            </summary>
            <param name="m">The number of number of Terms to be true</param>
            <param name="terms">a query</param>
            <returns>1 if at most m of the inputs are true (nonzero), 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ExactlyMofN(System.Int32,Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Exactly m inputs are true
            </summary>
            <param name="m">number of vars to be true</param>
            <param name="terms">a query</param>
            <returns>1 if exactly m of the inputs are true (nonzero), 0 otherwise.</returns>
            <exception cref="T:System.ArgumentException">Thrown if the operation is not valid for the given inputs.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sos1(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Creates a special ordered sets (type 1) constraint. The input must be of the form
            <code>c1 * d1 + c2 * d2 + ...</code>
            where cN are constants and dN are decisions. None of the constants may be zero, and
            the same constant may not appear twice.
            
            The SOS1 constraint enforces the property that at most one of the given decisions can be nonzero.
            The constants should be associated with the problem in some natural way. The ordering of the constants
            is used by the solver to find a solution more quickly.
            </summary>
            <param name="referenceRow">The input term for the Sos1 operation.</param>
            <returns>A Term representing the Sos constraint.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Sos2(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Creates a special ordered sets reference row. The input must be a constraint of the form
            <code>x == c1 * d1 + c2 * d2 + ...</code>
            where cN are constants and dN are decisions. The order of the equality matters. None of the constants may be zero, and
            the same constant may not appear twice.
            
            The result of this is the equality constraint given, plus additional requirements: the sum of the dN must be 1,
            at most two of the dN can be nonzero, and any nonzero dN must be adjacent in the list produced by sorting the dN by the
            corresponding cN.
            </summary>
            <param name="referenceRow">The input term for the Sos2 operation.</param>
            <returns>A Term representing the Sos constraint.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.Equal(Microsoft.SolverFoundation.Services.Term[],Microsoft.SolverFoundation.Services.Tuples)">
            <summary>
            Tests a tuple for membership in a Tuples.
            </summary>
            <param name="tuple">A tuple Term.</param>
            <param name="tupleList">The Tuples to be tested.</param>
            <returns>Returns a boolean term for the result.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ForEach(Microsoft.SolverFoundation.Services.Set,System.Func{Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term})">
            <summary>
            Expands to one element for each element of the range, as if the function was called for each element.
            The function is only actually called once.
            </summary>
            <param name="range">The Set over which to iterate.</param>
            <param name="values">A function transforming element terms in the Set to result Terms.</param>
            <returns>A Term representing the result.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Model.ForEachWhere(Microsoft.SolverFoundation.Services.Set,System.Func{Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term},System.Func{Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term})">
            <summary>
            Expands to either zero or one element for each element of the range, as if the function was called
            for each element on which the condition is true. The function is only actually called once.
            </summary>
            <param name="range">The Set over which to iterate.</param>
            <param name="values">A function transforming element terms in the Set to result Terms.</param>
            <param name="condition">A function transforming element terms in the Set to 
            boolean Terms. The values function will expand only for elements where the condition function
            is ture.</param>
            <returns>A Term representing the result.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.IsEmpty">
            <summary>
            True if the model has no decisions, parameters, constraints, or goals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.IsRootModel">
            <summary>
            Return whether this model is a root model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.IsRemoved">
            <summary>
            Return whether this submodel is already removed
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Name">
            <summary>The name of the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Decisions">
            <summary>
            All decisions that are defined directly in the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.RecourseDecisions">
            <summary>
            All recourse decisions that are defined directly in the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Parameters">
            <summary>
            All parameters that are defined directly in model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.RandomParameters">
            <summary>
            All random parameters that are defined directly in the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Tuples">
            <summary>
            All Tuples that are defined in model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Goals">
            <summary>
            All goals that are defined directly in the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Submodels">
            <summary>
            All submodels created directly inside this model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.SubmodelInstances">
            <summary>
            All instantiations of submodels created directly inside this model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Constraints">
            <summary>
            All decisions that are defined directly in the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllDecisions">
            <summary>
            All decisions that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllRecourseDecisions">
            <summary>
            All recourse decisions that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllParameters">
            <summary>
            All parameters that are part of model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllRandomParameters">
            <summary>
            All random parameters that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllTuples">
            <summary>
            All Tuples that are part of model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllGoals">
            <summary>
            All goals that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllSubmodelInstances">
            <summary>
            All instantiations of submodels that are part of this model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllConstraints">
            <summary>
            All decisions that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.AllNamedConstants">
            <summary>
            All named constants that are part of the model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.Sets">
            <summary>
            All sets that are defined directly in the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Model.IsValidStochastic">
            <summary>
            This is true for valid stochastic (models with both recourse decisions and random parameters), 
            and false for either non-valid stochastic or non-stochastic models.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelAnalyzer.AnalyzeOperators">
            <summary>Analyzes model operators
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ModelAnalyzer.IsDifferentiable">
            <summary>Is model differentiable
            </summary>
            <remarks>Assme calling to AnalyzeOperators before</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ModelAnalyzer.Operators">
            <summary>Get all Operators of model
            </summary>
            <remarks>Assme calling to AnalyzeOperators before</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ModelAnalyzer.OperatorCollectingVisitor">
            <summary>
            This visitor is used for determine all operations included in the model.
            First bits of the BitArray is for existence of each operator. 
            Last bit (_isDifferentiableBit)is for IfDifferentiable of the model 
            </summary>
            <remarks>return value is not in used</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelAnalyzer.OperatorCollectingVisitor.Visit(Microsoft.SolverFoundation.Services.IterationTerm,System.Collections.BitArray)">
            <summary>
            Should not get here, as i don't care about itarations so i don't
            call it from ForEachTerm and ForEachWhereTerm
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DataBinder">
            <summary>
            This class is responsible of binding the data to a model 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ModelType">
            <summary>
            Not all the combinations are allow
            We need to define each one precisely
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ModelType.Qp">
            <summary>
            Goal is quadratic
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ModelType.Stochastic">
            <summary>
            The following are somewhat orthogonal to the others.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ModelType.Constrained">
            <summary>
            Indicates that the model has (nontrivial) constraints.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ModelType.Bounded">
            <summary>
            Indicates that the model has decisions with finite bounds.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelGenerator.Create(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Model)">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelGenerator.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.ModelType,Microsoft.SolverFoundation.Services.ModelAnalyzer)">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelGenerator.Fill(Microsoft.SolverFoundation.Services.Task)">
            <summary> Fill task with current model.
            This will be called even from task returned by TryGetTask
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ModelGenerator.TryGetTask(Microsoft.SolverFoundation.Services.Task@)">
            <summary> Check to see if there is an available task.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModelWriter.WriteQRow(System.IO.TextWriter,System.Boolean,System.Int32)">
            <summary>Writes a quadratic goal
            </summary>
            <param name="wrt"></param>
            <param name="fDouble"></param>
            <param name="goalIndex"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModelWriter.WriteRow(System.IO.TextWriter,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="wrt"></param>
            <param name="fDouble"></param>
            <param name="vid"></param>
            <param name="linearObjAfterQuadObj">if the goal combines from Quad part and linear part 
            there should be sign to connect them</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MpsLexer">
            <summary>
            Tokenizer for MPS 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsLexer.#ctor(Microsoft.SolverFoundation.Common.NormStr.Pool)">
            <summary>
            constructor
            </summary>
            <param name="pool"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsLexer.LexSource(Microsoft.SolverFoundation.Common.IText,System.Int32,System.Boolean)">
            <summary>
            M4 internal
            </summary>
            <param name="tv"></param>
            <param name="ichInit"></param>
            <param name="fLineStart"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsLexer.CreateImpl(Microsoft.SolverFoundation.Common.Lexer,Microsoft.SolverFoundation.Common.IText,System.Int32,System.Boolean)">
            <summary>
            M4 internal 
            </summary>
            <param name="lex"></param>
            <param name="tv"></param>
            <param name="ichInit"></param>
            <param name="fLineStart"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsLexer.MpsFixedLexerImpl.Dispatch">
            <summary>
            M4 internal
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MpsParser">
            <summary>
            MPS file parser
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.#ctor">
            <summary> A constructor which uses the default lexer 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.#ctor(Microsoft.SolverFoundation.Services.MpsLexer)">
            <summary> constructor 
            </summary>
            <param name="lex"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.ProcessSource(System.String,System.Boolean)">
            <summary> Entry point to invoke the MPS parser 
            </summary>
            <param name="path"> source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.ProcessSource(Microsoft.SolverFoundation.Common.IText,System.Boolean)">
            <summary> Entry point to invoke the MPS parser 
            </summary>
            <param name="text">text source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.ProcessSource(System.String,System.Boolean,Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary> Parse the MPS input into the linear model
            </summary>
            <param name="path"> source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <param name="mod">a linear model</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsParser.ProcessSource(Microsoft.SolverFoundation.Common.IText,System.Boolean,Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary> Parse the MPS input into the linear model
            </summary>
            <param name="text">text source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <param name="mod">a linear model</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SmpsParser">
            <summary>
            As we inherits from MPS parser we have the entry points of ProcessSource
            Those will work just for the cor file, for the time and stoch one there are different methods
            As 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SmpsParser._colsKeys">
            <summary>
            As for now i preffer not changin the work of the core file parser
            I will take the variables from the LinearModel. I will put them to hash
            for efficiency
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SmpsParser._periodsData">
            <summary>
            Encapsulates the data from time file
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SmpsParser._randomParametersSubstitution">
            <summary>
            Encapsulates the data from the stoch file.
            the First Key is the row, so for each row we have a dictionary colkey->randomdata
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.ProcessSmpsSource(System.String,System.Boolean,Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary> Entry point to invoke the MPS parser 
            </summary>
            <param name="path"> source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <param name="model">model to be filled</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.InitiateLexer(Microsoft.SolverFoundation.Common.IText,System.Boolean)">
            <summary>
            REVIEW shahark: consider refactor in MpsParser and use the same code
            </summary>
            <param name="text"></param>
            <param name="fFixedFormat"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.ProcessCoreSource(Microsoft.SolverFoundation.Common.IText,System.Boolean,Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary> Entry point to invoke the core MPS parser 
            </summary>
            <param name="text">text source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <param name="mod">model to be filled</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.ProcessTimeSource(Microsoft.SolverFoundation.Common.IText,System.Boolean)">
            <summary> Entry point to invoke the Time parser 
            </summary>
            <param name="text">text source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.ProcessStochSource(Microsoft.SolverFoundation.Common.IText,System.Boolean)">
            <summary> Entry point to invoke the Stoch parser 
            </summary>
            <param name="text">text source</param>
            <param name="fFixedFormat">whether the MPS is fixed or free format</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.AnalyzeStochasticParameterSection">
            <summary>
            For now just support INDEP section
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.GetKeyForColumn(Microsoft.SolverFoundation.Common.Token,Microsoft.SolverFoundation.Common.Token)">
            <summary>
            In the case of RHS we use the row as the key for the column, as the
            the stochastic value has no real column (decision) which related to ir
            RHS column is recognized as an ident which is not used as variable
            </summary>
            <param name="rowTok">row token (e.g. Row1)</param>
            <param name="colTok">col token (e.g. X1 or RHS1)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.TryGetMpsKind(Microsoft.SolverFoundation.Common.Token,Microsoft.SolverFoundation.Common.TokKind@)">
            <summary>
            This is done instead of changing the lexer behaviour
            so we got the TokKind instead of Ident
            </summary>
            <param name="tok"></param>
            <param name="tid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.FinishReadFile">
            <summary>
            There is a bug which that disposing the file happens just when finish reading 
            all of it (see LexSource(IText tv, int ichInit, bool fLineStart) so this make sure we will get there 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SmpsParser.RandomParametersSubstitution">
            <summary>
            Encapsulates the data from the stoch file.
            the First Key is the row, so for each row we have a dictionary colkey->randomdata
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SmpsParser.PeriodsInfo">
            <summary>
            Encapsulates the data from time file
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SmpsParser.PeriodsData">
            <summary>
            One for all periods data for the whole model
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterData">
            <summary>
            There will be one RandomParameterData for each stochastic parameter
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterData.#ctor(Microsoft.SolverFoundation.Services.Scenario[],Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterModification)">
            <summary>
            For the usage of discrete parameter
            </summary>
            <param name="scenarios">Scenarios for this parameter</param>
            <param name="modification">Add, Multiply or Replace</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterData.#ctor(System.Double,System.Double,Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterType)">
            <summary>
            For all but discrete
            </summary>
            <param name="firstArgument">first (depends on the distribution)</param>
            <param name="secondArgument">second (depends on the distribution)</param>
            <param name="type">type of distribution</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterModification">
            <summary>
            The modification of the data with respect to what has been suggested in the core file
            REVIEW shahark: i am not sure if that was supposed to be supported for all type of random data
            but for now it is only done for Discrete data
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SmpsParser.RandomParameterType">
            <summary>
            Those reflects the different type of INDEP section
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MpsWriter">
            <summary>
            MPS file generator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsWriter.#ctor(Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary>
            constructor 
            </summary>
            <param name="mod">a linear model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsWriter.WriteMps(System.IO.TextWriter,System.Boolean)">
            <summary>
            Entry point to generate MPS file 
            </summary>
            <param name="wrt">output writer</param>
            <param name="fFixed">whether output in free or fixed format</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MpsWriter.GetStringFromObject(System.Object)">
            <summary>
            Get the value from obj which is Expression, and use ToString() for other objects 
            That's is done because ToString of Expression adds quotes to the string
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NonlinearModel">
            <summary>
            NonlinearModel is an implementation of INonlinearModel. It represents a non-linear optimization model which has rows, 
            variables and goals, and in addition has callback that define the values and possible the gradients of the rows.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RowVariableGoalModel">
            <summary>
            <summary>
            RowVariableGoalModel is implementation of an optimization model 
            consisting of decision variables, rows and goals
            </summary>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>
            The IEqualityComparer's are for the internal dictionaries from key to row/variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark a row as a goal.
            </summary>
            <param name="vid">A row id.</param>
            <param name="pri">The priority of a goal.</param>
            <param name="minimize">Whether to minimize the goal row.</param>
            <returns>An IGoal representing the goal.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.ClearGoals">
            <summary>
            Clear all the goals. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row.
            </summary>
            <param name="vid">a row id</param>
            <returns>true if the goal is removed. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row. 
            </summary>
            <param name="vid">a row id</param>
            <returns>true if this a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.IGoal@)">
            <summary>
            Check if a row id is a goal. If true, return the goal entry.
            </summary>
            <param name="vid">a row id</param>
            <param name="goal">return the goal entry</param>
            <returns>true if a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableGoalModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal.
            </summary>
            <param name="vid">a variable index</param>
            <returns>A goal entry. Null if not a goal row</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableGoalModel.GoalCount">
            <summary>
            The number of goals in this linear model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableGoalModel.Goals">
            <summary>
            Return the goal collection of this linear model. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>
            Creates an instance of NonlinearModel
            </summary>
            <param name="comparer">Comparer for keys.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.#ctor">
            <summary>
            Creates an instance of NonlinearModel
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.GetActiveVariables(System.Int32)">
            <summary>Specify variables that participate in the row. 
            </summary>
            <param name="rowVid">The row index.</param>
            <returns>Enumeration of active variables on rowVid.</returns>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.IsActiveVariable(System.Int32,System.Int32)">
            <summary>Is a specific variable active in a specific row.
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="varVid">The variable index.</param>
            <returns>True if variable is active, otherwise false.</returns>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SetActiveVariables(System.Int32,System.Boolean)">
            <summary>Set all variables in a row to be active/inactive.
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="active">If true, all variables become active, 
            if false all variables become inactive.</param>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SetActiveVariable(System.Int32,System.Int32,System.Boolean)">
            <summary>Set a specific variable in a row to be active/inactive.
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="varVid">The variable index.</param>
            <param name="active">If true, the variable becomes active, 
            if false it becomes inactive.</param>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SetActiveVariables(System.Boolean)">
            <summary>Set all variables in all rows (include goal rows) to be active/inactive.
            </summary>
            <param name="active">If true, all variables become active, 
            if false all variables become inactive.</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NonlinearModel.JacobianSparsityPattern">
            <summary>
            This is used as the sparse pattern for jacobian.
            </summary>
            <remarks>Usually when talking about Jacobian it does not include the goal. 
            This one does include the goal's row (i.e. Jacobian rows + goals' gradient rows</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NonlinearModel.FunctionEvaluator">
            <summary>
            Function value callback.
            * INonlinearModel: the model.
            * int: the row (goal or constraint) index.
            * ValuesByIndex: the variable values.
            * bool: is first evaluator call with those variable values.
            * double: the row value (returned by the callback).
            </summary>
            <remarks>This callback must be set before solving the model</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NonlinearModel.GradientEvaluator">
            <summary>
            Gradient callback.
            * INonlinearModel: the model.
            * int: the row (goal or constraint) index.
            * ValuesByIndex: the variable values.
            * bool: is first evaluator call with those variable values.
            * ValuesByIndex: the gradient values (set by the user).
            </summary>
            <remarks>All entries which related to variables declared as an active by SetActiveVariables method, 
            needs to be filled in ValuesByIndex of gradients</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix">
            <summary>
            This is a sparse matrix by rows. There is no value associated with entry (row + variable). 
            Implicitly the value is boolean. The entry either exists or not
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix._sparseMatrix">
            <summary>
            This is used as the sparse pattern for Jacobian.
            rowVid -> hashset of variable vids
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.#ctor">
            <summary>
            Creates SparseMatrix instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.GetActiveVariables(System.Int32)">
            <summary>Specify variables that participate in the row. 
            </summary>
            <param name="rowVid">The row index.</param>
            <returns>Enumeration of active variable on rowVid.</returns>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.IsActiveVariable(System.Int32,System.Int32)">
            <summary>Is a specific variable active in a specific row.
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="varVid">The variable index.</param>
            <returns>True if variable is active, otherwise false.</returns>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.SetActiveVariables(System.Int32,System.Collections.Generic.IEnumerable{System.Int32},System.Boolean)">
            <summary>Set all variables in a row to be active/inactive
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="variableIndexes">All variables for dense row.</param>
            <param name="active">If true, all variables become active, 
            if false all variables become inactive.</param>
            <exception cref="T:System.ArgumentNullException">variableIndices cannot be null.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.SetActiveVariable(System.Int32,System.Int32,System.Boolean)">
            <summary>Set a specific variable in a row to be active/inactive
            </summary>
            <param name="rowVid">The row index.</param>
            <param name="varVid">The variable index.</param>
            <param name="active">If true, the variable becomes active, 
            if false it becomes inactive.</param>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NonlinearModel.SparseMatrix.RowCount">
            <summary>
            Row count of sparse matrix
            </summary>
            <remarks>This is O(1) operation</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.TermTask.EvaluationContext">
            <summary>
            Set or get EvaluationContext
            </summary>
            <remarks>Update _evaluationContext of term builder of exists</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermTask.Builder.ShouldAddOr(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Term})">
            <summary>
            This does some minor "presolve", but only the most important.
            If there is constant which is true there is no need for the constraint.
            </summary>
            <param name="inputs"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.PluginSolutionMapping">
            <summary>
            The base class for solution mappings for linear, nonlinear, and term-based plugin solvers.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolutionMapping">
            <summary>This is the middle layer between results in SFS decisions, goals and constraints to 
            the solver terms/vids.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.#ctor(Microsoft.SolverFoundation.Services.Model)">
            <summary>Constructor for SolutionMapping class
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Decision,System.Object[],System.Int32@)">
            <summary>Gets a vid out of a decision
            </summary>
            <param name="decision">A decision</param>
            <param name="indexes">Indexes related to the decision</param>
            <param name="vid">vid related to the decision</param>
            <returns>true if the decision has mapping to a vid, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Goal,System.Int32@)">
            <summary>Gets vid out of a Goal
            </summary>
            <param name="goal">A goal</param>
            <param name="vid">vid related to the goal</param>
            <returns>true if the goal has mapping to a vid, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Constraint,System.Object[],System.Int32,System.Int32@)">
            <summary>Get vid out of constraint, indexes and part
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks> 
            <param name="constraint">A constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint</param>
            <param name="vid">vid related to the constraint</param>
            <returns>true if constraint has mapping to a vid, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetDecision(System.Int32,Microsoft.SolverFoundation.Services.Decision@,System.Object[]@)">
            <summary>Gets a decision out of vid
            </summary>
            <param name="vid">A vid</param>
            <param name="decision">The decision mapped to the vid</param>
            <param name="indexes">Indexes related to the decision</param>
            <returns>true if the vid has mapping to a decision, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetConstraint(System.Int32,Microsoft.SolverFoundation.Services.Constraint@,System.Object[]@,System.Int32@)">
            <summary>Gets a constraint with indexes and component from vid
            </summary>
            <param name="vid">vid of a row</param>
            <param name="constraint">The constraint mapped to the vid</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint.
            When single constraint has multiple part 
            (e.g. "5 >= x >= y >= 9") there might be different row for each part. component is zero based.</param>
            <returns>true if the vid has mapping to a Constraint, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetGoal(System.Int32,Microsoft.SolverFoundation.Services.Goal@)">
            <summary>Gets goal out of a vid
            </summary>
            <param name="vid">A vid</param>
            <param name="goal">The goal mapped to the vid</param>
            <returns>true if the vid has mapping to a goal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetValue(Microsoft.SolverFoundation.Services.Decision,System.Object[],Microsoft.SolverFoundation.Common.Rational@)">
            <summary>Gets a value of a decision with specific indexes
            </summary>
            <param name="decision">A Decision</param>
            <param name="indexes">Indexes related to the Decision</param>
            <param name="value">The value related to the Decision </param>
            <returns>true if the decision has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">decision and indexes must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.TryGetValue(Microsoft.SolverFoundation.Services.Goal,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>Gets a value of a decision with specific indexes
            </summary>
            <param name="goal">A Goal</param>
            <param name="value">The value related to the Goal </param>
            <returns>true if the goal has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">goal must not be null </exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Decision)">
            <summary>Get all indexes of a decision
            </summary>
            <param name="decision">The decision</param>
            <returns>Enumaration of all indexes</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.GetComponents(Microsoft.SolverFoundation.Services.Constraint,System.Object[])">
            <summary>Get parts of constraint with its indexes
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A Constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <returns>A collection of parts related to the constraint</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Gets indexes of a constraint
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A constraint</param>
            <returns>A collection of indexes related to the constraint</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.GetGoalCoefficient(Microsoft.SolverFoundation.Services.Decision)">
            <summary>This is called from context when solving stochastic problem 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.UpdateSecondStageResults(Microsoft.SolverFoundation.Services.Model,System.Double)">
            <summary>This updates the second stage results when using decomposition
            Called at the end of every iteration for each scenario 
            </summary>
            <param name="model"></param>
            <param name="probability">probability of the scenario</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolutionMapping.GetNext(Microsoft.SolverFoundation.Services.Model,System.Func{System.Boolean})">
            <summary>Get the next solution
            </summary>
            <remarks>used internaly for CSP</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolutionMapping.EmptyArray">
            <summary>One dimensional Empty array. Use it whenever you need an empty array instead of allocating one. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolutionMapping.Model">
            <summary>Sfs Model which was solved
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Decision)">
            <summary>Get all indexes of a decision
            </summary>
            <param name="decision">The decision</param>
            <returns>Enumaration of all indexes</returns>
            <exception cref="T:System.ArgumentNullException">decision must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Decision,System.Object[],System.Int32@)">
            <summary>Gets a vid out of a decision
            </summary>
            <param name="decision">A decision</param>
            <param name="indexes">Indexes related to the decision</param>
            <param name="vid">vid related to the decision</param>
            <returns>true if the decision has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">decision and indexes must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Constraint,System.Object[],System.Int32,System.Int32@)">
            <summary>Get vid out of constraint, indexes and part
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint</param>
            <param name="vid">vid related to the constraint</param>
            <returns>true if constraint has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">constraint and indexes must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Goal,System.Int32@)">
            <summary>Gets vid out of a Goal
            </summary>
            <param name="goal">A goal</param>
            <param name="vid">vid related to the goal</param>
            <returns>true if the goal has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">goal must not be null </exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetDecision(System.Int32,Microsoft.SolverFoundation.Services.Decision@,System.Object[]@)">
            <summary>Gets a decision out of vid
            </summary>
            <remarks>Caller must not change the indexes array</remarks>
            <param name="vid">A vid</param>
            <param name="decision">The decision mapped to the vid</param>
            <param name="indexes">Indexes related to the decision</param>
            <returns>true if the vid has mapping to a decision, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetConstraint(System.Int32,Microsoft.SolverFoundation.Services.Constraint@,System.Object[]@,System.Int32@)">
            <summary>Gets a constraint with indexes and component from vid
            </summary>
            <remarks>Caller must not change the indexes array</remarks>
            <param name="vid">vid of a row</param>
            <param name="constraint">The constraint mapped to the vid</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint.
            When single constraint has multiple part 
            (e.g. "5 >= x >= y >= 9") there might be different row for each part. component is zero based.</param>
            <returns>true if the vid has mapping to a Constraint, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.TryGetGoal(System.Int32,Microsoft.SolverFoundation.Services.Goal@)">
            <summary>Gets goal out of a vid
            </summary>
            <param name="vid">A vid</param>
            <param name="goal">The goal mapped to the vid</param>
            <returns>true if the vid has mapping to a goal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Gets indexes of a constraint
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A constraint</param>
            <returns>A collection of indexes related to the constraint</returns>
            <exception cref="T:System.ArgumentNullException">constraint must not be null </exception>
            <exception cref="T:System.NotSupportedException">Mapping of stochastic model is not supported</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetComponents(Microsoft.SolverFoundation.Services.Constraint,System.Object[])">
            <summary>Get parts of constraint with its indexes
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A Constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <returns>A collection of parts related to the constraint</returns>
            <exception cref="T:System.NotSupportedException">Mapping of stochastic model is not supported</exception>
            <exception cref="T:System.ArgumentNullException">constraint and indexes must not be null </exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetComponentsCore(Microsoft.SolverFoundation.Services.Constraint,System.Object[])">
            <summary>Get parts of constraint with its indexes
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A Constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <returns>A collection of parts related to the constraint</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.CalculateSecondStageResults(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>Calculate and set the recourseDecision results (avg, min, max) 
            </summary>
            <param name="recourseDecision"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.UpdateSecondStageResults(Microsoft.SolverFoundation.Services.Model,System.Double)">
            <summary>This updates the second stage results when using decomposition
            Called at the end of every iteration for each scenario 
            </summary>
            <param name="model"></param>
            <param name="probability">probability of the scenario</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetGoalCoefficient(Microsoft.SolverFoundation.Services.Decision)">
            <summary>This is called from context when solving stochastic problem 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.GetVidVar(Microsoft.SolverFoundation.Services.Decision,System.Object[])">
            <summary>
            
            </summary>
            <param name="decision"></param>
            <param name="indexes"></param>
            <returns>vid if success and -1 if fails</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.EnsureVidToDecisionMappingInitiated">
            <summary>If _vidToDecisionMapping was not created, creates it
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.EnsureVidToGoalMappingInitiated">
            <summary>If _vidToGoalMapping was not created, creates it
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolutionMapping.EnsureConstraintToVidMappingInitiated">
            <summary>If _constraintToVidMapping was not created, creates it
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NonlinearTask.PickDifferentiator">
            <summary>
            Picks the right Differentiator depends on the model.
            Currently picks ReverseDifferentiator if there is just one row, 
            otherwise picks ForwardDifferentiator
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NonlinearTask.EvaluationContext">
            <summary>
            Set or get EvaluationContext
            </summary>
            <remarks>Update _evaluationContext of term builder of exists</remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearTask.DelegateBuilder.MaxExpressionDepth">
            <summary>
            This is the maximum depth of an expression; anything larger will be broken up using temporary variables.
            Setting this too low will impact performance, while setting it too high may cause stack overflow.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NonlinearTask.DelegateBuilder._rowVids">
            <summary>
            This contains the vids of constraints and goals (not all rows) in the TermModel.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.OmlLexer">
            <summary>
            lexer which takes underscore('_') as a normal character
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteLexer.IsIdentStart(System.Char)">
            <summary> Is the character valid starter for an identifier
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteLexer.IsIdentCh(System.Char)">
            <summary> Is the character valid in an identifier
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlLexer.IsIdentCh(System.Char)">
            <summary>
            Is the character valid in an identifier
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlLexer.IsIdentStart(System.Char)">
            <summary>
            Is the character valid starter for an identifier
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.ErrorOutput(Microsoft.SolverFoundation.Common.Token,System.String,System.Object)">
            <summary> output an error
            </summary>
            <param name="tok">Token that produced the error</param>
            <param name="errorMessage">Error text.</param>
            <param name="errorData">Error data (optional).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.ProcessExpr(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary> Process an expression
            </summary>
            <param name="expr"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.Error(System.String,System.Object)">
            <summary> record an error
            </summary>
            <param name="errorMessage"></param>
            <param name="errorData">Error data (optional).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.ErrorNoData(System.String,System.Object[])">
            <summary> record an error with no data and with one or more args.
            </summary>
            <param name="errorMessage"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.Error(Microsoft.SolverFoundation.Common.Token,System.String,System.Object[])">
            <summary> record an error
            </summary>
            <param name="tok"></param>
            <param name="errorMessage"></param>
            <param name="args"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.IgnoreError">
            <summary> check if the error should be ignored as duplicate
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.ErrorCore(Microsoft.SolverFoundation.Common.Token,System.String,System.Object)">
            <summary> record an error
            </summary>
            <param name="tok"></param>
            <param name="errorMessage"></param>
            <param name="errorData">Error data (optional).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.EatToken(Microsoft.SolverFoundation.Common.TokKind)">
            <summary>
            Eats a literal token of the given kind. If the next token is not the right kind, reports an error.
            </summary>
            <param name="tid"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteParser.EndExpressionParsing(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Common.TextSpan)">
            <summary>
            set the span info
            </summary>
            <param name="expr"></param>
            <param name="exprSpan"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Rewrite.RewriteParser.Rewrite">
            <summary> Construct a RewriteSystem
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Rewrite.RewriteParser.Stopwatch">
            <summary> Read the Stopwatch
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.OmlValidator">
            <summary>
            This class implements methods for checking that an OML model is valid.
            
            "Valid" in this case means that only a restricted set of operators are
            used, and that if each parameter and decision was assigned a value from
            the appropriate domain, all the goals and constraints would reduce to
            simple values (numbers for goals, booleans for constraints).
            
            The validator is conservative, in that it only accepts models
            where it can prove the above two conditions are true.
            
            Note that in some cases, applying standard reductions to an invalid model
            can produce a valid model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.MakeModelClauseException(System.String,Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation,Microsoft.SolverFoundation.Common.OmlParseExceptionReason)">
            <summary>
            This is used when the string of error is the same no matter if we use the 
            Expression itself or the closest Invocation
            </summary>
            <param name="errorMessage"></param>
            <param name="errorExp"></param>
            <param name="closestInvocation"></param>
            <param name="reason">The reason for the exception.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.MakeModelClauseException(System.String,System.String,Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            get different format strings for case that the errored Expression is Symbol,
            so it doesn't have a reliable line info, and if it is not
            </summary>
            <param name="errorForNonSymExpression">error message for the case the Expression itself is sent</param>
            <param name="formatErrorForSymExpression">used to get the symbol into the error when the Expression sent to the exception is the Invocation</param>
            <param name="errorExp">wrong Expression</param>
            <param name="closestInvocation">clesest Invocation for the wrong Expression</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeParametersSection(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check a Parameters[...] section.
            </summary>
            <param name="sectionInv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeDecisionsSection(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check a Decisions[...] section.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeDecisionsOrParametersSection(Microsoft.SolverFoundation.Rewrite.Invocation,Microsoft.SolverFoundation.Services.OmlValidator.TokenType)">
            <summary>
            Check a Decisions[...] or Parameters[...] section. The two types have the same basic structure, so most of the code is shared.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeConstraintsSection(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check a Constraints[...] section.
            </summary>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeGoalsSection(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check a Minimize[...] or Maximize[...] section.
            </summary>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeDecisionsOrParametersSectionElement(Microsoft.SolverFoundation.Services.OmlValidator.TokenType,Microsoft.SolverFoundation.Services.OmlValidator.DecisionParameterInfo,Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check a single element of a Decisions[...] or Parameters[...] section.
            This encompasses the EBNF grammar rules for {domain}, {set_domain}, {decision}, {parameter}, and {assignment_parameter}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeDomain(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation,System.Boolean)">
            <summary>
            Check a domain declaration (Integers, Reals[0.0,+Infinity], etc.).
            </summary>
            <param name="expr"></param>
            <param name="closestInvocation"></param>
            <param name="allowDomainWithDataDependent"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeExpr(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            This is the core of the validator. It analyzes an expression, verifies that its
            arguments are of appropriate types, and returns a TermType object for further analysis.
            </summary>
            <param name="expr"></param>
            <param name="closestInvocation"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeInvocation(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check an invocation
            </summary>
            <param name="inv"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeBuiltin(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check an invocation of a builtin operator.
            </summary>
            <param name="inv"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeInOr(Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check InOr[...]. This only accepts InOr of the form
              InOr[Tuple[expr, expr, ...],
                   Tuple[set, set, ...],
                   Tuple[set, set, ...]]
            
            where a "set" is either {expr, expr, ...} or a domain.
            </summary>
            <param name="inv"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeIndex(Microsoft.SolverFoundation.Services.OmlValidator.TermType,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Check an invocation where the head is not a builtin operator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeSum(Microsoft.SolverFoundation.Rewrite.Invocation,Microsoft.SolverFoundation.Rewrite.Expression,System.Boolean)">
            <summary>
            Check a Sum[...] or FilteredSum[...]
            </summary>
            <param name="inv"></param>
            <param name="head"></param>
            <param name="hasCondition"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeIteration(Microsoft.SolverFoundation.Rewrite.Invocation,Microsoft.SolverFoundation.Rewrite.Expression,System.Boolean)">
            <summary>
            Check a Foreach[...] or FilteredForeach[...]
            </summary>
            <param name="inv"></param>
            <param name="head"></param>
            <param name="hasCondition"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeIterationSet(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation,System.Boolean)">
            <summary>
            Check the second part of an iterator seen in a Foreach/FilteredForeach/Sum/FilteredSum
            </summary>
            <param name="iterSet"></param>
            <param name="closestInvocation"></param>
            <param name="mustBeNumeric"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.AnalyzeBuiltin(Microsoft.SolverFoundation.Rewrite.Invocation,Microsoft.SolverFoundation.Services.TermValueClass,Microsoft.SolverFoundation.Services.OmlValidator.ArgumentRestriction,System.Boolean,System.Boolean)">
            <summary>
            Check an invocation of a builtin operator.
            </summary>
            <param name="inv"></param>
            <param name="returnType"></param>
            <param name="argsRestriction"></param>
            <param name="requireNumeric"></param>
            
            <param name="requireFirstNumeric"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.ValidateOperators(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation},System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Invocation})">
            <summary>
            Go through first validation of goals and constraints
            </summary>
            <param name="constraintsSections"></param>
            <param name="goalSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.ValidateOperators(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>
            Called before evaluation
            Validates that no forbidden operators is in constraints or goals
            REVIEW shahark: 
            1. This pass only validate that there is no usage of 
            forbidden operators, it does not valid correct usage of them for now.
            2. Decisions and parameters will be checked just in second pass, as the one that
            belongs to foreach for example are hard to e verified
            </summary>
            <param name="exprParent"></param>
            <param name="expr"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlValidator.ValidateSymbols(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>
            called after evaluation, finds any free symbols
            </summary>
            <param name="exprParent"></param>
            <param name="expr"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.OmlWriter">
            <summary>
            A method object for converting a Model to an OML Expression.
            
            This preserves the structure of the model, including parameters and labels of constraints/goals.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._cachedTermExpressions">
            <summary>
            A cache of expressions resulting for terms. This cache is not necessary for correctness.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._constantSymbols">
            <summary>
            A cache from named constants to symbols. Required to ensure that each parameter has a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._decisionSymbols">
            <summary>
            A cache from decisions to symbols. Required to ensure that each decision has a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._iterationSymbols">
            <summary>
            A cache mapping iteration terms to symbols. This is required to ensure that each iteration term gets a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._parameterSymbols">
            <summary>
            A cache from parameters to symbols. Required to ensure that each parameter has a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._randomParameterSymbols">
            <summary>
            A cache from parameters to symbols. Required to ensure that each parameter has a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._recourseDecisionSymbols">
            <summary>
            A cache from recourse decisions to symbols. Required to ensure that each decision has a unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._cachedSets">
            <summary>
            A cache mapping sets to terms. This is necessary so that each set gets only one unique symbol.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlWriter._randomParameterTypes">
            <summary>A mapping from random parameter type to its corresponding expression in OML
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.Translate(Microsoft.SolverFoundation.Services.Model)">
            <summary>
            Translate a model into OML. The result is an invocation with Model as its head. The invocation might be empty.
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddSubmodels(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add all SubmodelName -> Model[...] sections.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddSets(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add all Parameters[Sets, ...] sections. Each group of sets sharing a domain are grouped together.
            Domains are compared with object identity, so sets whose domains are two different calls to
            Domain.RealRange(...) will be placed in different sections.
            </summary>
            <param name="model"></param>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.GetSets(Microsoft.SolverFoundation.Services.Model)">
            <summary>
            Get all sets from the model. This is similar to Model.ModelSets, but guarantees
            that the sets are added in a consistent order (given a consistent order of Parameters and Decisions).
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddDecisionSections(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add all Decisions[...] sections to the model. Like AddSets, this groups decisions with the same domain.
            Indexed decisions are handled appropriately.
            </summary>
            <param name="model"></param>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.GetRecourseDecisionDefintion(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>Wrap the recourse decision name with Recourse invocation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddParameterSections(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add all Parameters[...] sections to the model. Like AddSets, this groups parameters with the same domain.
            Indexed parameters are handled appropriately.
            </summary>
            <param name="model"></param>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.TranslateScenarios(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Services.ScenariosParameter)">
            <summary>Gets expression with all the explicit scenarios of the ScenariosParameter
            e.g. gasDemand= {{0.3, 1900}, {0.4, 2000}, {0.3, 2100} }
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.GetSectionForDomain(System.Collections.Generic.List{System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression}},System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Services.Domain,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression}},Microsoft.SolverFoundation.Services.Domain,System.Boolean)">
            <summary>
            A helper function to group something (decisions, parameters, sets) by domains.
            </summary>
            <param name="sections">A list of section contents which go into the final model.</param>
            <param name="domainToSection">A dictionary from domains to lists of section contents.</param>
            <param name="domain">The domain of the section to find. If it doesn't exist, a new list of expressions
            is created, and the translation of the domain is added as the first element.</param>
            <param name="isSets">If true, the first element is wrapped in Sets[] when creating a new list of expressions.</param>
            <returns>A list of expressions representing the contents of the correct section. The list can be modified.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddConstraints(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add a Constraints[] section to the model. Only one Constraints[] section is generated. Each constraint is labeled.
            </summary>
            <param name="model"></param>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddGoals(Microsoft.SolverFoundation.Services.Model,System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add a Goals[] section to the model for each goal. Each goal is labeled.
            </summary>
            <param name="model"></param>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.AddNamedConstants(System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Add all named constants ("Parameters[..., P = constant]") to the model.
            Named constants go before the other model sections, but are added last because
            they are discovered while writing the Goals and Constraints sections.
            </summary>
            <param name="modelSections"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.Translate(Microsoft.SolverFoundation.Services.Domain)">
            <summary>
            Translate a Domain into an OML expression representing it.
            </summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.Translate(Microsoft.SolverFoundation.Services.Set)">
            <summary>
            Translate a Set into an OML expression representing it.
            </summary>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.Translate(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.TermValueClass)">
            <summary>
            Translate a Term into an OML expression representing it. This calls Visit on the term, which in turn calls the appropriate
            overload of Visit on this object.
            </summary>
            <param name="term"></param>
            <param name="targetValueClass">The value class the result should have. The value will be coerced if necessary.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.IsIdentCh(System.Char)">
            <summary>
            A helper function to find valid identifiers. Should be no broader than Lexer.IsIdentCh
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.IsIdentStartCh(System.Char)">
            <summary>
            A helper function to find valid identifiers. Should be no broader than Lexer.IsIdentCh
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlWriter.CreateSymbol(System.String)">
            <summary>
            Create a new symbol with a given name. If the name contains characters which are not valid in a symbol,
            translates them to characters which are valid.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.OmlFormatter">
            <summary>
            This is used to pretty-print OML. It handles tabbing, putting a space after ',', and having certain
            forms expand over multiple lines.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OmlFormatter._prettyPrintExprs">
            <summary>
            An invocation which has a head in this set is expanded on multiple lines, e.g.
            <code>
              Inv[
                arg,
                arg
              ]
            </code>
            instead of
            <code>
              Inv[arg, arg]
            </code>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.BeginInvocationArgs(System.Text.StringBuilder,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called immediately after printing '[' in an invocation.
            </summary>
            <param name="sb"></param>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.BeginOneArg(System.Text.StringBuilder,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called immediately before expanding each argument of an invocation.
            </summary>
            <param name="sb"></param>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.EndOneArg(System.Text.StringBuilder,System.Boolean,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called immediately after expanding each argument of an invocation, including the ',' if present.
            </summary>
            <param name="sb"></param>
            <param name="last"></param>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.EndInvocationArgs(System.Text.StringBuilder,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called immediately before printing ']' in an invocation.
            </summary>
            <param name="sb"></param>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.BeforeBinaryOperator(System.Text.StringBuilder,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called before printing the operator in a binary operator.
            </summary>
            <param name="sb"></param>
            <param name="inv"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OmlFormatter.AfterBinaryOperator(System.Text.StringBuilder,Microsoft.SolverFoundation.Rewrite.Invocation)">
            <summary>
            Called after printing the operator in a binary operator.
            </summary>
            <param name="sb"></param>
            <param name="inv"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Parameter">
            <summary>
            A group of terms which will take concrete values only when data is bound.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Parameter._addValueTableElement">
            <summary>
            Adds a data element to the internal ValueTable.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String)">
            <summary>
            Create a new parameter.
            </summary>
            <param name="domain">The set of values each element of the parameter can take, such as Model.Real</param>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            Create a new parameter.
            </summary>
            <param name="domain">The set of values each element of the parameter can take, such as Model.Real</param>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Shallow copy constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetIndexSet(System.Int32,Microsoft.SolverFoundation.Services.Set)">
            <summary>Re-sets the ith index set (refreshing the cache).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.Microsoft#SolverFoundation#Services#IDataBindable#DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>Establish values for the Parameter by binding to its data source.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,Microsoft.SolverFoundation.Common.Rational,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <param name="defaultValue">Used as a default value for indexes that are not provided by the binding.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBindingCore``1(System.Collections.Generic.IEnumerable{``0},System.String,Microsoft.SolverFoundation.Common.Rational,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <param name="defaultValue">Used as a default value for data which can't found in binding sequence.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Microsoft.SolverFoundation.Common.Rational},Microsoft.SolverFoundation.Common.Rational,System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="defaultValue">Used as a default value for indexes that are not provided by the binding.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Microsoft.SolverFoundation.Common.Rational},System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBindingCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Microsoft.SolverFoundation.Common.Rational},Microsoft.SolverFoundation.Common.Rational,System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="defaultValue">Used as a default value for data which can't found in binding sequence.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String,System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="defaultValue">Used as a default value for indexes that are not provided by the binding.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.SetBindingCore``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String,System.Func{``0,System.Object}[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(s) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="valueGetter">A function to select the value from each data element.</param>
            <param name="defaultValue">Used as a default value for data which can't found in binding sequence.</param>
            <param name="indexGetter">Functions to select the indexes for each data element, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Parameter.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Parameter.IndexSets">
            <summary>
            The index sets passed in when this object was created.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Parameter.EnumeratedDomain">
            <summary>
            REVIEW shahark: currently not added to the random types, but in future releases
            if we support stochastic CSP we may need that 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Parameter.Item(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Indexes by one or more values
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Parameter.Name">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Parameter.Description">
            <summary>
            A description.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RandomParameter">
            <summary>A group of terms that take stochastic values.
            </summary>
            <remarks>
            Random parameters are used to model randomness in input data.  Random parameters 
            can be discrete or continuous, and can be used where (non-random) Parameters or 
            constants would normally be used in Constraints.  RandomParameter is the base class 
            for a number of commonly used distributions including uniform, normal, and log normal.  
            A special type of random parameter is a ScenariosParameter, where each scenario 
            contains a value and a probability. 
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RandomParameter._addValueTableElement">
            <summary>
            Adds a data element to the internal ValueTable.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.#ctor(System.String)">
            <summary>
            Create a new RandomParameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Create a new RandomParameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>Create a new RandomParameter.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.SetIndexSet(System.Int32,Microsoft.SolverFoundation.Services.Set)">
            <summary>Re-sets the ith index set (refreshing the cache).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.Microsoft#SolverFoundation#Services#IDataBindable#DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            
            </summary>
            
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.Microsoft#SolverFoundation#Services#IIndexable#TryEvaluateConstantValue(System.Object[],Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Services.Term.EvaluationContext)">
            <summary>Gets the current value of a non-indexed random parameter.
            </summary>
            <param name="inputValues">The input values.</param>
            <param name="value">An output parameter which stores the value (if successful).</param>
            <param name="context">The EvaluationContext.</param>
            <returns>Returns true if the random parameter could be evaluated as a constant.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.GetConstantValue(Microsoft.SolverFoundation.Services.DistributedValue)">
            <summary>Returns the value of the current sample or the mean value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.VerifyModelNotFrozen">
            <summary>
            Used in SetBinding methods to make sure the 
            owning model is not frozen 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Bind the data. Some minor implementation can depends on the random parameter type
            </summary>
            <param name="context"></param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.GetIndexFieldGetters``1(System.Collections.Generic.IEnumerable{``0},System.String[])">
            <summary>This method creates getters
            for the indexes and also does all the checks common to all random parameters
            </summary>
            <returns>getters for each index</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.GetIndexes``1(System.Object,System.Func{``0,System.Object}[])">
            <summary>Use the index field accessor delegates to get the indexes from the object.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.TryEvaluateConstantValue(Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Services.Term.EvaluationContext)">
            <summary>Gets the current value of a non-indexed random parameter.
            </summary>
            <param name="value">An output parameter which stores the value (if successful).</param>
            <param name="context">The EvaluationContext.</param>
            <returns>Returns true if the random parameter could be evaluated as a constant.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RandomParameter.ToString">
            <summary>Returns a string representation for the RandomParameter.
            </summary>
            <returns>A string representation for the RandomParameter.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.EvaluateExpectedValue">
            <summary>If true, evaluating the parameter will return the expected value instead of sampling.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.IndexSets">
            <summary>The index sets for this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.Item(Microsoft.SolverFoundation.Services.Term[])">
            <summary>Indexes by one or more values.
            </summary>
            <param name="indexes">The index terms.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.Name">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.Description">
            <summary>
            A description.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RandomParameter.Microsoft#SolverFoundation#Services#IIndexable#DomainValueClass">
            <summary>
            Random parameter for now is just numeric
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ScenariosParameter">
            <summary>A parameter representing a fixed, finite number of discrete scenarios.
            </summary>
            <remarks>
            A ScenariosParameter is associated with an underlying set of Scenario objects.  
            Each Scenario defines a possible value for the random parameter along with the 
            probability of the scenario actually occurring.  The sum of probabilities over all
            scenarios equals 1.0.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.#ctor(System.String)">
            <summary>Creates a non-indexed random parameter representing a finite set of scenarios.
            </summary>
            <param name="name">The name of the parameter, which must be unique.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Scenario})">
            <summary>Creates a non-indexed random parameter representing the given set of scenarios.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="scenarios">Array of scenarios</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed random parameter representing a finite set of scenarios.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.FillExplicitScenarios(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Scenario})">
            <summary>Fill in the scenarios for this parameter.
            </summary>
            <param name="scenarios">The scenarios.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="probabilityField">The name of the property of each input object which contains the probability for the value.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="probabilityField">The name of the property of each input object which contains the probability for the value.</param>
            <param name="valueField">The name of the property of each input object which contains the value of the data element.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Actually binds the data to the parameter, using the delegates constructed in advance
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenariosParameter.VerifyProbabilitySumToOne">
            <summary>
            Makes sure that probabilites sums up to 1.
            Can called after data binding (if the parameter is bound), or after
            ctr when the parameter has the scenarios is ctr.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NormalDistributionParameter">
            <summary>A normal (Gaussian) distribution parameter.
            </summary>
            <remarks>
            A normal distribution is a bell-shaped continuous random distribution.  The distribution
            is defined by its mean value and its standard distribution.  The distribution is symmetric
            about the mean value.  Normal distributions are sometimes defined using the variance rather
            than standard deviation - the variance is the square of the standard deviation.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalDistributionParameter.#ctor(System.String)">
            <summary>Creates a non-indexed normal distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalDistributionParameter.#ctor(System.String,System.Double,System.Double)">
            <summary>Creates a non-indexed normal distribution parameter with the specified values.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="mean">The mean value.</param>
            <param name="standardDeviation">The standard deviation.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed normal distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="meanField">The name of the property of each input object which contains the mean for the distribution.</param>
            <param name="stdField">The name of the property of each input object which contains the value of the standard deviation for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NormalDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="meanField">The name of the property of each input object which contains the mean for the distribution.</param>
            <param name="stdField">The name of the property of each input object which contains the value of the standard deviation for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.UniformDistributionParameter">
            <summary>A continuous uniformly distributed random parameter.
            </summary>
            <remarks>
            A uniform distribution is a continuous random distribution defined by an upper and lower
            bound.  The values within the (closed) interval occur with equal probability.  The upper
            and lower bounds must be finite.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.#ctor(System.String)">
            <summary>Creates a new continuous uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.#ctor(System.String,System.Double,System.Double)">
            <summary>Creates a new continuous uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="lowerBound">The lower bound (inclusive).</param>
            <param name="upperBound">The upper bound (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates a new continuous uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.UniformDistributionParameter)">
            <summary>Creates a new continuous uniform distribution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="lowerBoundField">The name of the property of each input object which contains the lower bound for the distribution.</param>
            <param name="upperBoundField">The name of the property of each input object which contains the value of the upper bound for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="lowerBoundField">The name of the property of each input object which contains the lower bound for the distribution.</param>
            <param name="upperBoundField">The name of the property of each input object which contains the value of the upper bound for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.UniformDistributionParameter.SetBindingCore``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>Bind parameter to data.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter">
            <summary>A discrete uniformly distributed random parameter.
            </summary>
            <remarks>
            A discrete uniform distribution is defined by an upper and lower
            bound.  The integer values within the (closed) interval occur with equal probability.  The upper
            and lower bounds must be finite.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter.#ctor(System.String)">
            <summary>Creates a new discrete uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter.#ctor(System.String,System.Double,System.Double)">
            <summary>Creates a new discrete uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="lowerBound">The lower bound (inclusive).</param>
            <param name="upperBound">The upper bound (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Creates a new discrete uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="lowerBound">The lower bound (inclusive).</param>
            <param name="upperBound">The upper bound (inclusive).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates a new discrete uniform distribution.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.DiscreteUniformDistributionParameter.IsInt32(System.Double)">
            <summary>Determine if a Double represents a valid Int32.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter">
            <summary>A random parameter with exponential distribution.
            </summary>
            <remarks>
            An exponential distribution is a continuous random distribution defined by a rate
            parameter.  The distribution describes a Poisson process where independent events 
            occur continuously at that rate. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter.#ctor(System.String)">
            <summary>Creates a non-indexed exponential distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter.#ctor(System.String,System.Double)">
            <summary>Creates a non-indexed exponential distribution parameter with the specified rate.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="rate">The rate argument for the distribution.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed exponential distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="rateField">The name of the property of each input object which contains the rate for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ExponentialDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="rateField">The name of the property of each input object which contains the rate for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.GeometricDistributionParameter">
            <summary>A random parameter with geometric distribution.
            </summary>
            <remarks>
            A geometric distribution is a discrete random distribution defined by a success probability
            parameter.  The distribution describes a process where independent Bernoulli trials 
            are taken with the given success probability. The probability distribution is of the number 
            Y = X - 1 of Bernoulli trial failures before the first success, supported on the set { 0, 1, 2, 3, ... }.
            (Note that this is different from an alternate convention which defines the distribution as the first successful trial 
            supported on the set {1, 2, 3, ... }.)
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricDistributionParameter.#ctor(System.String)">
            <summary>Creates a non-indexed geometric distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricDistributionParameter.#ctor(System.String,System.Double)">
            <summary>Creates a non-indexed geometric distribution parameter with the specified success probability.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="successProbability">Success probability of the distribution</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed geometric distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="successProbabilityField">The name of the property of each input object which contains the success probability for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GeometricDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="successProbabilityField">The name of the property of each input object which contains the success probability for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.BinomialDistributionParameter">
            <summary>A binomial distribution parameter.
            </summary>
            <remarks>
            A binomial distribution is a discrete random distribution defined by a success probability
            and number of trials.  The distribution represents the number of successes in a sequence of trials with the
            given success rate. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialDistributionParameter.#ctor(System.String)">
            <summary>Creates a non-indexed binomial distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <remarks>If the case of : numberOfTrials * min(successProbability, 1 - successProbability) >= 10 
            the distribution cannot be sampled with Latin hypercube method
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialDistributionParameter.#ctor(System.String,System.Int32,System.Double)">
            <summary>Creates a non-indexed binomial distribution parameter from the specified values.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="numberOfTrials">Number of trials of the distribution</param>
            <param name="successProbability">Success probability of the distribution</param>
            <remarks>If the case of : numberOfTrials * min(successProbability, 1 - successProbability) >= 10 
            the distribution cannot be sampled with Latin hypercube method
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed binomial distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
            <remarks>If the case of : numberOfTrials * min(successProbability, 1 - successProbability) >= 10 
            the distribution cannot be sampled with Latin hypercube method
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="numberOfTrialsField">The name of the property of each input object which contains the number of trials for the distribution.</param>
            <param name="successProbabilityField">The name of the property of each input object which contains the success probability for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BinomialDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="numberOfTrialsField">The name of the property of each input object which contains the number of trials for the distribution.</param>
            <param name="successProbabilityField">The name of the property of each input object which contains the success probability for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter">
            <summary>A log normal distribution parameter.
            </summary>
            <remarks>
            A log normal random parameter is a continuous random parameter where the log of the
            parameter is normally distributed. The distribution is defined by the natural log 
            of its mean value and standard distribution.  
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter.#ctor(System.String)">
            <summary>Creates a non-indexed log normal distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter.#ctor(System.String,System.Double,System.Double)">
            <summary>Creates a non-indexed log normal distribution parameter with the specified values.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="meanLog">Mean of the logarithm of the distribution</param>
            <param name="standardDeviationLog">Standard deviation of the logarithm of the distribution</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter.#ctor(System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>Creates an indexed log normal distribution parameter.
            </summary>
            <param name="name">A name for the parameter. The name must be unique. If the value is null, a unique name will be generated.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar parameter.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="meanLogField">The name of the property of each input object which contains the mean of the logarithm for the distribution.</param>
            <param name="stdLogField">The name of the property of each input object which contains the value of the standard deviation of the logarithm for the distribution.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LogNormalDistributionParameter.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.String[])">
            <summary>
            Binds the parameter to data. Each parameter must be bound before solving. The data must be in the form of a sequence of
            objects, where each object has properties for the value and index(es) of the data element. 
            
            The data is read each time Context.Solve() is called.
            
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="meanLogField">The name of the property of each input object which contains the mean of the logarithm for the distribution.</param>
            <param name="stdLogField">The name of the property of each input object which contains the value of the standard deviation of the logarithm for the distribution.</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Parameter was created.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Report">
            <summary>Contains information about the current solution.
            </summary>
            <remarks>
            A Report instance is obtained from a Solution using the GetReport method. Depending on the solver
            that was used to solve the model, GetReport may return a subclass of Report with solver-specific information.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Report._defaultFormatProvider">
            <summary>This is needed for internal access from Solution for setter instead of using the ctr
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Report._defaultVerbosity">
            <summary>This is needed for internal access from Solution for setter instead of using the ctr
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Creates a new instance.
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The solver instance.</param>
            <param name="solution">The solution.</param>
            <param name="solutionMapping">A SolutionMapping object.</param>
            <exception cref="T:System.ArgumentNullException">The context, solver and solution must not be null.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.WriteTo(System.IO.TextWriter)">
            <summary>Writes the string representation of the report to the destination.
            </summary>
            <param name="destination">A TextWriter where the output is directed.</param>
            <exception cref="T:System.ArgumentNullException">The destination must not be null.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.ToString">
            <summary>Get a string representation of the report.
            </summary>
            <remarks>Uses the verbosity supplied on GetReport(), or the default Verbosity (All) if none was supplied. 
            Uses the formatProvider given to GetReport(), or the default IFormatProvider (CultureInfo.CurrentCulture) if none was supplied.</remarks>
            <returns>A string representation of the report</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.ToString(System.IFormatProvider)">
            <summary>Get a string representation of the report
            </summary>
            <remarks>Uses the verbosity supplied on GetReport(), or the default Verbosity (All) if none was supplied</remarks>
            <param name="format">format provider for the string representation</param>
            <returns>A string representation of the report</returns>
            <exception cref="T:System.ArgumentNullException">The format must not be null</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.ToString(Microsoft.SolverFoundation.Services.ReportVerbosity)">
            <summary>Get a string representation of the report
            </summary>
            <remarks>Uses the formatProvider given to GetReport(), or the default IFormatProvider (CultureInfo.CurrentCulture) if none was supplied</remarks>
            <param name="verbosity">verbosity options</param>
            <returns>A string representation of the report</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.ToString(Microsoft.SolverFoundation.Services.ReportVerbosity,System.IFormatProvider)">
            <summary>Get a string representation of the report
            </summary>
            <param name="verbosity">verbosity options</param>
            <param name="format">format provider for the string representation</param>
            <returns>A string representation of the report</returns>
            <exception cref="T:System.ArgumentNullException">The format must not be null</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.SupportsSolutionDetails">
            <summary>
            Determine if solution details can be returned.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.ValidateSolution">
            <summary>Make sure the solution is a valid one. 
            </summary>
            <remarks>Every pulic API should call this verification method</remarks>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportOverview(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Add the overview to the report
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportDecisions(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Add the decision results to the report
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportGoals(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Add the goals results to the report's string representation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GetMaxGoalCount">
            <summary>Returns the MaximumGoalCount of the winning task if exists
            </summary>
            <remarks>The default number for MaximumGoalCount is -1 which means no limit</remarks>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.PrintMapping(System.Text.StringBuilder,System.IFormatProvider,Microsoft.SolverFoundation.Services.RecourseDecision,Microsoft.SolverFoundation.Services.ValueTable{System.Double[]})">
            <summary>
            prints the second stage results
            </summary>
            <param name="report">The report</param>
            <param name="formatProvider">The format provider</param>
            <param name="decision">Currunt RecourseDecision</param>
            <param name="values">ValueTable which holds array of doubles, 
            first is avaerage, second is minimal value and the third is maximal</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportPartialSolutionDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds goal results to the report's string representation. Works for suboptimal solutions as well 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Report.GenerateReportDirectives(System.Text.StringBuilder)">
            <summary>Adds a section about all directives being used to the report string representation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.Context">
            <summary>The SolverContext
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.Solution">
            <summary>The solution this report is built for
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.Solver">
            <summary>The solver that solved the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolutionMapping">
            <summary>An object that maps between model and solver level terms.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.DefaultFormatProvider">
            <summary>The default format provider for building the string representation of the report
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.DefaultVerbosity">
            <summary>The default verbosity for building the string representation of the report
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolutionQuality">
            <summary>Solver result quality
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolveTime">
            <summary>Time spent solving the model (in milliseconds).
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.TotalTime">
            <summary>Total time spent (in milliseconds)
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.ModelName">
            <summary>The name of the model.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolutionDirective">
            <summary>Gets the directive passed to the solver that found the solution.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.Directives">
            <summary>All directives that were used.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolverType">
            <summary>The System.Type of the solver that found the solution.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.SolverCapability">
            <summary>Capability of the solver that found this solution
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Report.IsStochastic">
            <summary>
            Determine if the model is stochastic
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RowVariableReport">
            <summary>Contains information about the current solution for Linear/Nonlinear/Term base  models.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowVariableReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.PluginSolutionMapping)">
            <summary>Constructor of a report for any Linear/Nonlinear/Term base model
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The ISolver that solved the model.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A PluginSolutionMapping instance.</param>
            <exception cref="T:System.ArgumentNullException">context, solver and solution must not be null</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableReport.OriginalVariableCount">
            <summary>Variable count before presolve, as represented by the solver.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
            <remarks>
            OriginalVariableCount may not match the decision count of the Model. This is because
            solvers often convert models into an internal representation by introducing
            or removing variables.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.RowVariableReport.OriginalRowCount">
            <summary>Row count before presolve.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
            <remarks>
            OriginalRowCount may not match the constraint count of the Model. This is because
            solvers often convert models into an internal representation by introducing
            or removing rows.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearReport">
            <summary>Contains information about the current solution for MILP and quadratic models.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.LinearSolutionMapping)">
            <summary>Constructor of a report for any Linear (including MILP) or Quadratic model
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The ISolver that solved the model.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A LinearSolutionMapping instance.</param>
            <exception cref="T:System.ArgumentNullException">context, solver and solution must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.ToString(Microsoft.SolverFoundation.Services.ReportVerbosity,System.IFormatProvider)">
            <summary>Get a string representation of the report.
            </summary>
            <param name="verbosity">verbosity options</param>
            <param name="format">format provider for the string representation</param>
            <returns>A string representation of the report</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
            <exception cref="T:System.ArgumentNullException">format must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetAllShadowPrices">
            <summary>Gets all shadow prices.
            </summary>
            <returns>An IEnumerable of pairs, one for each row. The key is a row name, and the is the shadow price for that row.
            If sensitivity is not supported by the solver, or GetSensitivity was not specified in the directive, an empty collection is returned.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetAllConstraintBoundsSensitivity">
            <summary>Gets the sensitivity range for all constraints.
            A bound can be changed in the sensitivity range without changing the solution vector, i.e. the decision values.
            </summary>
            <returns>An IEnumerable of pairs, one for each row. The key is a row name, and the is the sensitivity range for that row.
            If sensitivity is not supported by the solver, or GetSensitivity was not specified in the directive, an empty collection is returned.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetShadowPrices(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Gets shadow prices for the specified Constraint.
            </summary>
            <param name="constraint">The constraint for which shadow prices should be returned.</param>
            <returns>An IEnumerable of pairs, one for each row. The key is a row name, and the is the shadow price for that row.
            If sensitivity is not supported by the solver, or GetSensitivity was not specified in the directive, an empty collection is returned.</returns>
            <exception cref="T:System.ArgumentNullException">The constraint was null.</exception>
            <exception cref="T:System.ArgumentException">The constraint was not found in model.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetConstraintBoundsSensitivity(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Gets the sensitivity range for a Constraint.
            A bound can be changed within the sensitivity range without changing the solution vector, i.e. the decision values.
            </summary>
            <param name="constraint">The constraint of interest.</param>
            <returns>An IEnumerable of pairs, one for each row. The key is a row name, and the is the sensitivity range for that row.
            If sensitivity is not supported by the solver, or GetSensitivity was not specified in the directive, an empty collection is returned.</returns>
            <exception cref="T:System.ArgumentNullException">The constraint was null.</exception>
            <exception cref="T:System.ArgumentException">The constraint was not found in model.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetGoalCoefficientSensitivity(Microsoft.SolverFoundation.Services.Decision,System.Object[])">
            <summary>Gets the goal coefficient sensitivity range for a Decision with the specified indexes.
            </summary>
            <param name="decision">The decision of interest.</param>
            <param name="indexes">The decision indexes. Use an empty array for a non-indexed decision.</param>
            <returns>Goal coefficient range. 
            If sensitivity is not supported the result is null.
            </returns>
            <remarks>
            A coefficient can be changed within the range without changing the solution vector, i.e. the decision values.
            An indexed Decision has multiple sensitivity ranges, one for each set of indexes. The GetValues method
            returns the complete set of indexes that can be passed into this method.
            </remarks>
            <exception cref="T:System.ArgumentNullException">The decision and its indexes must not be null.</exception>
            <exception cref="T:System.ArgumentException">No decision with the specified indexes can be found.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GetInfeasibilitySet">
            <summary>Gets the infeasibility constraint set.
            </summary>
            <returns>An IEnumerable containing the names of the constraints the infeasibility constraint set.
            If infeasibility is not supported in the solver, or GetInfeasibility was not specified in the directive, an empty enumeration is returned.</returns>
            <remarks>
            The infeasibility set is an irreducible set of constraints that causes the model to be infeasible.
            </remarks>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GenerateReportSolutionDetails(System.Text.StringBuilder,System.IFormatProvider,Microsoft.SolverFoundation.Services.ReportVerbosity)">
            <summary>Adds goals, decision, and sensitivity results. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GenerateReportInfeasibility(System.Text.StringBuilder)">
            <summary>Add infeasibility details to the report.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearReport.GenerateReportStochasticOverview(System.Text.StringBuilder,System.IFormatProvider,Microsoft.SolverFoundation.Services.Solution)">
            <summary>Add the stochastic details.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.IsSensitivityAvailable">
            <summary>Indicates whether sensitivity information is available.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.IsInfeasibilityAvailable">
            <summary>Indicates whether infeasibility information is available.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.LinearModel">
            <summary> The ILinearModel associated with this report.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.NonzeroCount">
            <summary>Nonzero count before presolve.
            </summary>
            <remarks>
            NonzeroCount may not match the number of nonzero constraint terms in the Model. This is because
            solvers often convert models into an internal representation by introducing
            or removing rows.
            </remarks>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.OriginalVariableCount">
            <summary>Variable count before presolve, as represented by the solver.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
            <remarks>
            OriginalVariableCount may not match the decision count of the Model. This is because
            solvers often convert models into an internal representation by introducing
            or removing variables.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.OriginalRowCount">
            <summary>Row count before presolve.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
            <remarks>
            OriginalRowCount may not match the constraint count of the Model. This is because
            solvers often convert models into an internal representation by introducing
            or removing rows.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.SensitivityReport">
            <summary>Sensitivity report from the solver. 
            </summary>
            <remarks>
            This property can be overriden by a derived class to provide
            sensitivity information.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.LinearReport.InfeasibilityReport">
            <summary>Infeasibility report from the solver. 
            </summary>
            <remarks>
            This property can be overriden by a derived class to provide
            infeasibility information.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.InteriorPointReport">
            <summary>Contains information about the current solution for models solved by the InteriorPointSolver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.InteriorPointReport.SupportsSolutionDetails">
            <summary>
            Determine if solution details can be returned.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.InteriorPointReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.InteriorPointReport.Statistics">
            <summary> Interior point algorithm solution metrics.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexReport">
            <summary>Contains information about the current solution for models solved by SimplexSolver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplexReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexReport.Statistics">
            <summary> Simplex algorithm solution metrics.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplexReport.InitialBasisUsed">
            <summary>The kind of initial basis used
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport">
            <summary>Constraint solver report.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.CspSolutionMapping)">
            <summary>Create a new instance.
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The solver object.</param>
            <param name="solution">The solution.</param>
            <param name="solutionMapping">The solution mapping.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.Algorithm">
            <summary>The CSP search algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.MoveSelection">
            <summary>Move selection heuristic for local search.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.ValueSelection">
            <summary>Value ordering heuristic for tree search.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.VariableSelection">
            <summary>Variable ordering heuristic for tree search.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ConstraintProgrammingReport.BacktrackCount">
            <summary>Number of backtracks during solve for tree search.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.MsfException">The solution is out of date.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport">
            <summary>Contains information about the current solution for models solved by the CompactQuasiNewtonSolver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.PluginSolutionMapping)">
            <summary>Constructor of a report for any CompactQuasiNewton model
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The ISolver that solved the model.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A PluginSolutionMapping instance.</param>
            <exception cref="T:System.ArgumentNullException">context, solver and solution must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.ToleranceDifference">
            <summary>Gets the difference between the solution tolerance and the tolerance
            requested by the caller.
            </summary>
            <remarks>
            The solver tolerance is set using CompactQuasiNewtonSolverParams.
            If a call to Solve() returns CompactQuasiNewtonSolutionQuality.LocalOptimum
            then this value will be zero or less.  If a local optimum is found even
            though the stopping criterion is not met, the final tolerance is considered
            to be zero and the ToleranceDifference will be the negated version of
            the requested tolerance.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.IterationCount">
            <summary> The number of iterations that have been performed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.EvaluationCallCount">
            <summary> The number of function evaluation calls.
            Each call is for both funtion and gradient evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.CompactQuasiNewtonReport.CompactQuasiNewtonSolutionQuality">
            <summary> The detailed quality of solution from Compact Quasi Newton solver
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NelderMeadReport">
            <summary>Contains information about the current solution for models solved by the NelderMeadSolver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NelderMeadReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.PluginSolutionMapping)">
            <summary>Creates a new instance.
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The ISolver that solved the model.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A PluginSolutionMapping instance.</param>
            <exception cref="T:System.ArgumentNullException">context, solver and solution must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.NelderMeadReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.IterationCount">
            <summary> The number of iterations that have been performed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.AcceptedExpansionsCount">
            <summary>Number of times the expanded point was accepted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.RejectedExpansionsCount">
            <summary>Number of times the expanded point was rejected (using the reflected point).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.RejectedContractionsCount">
            <summary>Number of times the contracted point was rejected (regenerating the simplex).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.AcceptedContractionsCount">
            <summary>Number of times the contracted point was accepted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.AcceptedReflectionsCount">
            <summary>Number of times the reflected point was accepted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.EvaluationCallCount">
            <summary> The number of function evaluation calls.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.SmallSimplexCount">
            <summary>Number of times a small simplex was encountered.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.NelderMeadReport.NelderMeadResult">
            <summary> The type of result of the NelderMead solver.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.HybridLocalSearchReport">
            <summary>Contains information about the current solution for models solved by the CompactQuasiNewtonSolver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.HybridLocalSearchReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.PluginSolutionMapping)">
            <summary>Constructor of a report for any  HybridLocalSearch model
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solver">The ISolver that solved the model.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A PluginSolutionMapping instance.</param>
            <exception cref="T:System.ArgumentNullException">context, solver and solution must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.HybridLocalSearchReport.GenerateReportSolverDetails(System.Text.StringBuilder,System.IFormatProvider)">
            <summary>Adds the solver details to the string builder.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.HybridLocalSearchReport.SupportsSolutionDetails">
            <summary>
            Determine if solution details can be returned.
            </summary>
            <returns>true if can, false otherwize</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.HybridLocalSearchReport.StepCount">
            <summary>Step count of the search when it is running
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.HybridLocalSearchReport.Violation">
            <summary>Constraints violation. Zero stands for no violation (feasible solution), 
            and the smaller Violation is the more solution tends toward feasibility.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.GenericReport">
            <summary>
            A generic Report from any solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.GenericReport.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.PluginSolutionMapping)">
            <summary>
            Instantiates a GenericReport
            </summary>
            <param name="context"></param>
            <param name="solver"></param>
            <param name="solution"></param>
            <param name="solutionMapping"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ReportVerbosity">
            <summary>
            Verbosity options for Solution.GetReport.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.SolverDetails">
            <summary>
            Include information about the algorithm used by the solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.Decisions">
            <summary>
            Include the values of all decisions.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.Sensitivity">
            <summary>
            Include sensitivity information if available.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.Directives">
            <summary>
            Include all directives passed to Solve.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.Infeasibility">
            <summary>
            Include infeasibility information (if available).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ReportVerbosity.All">
            <summary>
            Include everything.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SamplingMethod">
            <summary>Sampling method: Monte Carlo or Latin Hypercube.
            In Automatic mode the sampling method will be selected automatically 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingMethod.Automatic">
            <summary>Automatic.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingMethod.NoSampling">
            <summary>No sampling.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingMethod.MonteCarlo">
            <summary>Monte Carlo
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingMethod.LatinHypercube">
            <summary>Latin Hypercube
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SamplingEngine">
            <summary>
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingEngine._strata">
            <summary>
            Each stratum has 1/number of samples
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SamplingEngine._shuffles">
            <summary>
            This is mapping from distributed Value, sample number --> stratum to sample with
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SamplingEngine.GetAllScenarios(Microsoft.SolverFoundation.Services.DistributedValue[],System.Int32,Microsoft.SolverFoundation.Services.SamplingMethod)">
            <summary>
            Sample from the distributions, gets back sampleCount samples of the  Creates the scenarios, for each scenario sets value for the IDistributedValues and returns
            the probability of the scenario. Hydrator should build the second stage constraints/part of goal 
            when iterating over the scenarios
            </summary>
            <returns>enumaration of probability of each scenario</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SamplingEngine.Init(System.Int32,Microsoft.SolverFoundation.Services.DistributedValue[],Microsoft.SolverFoundation.Services.SamplingMethod)">
            <summary> Prepare to generate scenarios.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SamplingEngine.FillShuffles(System.Int32,Microsoft.SolverFoundation.Services.DistributedValue[])">
            <summary>
            Fills the shuffle mapping, using modification of Durstenfeld for Fisher and Yates' algorithm
            Durstenfeld, Richard (July 1964). "Algorithm 235: Random permutation"
            for example, when sampleCount is 5 and ranomValuesCount is 3
            0 1 2 3 4  
            1 3 2 4 0
            2 1 4 0 3
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SamplingEngine.Context">
            <summary>
            For not using GetContext() each time
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.PseudoRandom">
             <summary>
             Abstract pseudo-random number generator. Use the various Create methods to create instances.
            
             The periods are large (at least 2^19937 - 1) and the generators pass both the DIEHARD and NIST tests.
             </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.Create">
            <summary>
            Return the default pseudo-random number generator--a high quality linear algorithm.
            The same sequence of numbers will be returned for every run of the algorithm. But different
            instances will typically produce different sequences.
            REVIEW shahark: i believe the unchecked is unnecessary, as it happens by default
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.Create(System.UInt32)">
            <summary>
            Return the default pseudo-random number generator--a high quality linear algorithm.
            The same sequence of numbers will be returned for every run of the algorithm with the same seed.
            Different seeds will result in different sequences.
            </summary>
            <param name="seed">The seed to initialize the pseudo-random number generator with.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.Create(System.Int32)">
            <summary>
            Return the default pseudo-random number generator--a high quality linear algorithm.
            The same sequence of numbers will be returned for every run of the algorithm with the same seed.
            Different seeds will result in different sequences.
            </summary>
            <param name="seed">The seed to initialize the pseudo-random number generator with.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.CreateVerification">
            <summary>
            Return the verification pseudo-random number generator--a high quality nonlinear algorithm.
            This generator is slower than the one returned by default and is intended for validating
            results to guard against unforeseen flaws in the default generator.
            The same sequence of numbers will be returned for every run of the algorithm. But different
            instances will typically produce different sequences.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.CreateVerification(System.UInt32)">
            <summary>
            Return the verification pseudo-random number generator--a high quality nonlinear algorithm.
            This generator is slower than the one returned by default and is intended for validating
            results to guard against unforseen flaws in the default generator.
            The same sequence of numbers will be returned for every run of the algorithm with the same seed.
            Different seeds will result in different sequences.
            </summary>
            <param name="seed">The seed to initialize the pseudo-random number generator with.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.CreateVerification(System.Int32)">
            <summary>
            Return the verification pseudo-random number generator--a high quality nonlinear algorithm.
            This generator is slower than the one returned by default and is intended for validating
            results to guard against unforseen flaws in the default generator.
            The same sequence of numbers will be returned for every run of the algorithm with the same seed.
            Different seeds will result in different sequences.
            </summary>
            <param name="seed">The seed to initialize the pseudo-random number generator with.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextUInt32">
            <summary>
            Return a uniform pseudo-random number in the range [0, UInt32.MaxValue] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextBytes(System.Byte[])">
            <summary>
            Return a series of pseudo-random bytes suitable for simulation work.
            Note: this byte sequence is not cryptographically secure.
            </summary>
            <param name="bytes">The array of bytes to fill.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextSingle">
            <summary>
            Return a single precision uniform pseudo-random number in the range [0,1] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextSingle(Microsoft.SolverFoundation.Services.Interval{System.Single})">
            <summary>
            Return a single precision uniform pseudo-random number in the range lowerBound...upperBound suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <param name="interval">Interval</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextDouble">
            <summary>
            Return a double precision uniform pseudo-random number in the range [0,1] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextDoubleGreaterThan0">
            <summary>
            Return a double precision uniform pseudo-random number in the range (0,1] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextDoubleGreaterThan0LessThan1">
            <summary>
            Return a double precision uniform pseudo-random number in the range (0,1) suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextDoubleLessThan1">
            <summary>
            Return a double precision uniform pseudo-random number in the range [0,1) suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PseudoRandom.NextDouble(Microsoft.SolverFoundation.Services.Interval{System.Double})">
            <summary>
            Return a double precision uniform pseudo-random number in the range lowerBound...upperBound suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <param name="interval">Interval</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RijndaelPseudoRandom">
             <summary>
             Pseudo-random number generator based on the Rijndael algorithm.
             Used for verifing the MersenneTwisterPseudoRandom sequence.
             
             Essentially the idea is to take the output of the MersenneTwisterPseudoRandom and
             encrypt it with the Rijndael algorithm in code book mode. This gives a nonlinear
             list of pseudo-random numbers with a very high period and reasonably good efficiency.
             The algorithm works because Rijndael has good bit dispersion and the input sequence
             has a good period and bit distribution. The paper below recommends the sequence 0, 1, 2, ...
             but this has a low period and poor bit distribution.
            
             Algorithm based on
             Peter Hellekalek and Stefan Wegenkittl, Empirical Evidence Concerning AES
             ACM Transactions on Modeling and Computer Simulation, Vol. 13, No. 4, October 2003, Pages 322–333
             
             Because the Rijndael algorithms block size does not fit evenly into the Mersenne twisters period,
             the period is large >>2^19937 - 1. The generator passes both the DIEHARD and NIST tests.
             
             </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RijndaelPseudoRandom.#ctor(System.UInt32)">
            <summary>
            Create a new sequence of random numbers based on a seed.
            </summary>
            <param name="seed">The seed to base the generator on.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RijndaelPseudoRandom.FillBuffer">
            <summary>
            If necessary fill the buffer with random bytes.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RijndaelPseudoRandom.NextUInt32">
            <summary>
            Return a uniform pseudo-random number in the range [0,0xffffffff] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <remarks>
            The Rijndael algorithm is being used with fixed and easily discoverable keys thus the resulting numbers
            are not suitable for cryptographic uses.
            </remarks>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MersenneTwisterPseudoRandom">
             <summary>
             Pseudo-random number generator based on the Mersenne Twister algorithm.
            
             Makoto Matsumoto and Takuji Nishimura
             "Mersenne Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random Number Generator"
             ACM Transactions on Modeling and Computer Simulation, Vol. 8, No. 1, January 1998, Pages 3–30.
             
             The period is large 2^19937 - 1 and the generator passes both the DIEHARD and NIST tests.
             
             </summary>
             <remarks>
             The original algorithm used 64 bit arithmetic heavily. Since CLR 64 bit integer arithmetic is slow on
             x86 architectures, I have converted it to use 32 bit integer arithmetic where possible.
             </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MersenneTwisterPseudoRandom.#ctor(System.UInt32)">
            <summary>
            Create a new sequence of random numbers based on a seed.
            </summary>
            <param name="seed">The seed to base the generator on.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MersenneTwisterPseudoRandom.BuildSeeds">
            <summary>
            If the current list of seeds is exhausted build a new list.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.MersenneTwisterPseudoRandom.NextUInt32">
            <summary>
            Return a uniform pseudo-random number in the range [0,0xffffffff] suitable for simulation work.
            Note: this number is not cryptographically secure.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenarioGenerator.GetAllScenarios">
            <summary>
            Creates the scenarios. For each scenario sets value for the IDistributedValues and returns
            the probability of the scenario. 
            </summary>
            <remarks>
            Each call will start with the same seed and same numbers.
            </remarks>
            <returns>enumaration of probability of each scenario</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenarioGenerator.GetAllScenarios(System.Boolean)">
            <summary>
            Creates the scenarios. For each scenario sets value for the IDistributedValues and returns
            the probability of the scenario. 
            </summary>
            <param name="startOver">Whether to start over (so that same scenarios come back each time).</param>
            <returns>enumaration of probability of each scenario</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ScenarioGenerator.GetAllScenarios(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Recursive method for getting all scenarion for the finite case
            When yeilding a result each IDistributedValue has its CurrentValue set to a fix number 
            that belongs to this scenario
            Remark: Rational values are converted to double here
            </summary>
            <param name="distributedValuePlace">which Distributed Value is being changed now</param>
            <param name="comulativeProbability">comulative probability for this scenario considering all predecessors DistributionValue</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenarioGenerator.SampleCount">
            <summary>The number of samples taken.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenarioGenerator.RandomSeed">
            <summary>Random seed
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenarioGenerator.SamplingNeeded">
            <summary>Indicates if sampling will be used for scenario generation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenarioGenerator.SamplingMethod">
            <summary>The sampling method.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ScenarioGenerator.ScenarioCount">
            <summary>The total number of independent scenarios in the model.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Set">
            <summary>A Set represents a set of values within a Domain.
            </summary>
            <remarks>
            A Set is an unordered collection of items that is used to create indexed Parameter
            or Decision objects. Sets are also used in Foreach and FilteredForeach expressions.
            The items in a Set are established by data binding the Parameters and Decisions in which
            the Set appears.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Set._valueSet">
            <summary>
            A ValueSet representing the actual values. Constructed during data binding, and thrown out after the solver has been hydrated.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Set._addValueTableElement">
            <summary>
            Adds a data element to the internal ValueTable.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if duplicate or out-of-range data is detected in the model.</exception>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Set._domain">
            <summary>
            The domain which all the values of this set belong to.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.Set._name">
            <summary>
            The name of the Set. Provided by the user. Not necessarily unique.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.#ctor(Microsoft.SolverFoundation.Services.Domain,System.String)">
            <summary>
            Create a new set
            </summary>
            <param name="domain">The Domain for values of this set.</param>
            <param name="name">The name of the set.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.#ctor(Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Create a set of numbers with a given start, limit, and step.
            </summary>
            <param name="start"></param>
            <param name="limit"></param>
            <param name="step"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.#ctor(Microsoft.SolverFoundation.Services.Term[],Microsoft.SolverFoundation.Services.Domain,System.String)">
            <summary>
            Create a set with fixed values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.#ctor(Microsoft.SolverFoundation.Services.Term[])">
            <summary>
            Create a set with fixed values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.Microsoft#SolverFoundation#Services#IDataBindable#DataBind(Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>
            Create the ValueSet object at the beginning of data binding. The actual data is added as a side effect
            of Parameter.DataBind.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.SetBinding``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Binds the set to data. The data must be in the form of a sequence of
            objects, where each object has a property for the value for a set element.
            
            The data is read each time Context.Solve() is called.
            </summary>
            <param name="binding">A sequence of objects, one for each set element.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A property or field isn't found.</exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Set.ToString">
            <summary>
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.Binding">
            <summary>The binding for this Set (optional).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.FixedLimit">
            <summary>The limiting element in a fixed range Set (if any).
            </summary>
            <remarks>
            This property is null if this Set is not defined by a range.
            This element does not actually belong to the set.</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.FixedStart">
            <summary>The first element in a fixed range Set (if any).
            </summary>
            <remarks>
            This property is null if this Set is not defined by a range.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.FixedStep">
            <summary>The step in a fixed range Set (if any).
            </summary>
            <remarks>
            This property is null if this Set is not defined by a range.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.IsConstant">
            <summary>Indicates whether the values for the Set were established upon creation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.IsLocked">
            <summary>Indicates whether additional values may be added to a Set, for example by data binding operations on Parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.Name">
            <summary>
            The name of the set.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.ValueSet">
            <summary>
            A ValueSet representing the actual values. Constructed during data binding, and thrown out after the solver has been hydrated.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Set.ItemValueClass">
            <summary>
            The type of each element of the set.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SecondOrderCone">
            <summary>Second order cone information.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderCone.#ctor(System.Object,System.Int32,Microsoft.SolverFoundation.Services.SecondOrderConeType)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderCone.AddVid(System.Int32,System.Boolean)">
            <summary>Add a vid to the cone.
            </summary>
            <param name="vid">A row variable index.</param>
            <param name="isPrimary">Specifies if the var is a primary conic variable.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderCone.ContainsVid(System.Int32)">
            <summary>Check if a vid belongs to the cone.
            </summary>
            <param name="vid">A row variable index.</param>
            <returns>Returns true if the vid belongs to the cone.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderCone.RemoveVid(System.Int32)">
            <summary>Remove a vid from the cone.
            </summary>
            <param name="vid">A row variable index.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderCone.ToString">
            <summary> The string representation of the cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.PrimaryVid1">
            <summary> The primary conic variable.  For a quadratic cone it is x1 where
            x1 >= || x2 ||, x1 > 0.
            </summary>
            <remarks>
            -1 means there is no primary conic variable - the cone is empty.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.PrimaryVid2">
            <summary> The secondary conic variable.  For a rotated quadratic cone it is x2 where
            x1 x2 >= || x3 ||, x1, s2 > 0.
            </summary>
            <remarks>
            -1 means either the cone is not rotated, or there are fewer than 2 conic vars.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.Vids">
            <summary> The VIDs that belong to this cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.VidCount">
            <summary> The number of VIDs that belong to this cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.ConeType">
            <summary> The second order cone type.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.Index">
            <summary> The cone index (vid) of this cone.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderCone.Key">
            <summary> The cone key.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SecondOrderConicModel">
            <summary>Encapsulates a second order conic optimization problem.
            </summary>
            <remarks>
            Second order conic (SOCP) models are distinguished from linear models by
            the use of conic constraints.  Cones come in two types: quadratic and rotated
            quadratic.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SecondOrderConicModel._mpcidcone">
            <summary> Map from cone index to cone info.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>Create a new instance.
            </summary>
            <param name="comparer">The IEqualityComparer used to map from key to row/variable (optional).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.AddRow(System.Object,Microsoft.SolverFoundation.Services.SecondOrderConeType,System.Int32@)">
            <summary> Add a reference row for a second order cone. Each cone has one reference row.
            </summary>
            <param name="key">A second order cone key</param>
            <param name="coneType">Second order cone type</param>
            <param name="vidRow">the vid of the reference row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.SetPrimaryConic(System.Int32,System.Int32)">
            <summary> Specifies a primary variable for a cone.  
            </summary>
            <param name="vidRow">The reference row for the cone.</param>
            <param name="vid">The vid of the variable.</param>
            <returns></returns>
            <remarks>
            Quadratic cones have one primary variable.  SetPrimaryConic must be called twice for rotated quadratic cones
            because they have two primary variables.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.TryGetConeFromIndex(System.Int32,Microsoft.SolverFoundation.Services.ISecondOrderCone@)">
            <summary>Gets cone information given a reference row vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.AddRow(System.Object,System.Int32,Microsoft.SolverFoundation.Services.SecondOrderConeRowType,System.Int32@)">
            <summary>Adds a new conic row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.SetCoefficient(System.Int32,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set the coefficient of the A matrix in the linear model. If num is zero, the entry is removed. 
            </summary>
            <param name="vidRow">a row id </param>
            <param name="vidVar">a column/variable id</param>
            <param name="num">a value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.IsConicRow(System.Int32)">
            <summary>Indicates whether a row is a conic row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.GetConicRowCount(System.Int32)">
            <summary> Return the row count for the specified cone.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.GetConicRowIndexes(System.Int32)">
            <summary> Return the rows for the specified cone.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.LoadSecondOrderConicModel(Microsoft.SolverFoundation.Services.ISecondOrderConicModel)">
            <summary> Inject the given SecondOrderConicModel into this model, removing all previous information.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.ValidateSecondOrderConeRowType(Microsoft.SolverFoundation.Services.SecondOrderConeRowType)">
            <summary> Validates a SecondOrderConeRowType.
            </summary>
            <param name="rowType">SecondOrderConeRowType.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SecondOrderConicModel.ValidateConeVid(System.Int32)">
            <summary> Validates a cone VID.
            </summary>
            <param name="vidCone">A VID.</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderConicModel.ConeCount">
            <summary>Return the number of cones. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderConicModel.Cones">
            <summary>Return the cone collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SecondOrderConicModel.IsSocpModel">
            <summary> Indicates whether the model contains any second order cones.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Solution">
            <summary> A Solution represents the result of solving a model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Solution.GetNext">
            <summary>
            Get the next solution.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Solution.GetReport">
            <summary>Gets a report on the solution to the current model.
            </summary>
            <remarks>Uses ReportVerbosity.All and CultureInfo.CurrentCulture as the default Verbosity and IFormatProvider</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Solution.GetReport(Microsoft.SolverFoundation.Services.ReportVerbosity)">
            <summary>Gets a report on the solution to the current model.
            </summary>
            <remarks>Uses CultureInfo.CurrentCulture as the default IFormatProvider</remarks>
            <param name="verbosity">The default verbosity to be used in string representation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Solution.GetReport(Microsoft.SolverFoundation.Services.ReportVerbosity,System.IFormatProvider)">
            <summary>Gets a report on the solution to the current model.
            </summary>
            <param name="verbosity">The default verbosity to be used in string representation</param>
            <param name="format">The default format to be used in string representation</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Solution.Quality">
            <summary>
            The quality of this solution (optimal, feasible, infeasible, or unknown).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Solution.Goals">
            <summary>
            All the goals of the model with their solution values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Solution.Decisions">
            <summary>
            All the decisions of the model, with their values for this solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Solution.Directive">
            <summary>
            Gets the directive passed to the solver that found this solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Solution.StochasticSolution">
            <summary>
            Encapsulates details about the stochastic solution
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverProperties">
            <summary>The names of properties that can be retrieved by events
            </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.SolverName">
            <summary>The name of the solver class.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.VariableLowerBound">
            <summary>Lower bound on the variable as a Double.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.VariableUpperBound">
            <summary>Lower bound on the variable as a Double.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.SolveState">
            <summary>The reason why the solver raised the Solve event as a String.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.GoalValue">
            <summary>The current best value for the first goal in the model as a Double.
            </summary>
            <remarks>For goaless model returns NaN.</remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.IterationCount">
            <summary>Iteration count as an Int32.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverProperties.VariableStartValue">
            <summary>The initial value for a variable as a Double.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.InteriorPointProperties">
            <summary>Properties that can be retrieved by events raised by the Interior Point solver.
            </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointProperties.AbsoluteGap">
            <summary>Absolute duality gap as a Double.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointProperties.PrimalObjectiveValue">
            <summary>The primal objective value as a Double.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.InteriorPointProperties.DualObjectiveValue">
            <summary>The dual objective value as a Double.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplexProperties">
            <summary>Properties that can be retrieved by events raised by the Simplex solver.
            </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexProperties.PivotCount">
            <summary>
            The pivot count property indicates the number of simplex pivots performed as an Int32.
            Generally these include both major and minor pivots.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexProperties.FactorCount">
            <summary>
            The factor count property indicates the number of basis matrix LU factorizations performed as an Int32.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexProperties.BranchCount">
            <summary>
            The BranchCount property indicates the number of branches performed when applying the branch and bound algorithm to a MILP. 
            The value is returned as an Int32.
            </summary>
            <remarks>If the model has no integer variables, this will be zero.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SimplexProperties.MipGap">
            <summary>
            Used by MIP to indicate the difference between an integer solution to a relaxed solution as a Double.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.CompactQuasiNewtonProperties">
            <summary>Properties that can be retrieved by events raised by the Compact Quasi Newton (CQN) solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.CompactQuasiNewtonProperties.EvaluationCount">
            <summary>Number of calls to the function and gradient evaluators as a long.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.CompactQuasiNewtonProperties.CurrentTerminationCriterion">
            <summary>Current tolerance calculated as a double.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NelderMeadProperties">
            <summary>Properties that can be retrieved by events raised by the NelderMeadSolver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NelderMeadProperties.EvaluationCount">
            <summary>Number of calls to the evaluation function as a long.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.NelderMeadProperties.CurrentTerminationCriterion">
            <summary>Current tolerance calculated as a double.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.PluginSolverCollection">
            <summary> Helper class for the solver plugin section in the configuration file
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.Contains(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Determine if a registration entry exists.
            </summary>
            <param name="item">The solver registration information.</param>
            <returns>Returns true if the solver has been registered.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolverRegistrations">
            <summary>All registration entries.
            </summary>
            <returns>All registration entries as an IEnumerable.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetDirectiveType(Microsoft.SolverFoundation.Services.SolverRegistration)">
            <summary>Return the Type of the directive associated with a registration entry.
            </summary>
            <returns>A Type object for the directive, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.CopyTo(Microsoft.SolverFoundation.Services.SolverRegistration[],System.Int32)">
            <summary>Copy registration entries to an Array.
            </summary>
            <param name="array">The destination array.</param>
            <param name="arrayIndex">The start index.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.IsValidClass(System.Reflection.Assembly,System.String,System.String,System.Type,System.Type@)">
            <summary> Test if class exists in the assembly and implements correct interface or is a subclass of the given class
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.LoadSolverAssembly(System.String,System.String,System.Reflection.Assembly@)">
            <summary>
            Load the solver assembly defined in reg
            </summary>
            <returns>true if and only if the assembly has not been loaded into the current AppDomain yet</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetPluginSolver(System.Type,Microsoft.SolverFoundation.Services.ISolverEnvironment)">
            <summary> Create an ISolver instance from the given registration info
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolverFoundationSolver(Microsoft.SolverFoundation.Services.SolverCapability,Microsoft.SolverFoundation.Services.ISolverEnvironment,Microsoft.SolverFoundation.Services.SolverCapabilityFlags)">
            <summary> Decide which Solver Foundation solver is suitable for capability 
                      given no directive
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.HasRegistered(Microsoft.SolverFoundation.Services.SolverCapability,System.Type,System.Type,System.Nullable{Microsoft.SolverFoundation.Services.PluginSolverCollection.PluginSolverInfo}@)">
            <summary> Check if the solver has been registered with the given capability and interface type.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.ValidateAccess">
            <summary> Validate if the access to this instance is OK.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown when the instance is not initialized</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.#ctor">
            <summary> Create a plugin solver collection class instance.
            </summary>
            <remarks>Must call Initialize() before using the instance</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.Initialize">
            <summary> Initialize the instance by preloading the registered assemblies and gathering the type info.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolverFoundationSolver(Microsoft.SolverFoundation.Services.SolverCapability,Microsoft.SolverFoundation.Services.Directive,Microsoft.SolverFoundation.Services.ISolverEnvironment,Microsoft.SolverFoundation.Services.SolverCapabilityFlags)">
            <summary> Decide which Solver Foundation solver is suitable given the capability and the directive
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolverParams(Microsoft.SolverFoundation.Services.SolverCapability,System.Type,Microsoft.SolverFoundation.Services.ISolver,Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Return the parameter object for the given solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetPluginSolverSection">
            <summary> Retrieve all registered solvers under MsfPluginSolvers section group
            </summary>
            <remarks>Current we do not support hosted environment</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.CreatePluginSolverCollection">
            <summary> Create a PluginSolverCollection instance and initialize it by preloading all registered solver assemblies and gathering necessary type info
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolvers(Microsoft.SolverFoundation.Services.SolverCapability,System.Boolean,Microsoft.SolverFoundation.Services.Directive,Microsoft.SolverFoundation.Services.ISolverEnvironment,Microsoft.SolverFoundation.Services.SolverCapabilityFlags)">
            <summary> Return the default registered ISolver instance with the given capability (could be null)
            </summary>
            <param name="cap">Capability required</param>
            <param name="isModelStochastic">Is model Stochastic</param>
            <param name="dir">Directive</param>
            <param name="context">Solver context (cannot be null)</param>
            <param name="flags">Capability flags</param>
            <remarks>Return the registered solver such that, if we can find a registered solver that has the directive class 
            equals the type of dir, we return that solver; otherwise, we return the first registered solver with the capability. If
            no such solvers are registered, we return our solvers.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.PluginSolverCollection.GetSolvers(Microsoft.SolverFoundation.Services.SolverCapability,Microsoft.SolverFoundation.Services.Directive,Microsoft.SolverFoundation.Services.ISolverEnvironment)">
            <summary>Return a sequence of registered ISolver instance with the given capability.
            </summary>
            <param name="cap">Capability required</param>
            <param name="dir">Directive</param>
            <param name="context">Solver context (cannot be null)</param>
            <remarks>Registered default solver is always returned first</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.PluginSolverCollection.Count">
            <summary>The number of registered solvers.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverContext">
            <summary>This class provides methods for creating, loading, saving, and solving models.
            A new instance is obtained using the static GetContext method. This class is multi-thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.#ctor">
            <summary>
            Construct a solver service context.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.GetContext">
            <summary>Returns the singleton context.
            </summary>
            <returns>Singleton context.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.CreateModel">
            <summary>Constructs an empty model.
            </summary>
            <remarks>This method can only be called when there is no active model in the context.
            </remarks>
            <returns>Newly created model.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if the context already contains a model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.ClearModel">
            <summary>
            Clears the current model so a new one can be created.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.PropagateDecisions">
            <summary>
            Write decision values from the current solution back to the database.
            </summary>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">A decision data binding contained an out-of-range index.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.Solve">
            <summary>Solve the constructed and loaded model. This is a blocking call.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.CheckModel">
            <summary>Check the model for obvious errors. If any are found, throws an exception.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.Solve(Microsoft.SolverFoundation.Services.Directive[])">
            <summary>Solve the constructed and loaded model.  This is a blocking call.
            </summary>
            <param name="directives">An array of Directive objects that specify how the model is to be solved.</param>
            <returns>A Solution object.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.UnsolvableModelException">Thrown when no solver can accept the model.</exception>
            <exception cref="T:System.ArgumentException">Thrown when an empty directives array is supplied.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.Solve(System.Func{System.Boolean},Microsoft.SolverFoundation.Services.Directive[])">
            <summary>Solve the constructed and loaded model.  This is a blocking call.
            </summary>
            <param name="directives">An array of Directive objects that specify how the model is to be solved.</param>
            <returns>A Solution object.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.UnsolvableModelException">Thrown when no solver can accept the model.</exception>
            <param name="queryAbort"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.AbortAsync">
            <summary>
            Abort a current Solve() operation. May be called asynchronously from any thread.
            If no Solve() is running, does nothing.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.Solve(Microsoft.SolverFoundation.Services.Model,System.Func{System.Boolean},Microsoft.SolverFoundation.Services.Directive[])">
            <exception cref="T:Microsoft.SolverFoundation.Common.UnsolvableModelException">Thrown when no solver can accept the model.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.SaveModel(Microsoft.SolverFoundation.Services.FileFormat,System.IO.TextWriter)">
            <summary>
            Saves a model in MPS or OML format.
            </summary>
            <param name="format">The output format.</param>
            <param name="writer">A TextWriter where the output will be written to.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.LoadModel(Microsoft.SolverFoundation.Services.FileFormat,System.String)">
            <summary>
            Load a model from a file.
            </summary>
            <param name="format">OML, MPS or SMPS.</param>
            <param name="path">For MPS and OML exact path to the file is needed.
            For SMPS files, the path represents the core file, or a directory. 
            In the first case the other two files (stoch and time) should be in the same directory as the core file and 
            their prefix should be the same to the core file. The path can be also be to the "time" file or the "stoch" file
            In the latter case the directory should contain the "core", "stoch" and "time" files
            with a prefix which is identical to the directory name.
            Suffixes supported - Core files: .cor, .core. Time files: .tim, .time.
            Stoch files: .sto, .stoch.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.LoadModel(Microsoft.SolverFoundation.Services.ILinearModel)">
            <summary>
            Import an ILinearModel.
            </summary>
            <param name="linearModel">An ILinearModel containing a model to be imported.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.LoadModel(Microsoft.SolverFoundation.Services.ITermModel)">
            <summary>
            Import an ITermModel.
            </summary>
            <param name="termModel">An ITermModel containing a model to be imported.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.LoadModel(Microsoft.SolverFoundation.Services.FileFormat,System.IO.TextReader)">
            <summary>
            Reads a model, for example in MPS or OML format.
            </summary>
            <param name="format">The input format.</param>
            <param name="reader">A TextReader with the model data.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.LoadSmpsModel(System.String,System.Boolean)">
            <summary>
            Loads the SMPS files and transfer it to Term tree
            </summary>
            <param name="path">path to core file or directory</param>
            <param name="isFixed">currently always true</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.ExportModelToCSharp(System.IO.TextWriter)">
            <summary>Exports the current model to C# code.
            </summary>
            <param name="writer">A TextWriter where the output is written.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.FindAllowedValues(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.DecisionBinding})">
            <summary>
            Finds all allowed values for a set of decision. An allowed value is one which is part of some feasible solution of the problem.
            This is much more efficient than enumerating all feasible solutions to find the allowed values.
            </summary>
            <param name="decisions">The decisions to find allowed values for.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.FindAllowedValues(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.DecisionBinding},System.Func{System.Boolean},Microsoft.SolverFoundation.Services.Directive[])">
            <summary>
            Finds all allowed values for a set of decision. An allowed value is one which is part of some feasible solution of the problem.
            This is much more efficient than enumerating all feasible solutions to find the allowed values.
            </summary>
            <param name="decisions">The decisions to find allowed values for.</param>
            <param name="queryAbort">A function which will be called periodically during the computation. If it returns true, computation is aborted.</param>
            <param name="directives">A series of directives to use when solving.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.SolveModel(Microsoft.SolverFoundation.Services.Model,System.Func{System.Boolean},System.Diagnostics.Stopwatch,System.Diagnostics.Stopwatch,System.Diagnostics.Stopwatch,Microsoft.SolverFoundation.Services.Directive[])">
            <exception cref="T:Microsoft.SolverFoundation.Common.UnsolvableModelException">Thrown when no solver can accept the model.</exception>
            <exception cref="T:System.ArgumentException">Thrown when an empty directives array is supplied.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.ClearSolverState(Microsoft.SolverFoundation.Services.SolverContext.SolveState)">
            <summary>
            We have no reason to hold those till the next solve call
            even that the solvers has already been disposed
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.GetQueryAborts(Microsoft.SolverFoundation.Services.SolverContext,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Task},System.Func{System.Boolean})">
            <summary>
            Create innerQueryAbort for each task
            </summary>
            <param name="context"></param>
            <param name="tasks"></param>
            <param name="queryAbort"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.ScheduleTasksToRun(Microsoft.SolverFoundation.Services.SolverContext.SchedulerQueue)">
            <summary>
            Take all tasks from schedulerQueue, build the abort delegate
            and schedule to ThreadPool queue
            </summary>
            <param name="schedulerQueue"></param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.PickWinningTask(Microsoft.SolverFoundation.Services.SolverContext.SolveState)">
            <summary>Pick the best solution from all that were solved up to 
            this point in time 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.GetWaitingTimes(Microsoft.SolverFoundation.Services.Directive[],System.Int64@,System.Int64@)">
            <summary>
            To do this right, we'd need to combine the gate with time limits per thread
            I think we should create an ordered list of time limits and do a wait with timing and check each of the threads.  
            practically speaking we are limited in the number of threads, so I think linear passing through the thread list 
            determining which one(s) to stop are possible.
            Instead, we just use the longest time limit. However, timelimits of infinity (-1) are ignored for deciding the longest.
            </summary>
            <param name="directives">directives</param>
            <param name="timeLimit">-1 for Infinity</param>
            <param name="waitLimit">-1 for Infinity</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.GetUpdatedTimeLimit(System.Int64,System.Diagnostics.Stopwatch[])">
            <summary>
            Time limit should be recalculated each iteration
            </summary>
            <param name="originalTimeLimit"></param>
            <param name="timers">All timers (hydration, data binding and solving</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolverContext.RegisterFinalSolution(Microsoft.SolverFoundation.Services.Task,Microsoft.SolverFoundation.Services.SolverContext.TaskSummary)">
            <summary>Take the candidate and register it as the final solution
            Dispose of the former one if needed
            </summary>
            <param name="task"></param>
            <param name="summary"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.DataSource">
            <summary>
            The database context for bound data.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.CurrentModel">
            <summary>
            Gets or sets the current model loaded into the context.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.SamplingParameters">
            <summary>Random sampling parameters.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.RegisteredSolvers">
            <summary>Get all registered plug-in solvers.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.TraceSource">
            <summary>
            A trace listener which receives informational messages about the SFS.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolverContext.CurrentTimeLimit">
            <summary>
            Current time limit for Solve or GetNext call
            </summary>
        </member>
        <member name="E:Microsoft.SolverFoundation.Services.SolverContext.Solving">
            <summary> An event that fires periodically during Solve.  
            Changing the model during this event (for example by adding or removing decisions or constraints) 
            can cause unpredictable results, and should be avoided.
            </summary> 
            <remarks> Plug-in solver which its pramaters class doesn't implement ISolverEvents can not call for this callback. 
            Expect no calls for this callback during solve</remarks>
        </member>
        <member name="E:Microsoft.SolverFoundation.Services.SolverContext.DataBinding">
            <summary> An event that fires as variables are added to the 
            solver object. 
            Changing the model during this event (for example by adding or removing decisions or constraints) 
            can cause unpredictable results, and should be avoided.
            </summary> 
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverContext.SolveState">
            <summary>
            SolveState encapsulating the state when scheduling and solving
            tasks. It is also used by the Context for sync
            REVIEW shahark: SolveState needs to carefully initiated when getting to the next iteration
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SamplingParameters">
            <summary>Random sampling parameters for the SolverContext.
            </summary>
            <remarks>Sampling parameters apply to all models created using the SolverContext.
            Stochastic options are set using the StochasticDirective class.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SamplingParameters.#ctor">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SamplingParameters.#ctor(Microsoft.SolverFoundation.Services.SamplingParameters)">
            <summary>A copy ctr
            </summary>
            <param name="samplingParameters"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SamplingParameters.SampleCount">
            <summary>How many samples should be taken.
            Use 0 for automatic mode (Default)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SamplingParameters.SamplingMethod">
            <summary>Sampling method: Monte Carlo or Latin Hypercube.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SamplingParameters.RandomSeed">
            <summary> Random seed for sampling engine. Use 0 for automatic mode (default).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModelTransferrer.#ctor(Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.ILinearModel,Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.SmpsParser)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="linearModel"></param>
            <param name="context"></param>
            <param name="smpsParser">null for NON SMPS file</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearModelTransferrer.GetFullLinearSumTerm(System.Int32)">
            <summary>
            This one actually gets the line as a sum and will be used just for stochastic
            as for large MPS its memory usage is too big
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModelTransferrer">
            <summary>Transfers a model to ITermModel.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelTransferrer.#ctor(Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.ITermModel,Microsoft.SolverFoundation.Services.SolverContext)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.FileFormat">
            <summary>
            A format which models can be loaded from or saved to.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.FileFormat.OML">
            <summary>
            Optimization Modeling Language format
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.FileFormat.MPS">
            <summary>
            MPS format
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.FileFormat.FreeMPS">
            <summary>
            Free MPS format
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.FileFormat.SMPS">
            <summary>
            SMPS format (Fixed only)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolverQuality">
            <summary>solver result 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.Optimal">
            <summary>The result is optimal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.Feasible">
            <summary>The model is feasible, but the result found was not proven optimal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.Infeasible">
            <summary>The model is infeasible.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.Unbounded">
            <summary>The model is feasible, but there is no optimal solution because the optimal goal value
            is infinite.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.InfeasibleOrUnbounded">
            <summary>The model was proved to have no optimum solution, but the solver was unable to determine
            whether or not it is feasible.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.Unknown">
            <summary>The solver was unable to find a solution or prove the model infeasible.
            This could be because the solver was interrupted, or because the model has no solution but the solver
            was unable to prove it.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.LocalOptimal">
            <summary>The solver found a solution which is locally optimal, but may not be globally optimal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.SolverQuality.LocalInfeasible">
            <summary>The solver found a solution which is locally infeasible, but can not determine if the model is globally infeasible.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ModelReport">
            <summary>
            Encapsulates the validity of a model and any errors found.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ModelReport.IsValid">
            <summary>
            True if the model is valid (has no errors).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ModelReport.Errors">
            <summary>
            A list of errors found in the model.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ValueFeasibilityKnownEventArgs">
            <summary>
            ValueFeasibilityKnown event data.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueFeasibilityKnownEventArgs.#ctor(System.Boolean)">
            <summary>Construct a ValueFeasibilityKnown event argument.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ValueFeasibilityKnownEventArgs.IsFeasible">
            <summary>
            Return whether the sender object (a value) is feasible or not
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Tuples">
            <summary>
            A list of constant value tuples.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Domain})">
            <summary>
            This creates Tuples which can be used as a Random Parameter for Stochastic Programming or for 
            Table Constraints
            </summary>
            <param name="name">The name of the new instance.</param>
            <param name="domains">Domains of the Tuples.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Domain},Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            This creates Tuples which can be used as a Random Parameter for Stochastic Programming or for 
            Table Constraints
            </summary>
            <param name="name">Tuples' name</param>
            <param name="domains">Domains of the Tuples</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar decision</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Domain},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational[]})">
            <summary>
            This creates Tuples which can be used as a Random Parameter for Stochastic Programming or for 
            Table Constraints
            </summary>
            <param name="name">Tuples' name</param>
            <param name="domains">Domains of the Tuples</param>
            <param name="data">The tuple data.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.#ctor(System.String,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Services.Domain},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational[]},Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            This creates Tuples which can be used as a Random Parameter for Stochastic Programming or for 
            Table Constraints
            </summary>
            <param name="name">Tuples' name</param>
            <param name="domains">Domains of the Tuples</param>
            <param name="data">The data.</param>
            <param name="indexSets">The index sets to use. Omit to create a scalar decision</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String[],System.String[])">
            <summary>Binds Tuples to a data source.
            </summary>
            <param name="binding">A sequence of objects, one for each data element.</param>
            <param name="fieldNames">The names of the properties of each input object which contain the values. One for each domain</param>
            <param name="indexFields">The names of the properties of each input object which contain the indexes of the data elements, one for
            each index set which was provided when the Tuples was created.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Tuples.SetBinding``1(System.Collections.Generic.IEnumerable{``0},System.String[])">
            <summary>
            Binds a Tuples to data.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="binding"></param>
            <param name="fieldNames"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Tuples.Name">
            <summary>
            The name of the tuples
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Tuples.Description">
            <summary>
            A description.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.DataBindingEventArgs">
            <summary> Event args for the DataBinding event.
            </summary> 
            <remarks>
            This event is fired for decision objects only, and only
            once per model entity (even if the model entity corresponds to more than one
            solver level entity as in the case of a ForEach constraint).
            </remarks> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Name">
            <summary>The name of the target entity.
            </summary> 
            <remarks>
            Also available through, e.g. ((Decision)Target).Name.  Provided
            for convenience.
            </remarks> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Target">
            <summary>The target entity (a Decision).
            </summary> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Indexes">
            <summary> 
            An IEnumerable of indexes for all solver-level decisions
            that correspond to the Decision.
            </summary> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Item(System.String)">
            <summary>Change or retreive a property by property name.
            </summary> 
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Item(System.String,System.Object[])">
            <summary>Change or retreive a property by property name.
            </summary> 
            <remarks>
            The indexes are used in the case of indexed decisions or constraints.
            </remarks> 
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.DataBindingEventArgs.Directive">
            <summary> Directive identifying the solver.
            </summary> 
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SolvingEventArgs">
            <summary>Event args for the Solving event.
            </summary> 
            <remarks>
            This event is fired at the solver’s discretion.
            </remarks> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolvingEventArgs.Cancel">
            <summary>Terminates the solver that fired the event.
            </summary> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SolvingEventArgs.CancelAll">
            <summary>Terminates the entire Solve operation.
            </summary> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolvingEventArgs.Directive">
            <summary> Directive identifying the solver.
            Any changes to the directive may not be picked up before the next
            call to SolverContext.Solve().
            </summary> 
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SolvingEventArgs.Item(System.String)">
            <summary>Retreive a property by property name.
            </summary> 
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.MpsWriterTask">
            <summary>
            This task is used exclusively for writing MSP/QPS files
            and not for solving.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.LinearSolutionMapping">
            <summary>A class for mapping between Sfs model and a ILinearModel
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.CalculateSecondStageResults(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>Calculate and set the recourseDecision results (avg, min, max) 
            </summary>
            <param name="recourseDecision"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.UpdateSecondStageResults(Microsoft.SolverFoundation.Services.Model,System.Double)">
            <summary>This updates the second stage results when using decomposition
            Called at the end of every iteration for each scenario 
            </summary>
            <param name="model"></param>
            <param name="probability">probability of the scenario</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetGoalCoefficient(Microsoft.SolverFoundation.Services.Decision)">
            <summary>This is called from context when solving stochastic problem 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetSensitivityReport">
            <summary>Getting the Sensitivity report from the linear solver
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetInfeasibilityReport">
            <summary>Getting the Infeasibility report from the linear solver
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetShadowPrice(System.Int32,Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport)">
            <summary>Get specific row's dual value/shadow price
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetAllConstraintBoundsSensitivity(Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport)">
            <summary>Get sensitivity ranges for all constraints.
            </summary>
            <param name="sensitivityReport">An ILinearSolverSensitivityReport.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetConstraintBoundsSensitivity(Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport,Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Get sensitivity ranges for the specified constraint.
            </summary>
            <param name="sensitivityReport">An ILinearSolverSensitivityReport.</param>
            <param name="constraint">The constraint of interest.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetConstraintBoundsSensitivityCore(Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport,System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Get sensitivity ranges for the specified constraint.
            </summary>
            <param name="sensitivityReport">An ILinearSolverSensitivityReport.</param>
            <param name="vidsRows">Enumeration of vids related to a specific constraint.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetVids(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Get a collection of all vids mapping to a constraint
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.LinearSolutionMapping.GetRowRange(System.Int32,Microsoft.SolverFoundation.Services.ILinearSolverSensitivityReport)">
            <summary>Get specific row's sensitivity range
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.CspSolutionMapping">
            <summary>A class for mapping between Sfs model and a ConstraintSystem
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Decision,System.Object[],System.Int32@)">
            <summary>Gets a vid out of a decision
            </summary>
            <param name="decision">A decision</param>
            <param name="indexes">Indexes related to the decision</param>
            <param name="vid">vid related to the decision</param>
            <returns>true if the decision has mapping to a vid, false otherwise</returns>
            <exception cref="T:System.ArgumentNullException">decision and indexes must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Constraint,System.Object[],System.Int32,System.Int32@)">
            <summary>Get vid out of constraint, indexes and part
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks> 
            <param name="constraint">A constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint</param>
            <param name="vid">vid related to the constraint</param>
            <returns>true if constraint has mapping to a vid, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetVid(Microsoft.SolverFoundation.Services.Goal,System.Int32@)">
            <summary>Gets vid out of a Goal
            </summary>
            <param name="goal">A goal</param>
            <param name="vid">vid related to the goal</param>
            <returns>true if the goal has mapping to a vid, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetDecision(System.Int32,Microsoft.SolverFoundation.Services.Decision@,System.Object[]@)">
            <summary>Gets a decision out of vid
            </summary>
            <param name="vid">A vid</param>
            <param name="decision">The decision mapped to the vid</param>
            <param name="indexes">Indexes related to the decision</param>
            <returns>true if the vid has mapping to a decision, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetConstraint(System.Int32,Microsoft.SolverFoundation.Services.Constraint@,System.Object[]@,System.Int32@)">
            <summary>Gets a constraint with indexes and component from vid
            </summary>
            <param name="vid">vid of a row</param>
            <param name="constraint">The constraint mapped to the vid</param>
            <param name="indexes">Indexes related to the constraint</param>
            <param name="component">component of the constraint.
            When single constraint has multiple part 
            (e.g. "5 >= x >= y >= 9") there might be different row for each part. component is zero based.</param>
            <returns>true if the vid has mapping to a Constraint, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.TryGetGoal(System.Int32,Microsoft.SolverFoundation.Services.Goal@)">
            <summary>Gets goal out of a vid
            </summary>
            <param name="vid">A vid</param>
            <param name="goal">The goal mapped to the vid</param>
            <returns>true if the vid has mapping to a goal, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Constraint)">
            <summary>Gets indexes of a constraint
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A constraint</param>
            <returns>A collection of indexes related to the constraint</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.GetIndexes(Microsoft.SolverFoundation.Services.Decision)">
            <summary>Get all indexes of a decision
            </summary>
            <param name="decision">The decision</param>
            <returns>Enumaration of all indexes</returns>
            <exception cref="T:System.ArgumentNullException">decision must not be null</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.GetComponents(Microsoft.SolverFoundation.Services.Constraint,System.Object[])">
            <summary>Get parts of constraint with its indexes
            </summary>
            <remarks>First call to TryGetVid of constraint or GetIndexes ( of constraint) or GetComponents is expensive</remarks>
            <param name="constraint">A Constraint</param>
            <param name="indexes">Indexes related to the constraint</param>
            <returns>A collection of parts related to the constraint</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.CspSolutionMapping.GetNext(Microsoft.SolverFoundation.Services.Model,System.Func{System.Boolean})">
            <summary>Get the next solution.
            </summary>
            <remarks>This method does not register the solution.</remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticModelGenerator">
            <summary>Stochastic model generator.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.#ctor(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.ModelType,Microsoft.SolverFoundation.Services.ModelAnalyzer)">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.TryGetTask(Microsoft.SolverFoundation.Services.Task@)">
            <summary>Called from the task to see if there is already task ready which
            we should work with. The master task should not be rebuilt every iteration.
            This also return the task of a slave if a feasibility task is needed
            </summary>
            <param name="task">The task to be set.</param>
            <returns>True if there is task is set.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.Fill(Microsoft.SolverFoundation.Services.Task)">
            <summary>Called from the Task factory.
            Fill in the master of slave (in the case of decomposition) or the DE
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.FillDeterministicEquivalent(Microsoft.SolverFoundation.Services.LinearStochasticTask)">
            <summary>Fills the task with the Deterministic Equivalent model
            </summary>
            <param name="stochasticTask"></param>
            
            <returns>True if the deteministic Equivalent met the criteria 
            or if (checkCriteria == false)</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.TuneSampleParameters(Microsoft.SolverFoundation.Services.SamplingParameters)">
            <summary>This will use some heuristics to determine the sampling parameters
            </summary>
            <param name="samplingParameters"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticModelGenerator.GetNameForSecondStageDecision(System.String,System.Int32)">
            <summary> Get name for second stage decision.
            </summary>
            <remarks> For now just use the number of scenarios.
            No need to check for duplicates (as for example if user called some other decision "decision_1" 
            as there is no restriction of names duplication anyway in Model
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticModelGenerator.Phase">
            <summary> Solution phase.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticModelGenerator.StochasticState">
            <summary>This class maintains the stages of the stochastic solution
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.StochasticModelGenerator.StochasticState.SecondStageCount">
            <summary> Number of all slaves/scenarios/samples
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticConstraintVisitor">
            <summary>
            This visitor is used for determine if a constraint term belongs to the 
            second stage
            </summary>
            <remarks>Arg type in ITermVisitor is not in use. If a new visitor interface
            is declared with just Result and no Arg, all types will need to implement another Visit method
            so it is better to use the exist one with unused parameter</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticConstraintVisitor.Visit(Microsoft.SolverFoundation.Services.IterationTerm,System.Byte)">
            <summary>
            Should not get here, as i don't care about itarations so i don't
            call it from ForEachTerm and ForEachWhereTerm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticConstraintVisitor.Visit(Microsoft.SolverFoundation.Services.RowTerm,System.Byte)">
            <summary>
            REVIEW shahark: what should i do here?
            </summary>
            <param name="term"></param>
            <param name="reserved"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticGoalVisitor">
            <summary>
            This visitor is used for determine if a goal is valid, stochastic wise.
            A goal is legal it doesn't have term1 * term2 when one of the terms include Decision and 
            the other include RandomParameter
            </summary>
            <remarks>Arg type in ITermVisitor is not in use. If a new visitor interface
            is declared with just Result and no Arg, all types will need to implement another Visit method
            so it is better to use the exist one with unused parameter</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticGoalVisitor.Visit(Microsoft.SolverFoundation.Services.OperatorTerm,System.Byte)">
            <summary>This is the only visitor which actually may add RandomParameterTimesDecision
            to the enum
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticGoalVisitor.Visit(Microsoft.SolverFoundation.Services.IterationTerm,System.Byte)">
            <summary>
            Should not get here, as i don't care about itarations so i don't
            call it from ForEachTerm and ForEachWhereTerm
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StochasticSolution">
            <summary>Stores stochastic solution information.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StochasticSolution.#ctor(Microsoft.SolverFoundation.Services.ScenarioGenerator)">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.ScenarioCount">
            <summary>Number of independent scenarios in the problem.
            (Int32.MaxValue means there are an infinite number.)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.SamplingMethod">
            <summary>Gets the sampling method (or NoSampling).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.SampleCount">
            <summary>Number of samples.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.RandomSeed">
            <summary>Seed for random number generator
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.DecompositionIterations">
            <summary>The number of decomposition iterations (0 if decomposition was not used).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.DecompositionGap">
            <summary>Average gap of the last iteration of the decomposition
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.ExpectedValue">
            <summary>Objective of expected value problem.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.WaitAndSee">
            <summary>Expected value of all wait-and-see problems.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.StochasticSolution.ExpectedResultOfExpectedValue">
            <summary>Expected result of using the ExpectedValue solution
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.Interval`1">
            <summary>An interval over a total order.
            </summary>
            <remarks>
            Need to change to use a sparse set of intervals for most of the applications of this class.
            </remarks>
            <typeparam name="Type"></typeparam>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Interval`1.#ctor(`0,`0)">
            <summary>
            Create the closed interval [lowerBound, upperBound].
            </summary>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.Interval`1.#ctor(`0,Microsoft.SolverFoundation.Services.IntervalBoundKind,`0,Microsoft.SolverFoundation.Services.IntervalBoundKind)">
            <summary>
            Create an interval. Intervals may be open or closed on either side. Intervals with
            closed bounds includes the boundary point and intervals with open bounds do not. Thus
            <code>new Interval(1, IntervalBoundKind.Open, 10, IntervalBoundKind.Closed)</code>
            includes 10 and 2 but not 1.
            </summary>
            <remarks>
            Bounds like (1,1) are permitted but define empty sets.
            </remarks>
            <param name="lowerBound"></param>
            <param name="lowerBoundKind"></param>
            <param name="upperBound"></param>
            <param name="upperBoundKind"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Interval`1.LowerBound">
            <summary>
            Lower bound of the interval.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.Interval`1.UpperBound">
            <summary>
            Upper bound of the interval.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SubmodelInstance">
            <summary>
            Composite decision, decision defined on a composite domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.#ctor(Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.SubmodelInstance,System.String)">
            <summary>
            Construct a submodel decision (singleton) on the submodel domain with the given name
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.#ctor(Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.SubmodelInstance,System.String,Microsoft.SolverFoundation.Services.Set[])">
            <summary>
            Construct a submodel decision (table) on the submodel domain with the given name and index sets
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.GetSubmodelInstance(Microsoft.SolverFoundation.Services.SubmodelInstance)">
            <summary>
            Given the SubmodelInstance member defined in the domain, return the corresponding SubmodelInstance member of this SubmodelInstance
            </summary>
            <param name="key">The SubmodelInstance object in the domain of this SubmodelInstance</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.GetDecision(Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Given the Decision member defined in the domain, return the corresponding Decision member of this SubmodelInstance
            </summary>
            <param name="key">The Decision object in the domain of this SubmodelInstance</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.GetDecision(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>
            Given the RecourseDecision member defined in the domain, return the corresponding RecourseDecision member of this SubmodelInstance
            </summary>
            <param name="key">The RecourseDecision object in the domain of this SubmodelInstance</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.GetParameter(Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Given the Parameter member defined in the domain, return the corresponding Parameter member of this SubmodelInstance
            </summary>
            <param name="key">The Parameter object in the domain of this SubmodelInstance</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SubmodelInstance.GetParameter(Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>
            Given the RandomParameter member defined in the domain, return the corresponding RandomParameter member of this SubmodelInstance
            </summary>
            <param name="key">The RandomParameter object in the domain of this SubmodelInstance</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Parameters">
            <summary>
            Return all parameter members directly defined in this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.RandomParameters">
            <summary>
            Return all random parameter members directly defined in this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Decisions">
            <summary>
            Return all decision members directly defined in this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.RecourseDecisions">
            <summary>
            Return all recourse decision members directly defined in this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.SubmodelInstances">
            <summary>
            Return all submodel instance members directly defined in this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.AllParameters">
            <summary>
            Return all parameter members that are instantiated from this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.AllRandomParameters">
            <summary>
            Return all random parameter members that are instantiated from this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.AllDecisions">
            <summary>
            Return all decision members that are instantiated from this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.AllRecourseDecisions">
            <summary>
            Return all recourse decision members that are instantiated from this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.AllSubmodelInstances">
            <summary>
            Return all submodel instance members that are instantiated from this submodel instance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Name">
            <summary>
            Get the name of the submodel decision
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Item(Microsoft.SolverFoundation.Services.SubmodelInstance)">
            <summary>
            Given the SubmodelInstance member defined in the domain, return the corresponding SubmodelInstance member of this SubmodelInstance
            </summary>
            <param name="key">The SubmodelInstance object in the domain of this SubmodelInstance</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Item(Microsoft.SolverFoundation.Services.Decision)">
            <summary>
            Given the Decision member defined in the domain, return the corresponding Decision member of this SubmodelInstance
            </summary>
            <param name="key">The Decision object in the domain of this SubmodelInstance</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Item(Microsoft.SolverFoundation.Services.RecourseDecision)">
            <summary>
            Given the RecourseDecision member defined in the domain, return the corresponding RecourseDecision member of this SubmodelInstance
            </summary>
            <param name="key">The RecourseDecision object in the domain of this SubmodelInstance</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Item(Microsoft.SolverFoundation.Services.Parameter)">
            <summary>
            Given the Parameter member defined in the domain, return the corresponding Parameter member of this SubmodelInstance
            </summary>
            <param name="key">The Parameter object in the domain of this SubmodelInstance</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SubmodelInstance.Item(Microsoft.SolverFoundation.Services.RandomParameter)">
            <summary>
            Given the RandomParameter member defined in the domain, return the corresponding RandomParameter member of this SubmodelInstance
            </summary>
            <param name="key">The RandomParameter object in the domain of this SubmodelInstance</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModel">
            <summary> TermModel is a default implementation of ITermModel.
            TermModel can be inherited by a plug-in solver class.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32)">
            <summary>Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32)">
            <summary>Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32[])">
            <summary>Adds an operation row to the model.
            </summary>
            <remarks>
            This overload is supported for the following TermModelOperation values:
            And, Equal, Greater, GreaterEqual, Less, LessEqual, Max, Min, Or, Plus, Times, Unequal.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddVariable(System.Object,System.Int32@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="vid"></param>
            <param name="lower"></param>
            <param name="upper"></param>
            <param name="isInteger"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddVariable(System.Object,System.Int32@,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="vid"></param>
            <param name="possibleValues"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddConstant(Microsoft.SolverFoundation.Common.Rational,System.Int32@)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.IsOperation(System.Int32)">
            <summary>
            
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.IsConstant(System.Int32)">
            <summary>
            
            </summary>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.GetOperation(System.Int32)">
            <summary>Get the operation for the specified row.
            </summary>
            <param name="vid"></param>
            <returns>The TermModelOperation.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.GetOperandCount(System.Int32)">
            <summary>Get the operand count for the specified row.
            </summary>
            <param name="vid">A vid.</param>
            <returns>The operand count.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.GetOperands(System.Int32)">
            <summary>Get the operands for the specified row.
            </summary>
            <param name="vid">A vid.</param>
            <returns>An IEnumerable containing the operand vids.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.GetOperand(System.Int32,System.Int32)">
            <summary>
            </summary>
            <param name="vid"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.AddRow(System.Object,System.Int32@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="vid"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the bounds for a vid.</summary>
            <remarks>
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite values for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            and ArgumentException is thrown.  
            </remarks>
            <param name="vid">A vid.</param>
            <param name="lower">The lower bound.</param>
            <param name="upper">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the lower bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="lower">The lower bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the upper bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="upper">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Sets the default value for a vid.
            </summary>
            <remarks>
            The default value for a vid is Indeterminate. An IRowVariableModel can be used to represent not just a model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value represented as a Rational. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            Some solvers may ignore this initial state for rows and even for variables.
            </remarks>
            <param name="vid">A vid.</param>
            <param name="value">The default value for the variable.</param>    
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper">
            <summary>
            This class wraps an ITermModel and applies some simplifications as the model is built.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32)">
            <summary>
            Adds an operation row to the model. This row can be turned into a constraint by setting the bounds.
            Examples of 1-operand operations: identity, negation, not, sin, cos, tan, exp, log, abs
            Examples of 2-operand operations: plus, minus, times, quotient, pow, max, min, and, or, equality/inequalities
            Examples of 3-operand operations: if
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row that would have the same value as the new row.</param>
            <param name="vid1">Vid of the input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32)">
            <summary>
            Adds an operation row to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vid1">Vid of the first input argument.</param>
            <param name="vid2">Vid of the second input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an operation row to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vid1">Vid of the first input argument.</param>
            <param name="vid2">Vid of the second input argument.</param>
            <param name="vid3">Vid of the third input argument.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32[])">
            <summary>
            Adds an operation row to the model.
            </summary>
            <param name="op">The operation.</param>
            <param name="vidNew">The vid of the new row, or the vid of an existing row with the same value as the new row.</param>
            <param name="vids">The vids of the input arguments.</param>
            <returns>True if a new row was added. False if an existing row was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddVariable(System.Object,System.Int32@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean)">
            <summary>
            Adds a variable to the model, with bounds and integrality given at creation time.
            </summary>
            <param name="key">The optional key of the new variable, or null.</param>
            <param name="vid">The vid of the new variable, or of an existing variable with the same key.</param>
            <param name="lower">The lower bound.</param>
            <param name="upper">The upper bound.</param>
            <param name="isInteger">True if the new variable should be restricted to only integer values.</param>
            <returns>True if a new variable was added. False if an existing variable had the same key.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddVariable(System.Object,System.Int32@,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            Adds a variable to the model, with a fixed set of possible values.
            </summary>
            <param name="key">The optional key of the new variable, or null.</param>
            <param name="vid">The vid of the new variable, or of an existing variable with the same key.</param>
            <param name="possibleValues">An array of possible values of the new variable. The caller must not modify the array after passing it to this function.</param>
            <returns>True if a new variable was added. False if an existing variable had the same key.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddConstant(Microsoft.SolverFoundation.Common.Rational,System.Int32@)">
            <summary>
            Adds a constant to the model. Constants are considered rows.
            </summary>
            <param name="value">The value of the constant to create.</param>
            <param name="vid">The vid of the new constant, or the vid of an existing constant with the same value.</param>
            <returns>True if a new constant was added. False if an existing constant was reused.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IsOperation(System.Int32)">
            <summary>
            Tests if a vid is an operation (not a variable or constant).
            </summary>
            <param name="vid">A vid.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IsConstant(System.Int32)">
            <summary>
            Tests if a vid is a constant (not a variable or operation).
            </summary>
            <param name="vid">A vid.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetOperation(System.Int32)">
            <summary>
            Gets the operation associated with a vid.
            </summary>
            <param name="vid">The vid of an operation.</param>
            <returns>The operation.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetOperandCount(System.Int32)">
            <summary>
            Gets the number of operands associated with a vid.
            </summary>
            <param name="vid">The vid of an operation.</param>
            <returns>The operand count.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetOperands(System.Int32)">
            <summary>
            Gets the operands associated with a vid.
            </summary>
            <param name="vid">The vid of an operation.</param>
            <returns>All the vids of the operands.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetOperand(System.Int32,System.Int32)">
            <summary>
            Gets an operand associated with a vid.
            </summary>
            <param name="vid">The vid of an operation.</param>
            <param name="index">The operand index.</param>
            <returns>The vid of the operand</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown 
            </summary>
            <param name="key"></param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key
            </summary>
            <param name="key">the key value </param>
            <param name="vid">the variable index </param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown
            </summary>
            <param name="vid">the variable index</param>
            <returns>the variable key</returns>
            <remarks>key might be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddRow(System.Object,System.Int32@)">
            <summary> If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IsRow(System.Int32)">
            <summary>
            Validate if it is a row index and not a variable index.
            </summary>
            <param name="vid">row index</param>
            <returns>True if a row otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetIgnoreBounds(System.Int32,System.Boolean)">
            <summary>
            Adjusts whether the bounds of a vid should be respected or ignored during solving. 
            By default, bounds are respected.
            </summary>
            <param name="vid">a variable index</param>
            <param name="fIgnore">whether to ignore the bounds</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetIgnoreBounds(System.Int32)">
            <summary>
            Get the flag whether is bound is ignored.
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if bounds are ignored, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite values for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            now the ArgumentException is thrown for this case.  
            </summary>
            <param name="vid">the variable index </param>
            <param name="numLo">lower bound</param>
            <param name="numHi">upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            set or adjust the lower bound of the variable 
            </summary>
            <param name="vid">the variable index </param>
            <param name="numLo">lower bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            set or adjust the upper bound of the variable 
            </summary>
            <param name="vid">the variable index</param>
            <param name="numHi">the upper bound</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Return the bounds for the variable 
            </summary>
            <param name="vid">the variable index</param>
            <param name="numLo">the lower bound returned</param>
            <param name="numHi">the upper bound returned</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            </summary>
            <param name="key"> Variable key </param>
            <param name="vid">variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used to fetch solver result 
            </summary>
            <param name="vid">a variable index</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            The default value for a vid is Indeterminate. An IRowVariableModel can be used to represent not just a model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value represented as a Rational. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            </summary>
            <param name="vid">a variable index</param>
            <param name="num">the value for the variable</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable 
            </summary>
            <param name="vid">a variable index </param>
            <param name="fInteger">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Mark a row as a goal row 
            </summary>
            <param name="vid">a row id</param>
            <param name="pri">the priority of a goal</param>
            <param name="fMinimize">whether to minimize the goal row</param>
            <returns>the goal entry</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row 
            </summary>
            <param name="vid">a row id</param>
            <returns>true if this a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.IGoal@)">
            <summary>
            Check if a row id is a goal. If true, return the goal entry 
            </summary>
            <param name="vid">a row id</param>
            <param name="goal">return the goal entry</param>
            <returns>true if a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row
            </summary>
            <param name="vid">a row id</param>
            <returns>true if the goal is removed. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.ClearGoals">
            <summary>
            Clear all the goals 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal
            </summary>
            <param name="vid">a variable index</param>
            <returns>A goal entry. Null if not a goal row</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.Indices">
            <summary> return the variable index collection, inclusive of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.Keys">
            <summary> Return the variable and row key collection.
            Indices are guaranteed to >= 0 and &lt; KeyCount.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.KeyCount">
            <summary> the number of keys, inclusive of rows and variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.RowIndices">
            <summary> Return the row index collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.RowKeys">
            <summary> Return the row key collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.RowCount">
            <summary> The number of rows in the model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.VariableIndices">
            <summary>
            return the variable index collection
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.VariableKeys">
            <summary>
            return the variable key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.VariableCount">
            <summary>
            return the variable count 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.IntegerIndexCount">
            <summary> return the number of integer variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.Goals">
            <summary>
            Return the goal collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.SimplifiedTermModelWrapper.GoalCount">
            <summary>
            The number of goals in this model
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModelForwardDifferentiator">
            <summary>Uses Forward Differentiation to symbolically differentiate an ITermModel.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelForwardDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel)">
            <summary>This method starts the differentiation work. SFS calls this method to differentiate the model. 
            The other Differentiate methods just load rows and variables of differentiation. 
            </summary>
            <param name="model"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.TermModelReverseDifferentiator">
            <summary>Uses Reverse Differentiation to symbolically differentiate an ITermModel.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.TermModelReverseDifferentiator.Differentiate(Microsoft.SolverFoundation.Services.ITermModel)">
            <summary>This method starts the differentiation work. SFS calls this method to differentiate the model. 
            The other Differentiate methods just load rows and variables of differentiation. 
            </summary>
            <param name="model"></param>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Numeric">
            <summary>
            A numeric value.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Enumerated">
            <summary>
            An enumerated value. Uses a numeric value as an index into a set of strings.
            Enumerated values can't be used in mathematical operations (except comparisons).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Any">
            <summary>
            Either an arbitrary number or an arbitrary string.
            "Any" values can only be used as an index.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Table">
            <summary>
            A multidimensional parameter or decision.
            Table values can only be used by indexing into them.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Submodel">
            <summary>
            An instance of a submodel
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermValueClass.Distribution">
            <summary>
            A random distribution
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.None">
            <summary>
            No flags
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Constant">
            <summary>
            Constant after all parameters and iteration terms are fixed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Linear">
            <summary>
            Linear in decisions (e.g. "x + 2")
            A term with this flag is valid as a goal in linear or quadratic models, and (if Boolean) as a constraint in linear or quadratic models.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Quadratic">
            <summary>
            Quadratic in decisions (e.g. "x * y + 2")
            A term with this flag is valid as a goal in quadratic models.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.LinearInequality">
            <summary>
            Linear inequality (e.g. "x + 2 == 5")
            A term with this flag is valid as the parameter of an SOS2 constraint.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.LinearConstraint">
            <summary>
            AND of linear inequalities and/or Boolean constants (e.g. "(x + 2 == 5) &amp; (x + y &lt;= 10)")
            A term with this flag is valid as a constraint in linear or quadratic models.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Integer">
            <summary>
            Uses only integer operations and constants, including all descendants
            A term with this flag is valid as a goal or constraint in CP models.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Multivalue">
            <summary>
            Foreach
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Sos1">
            <summary>
            Sos1
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Sos2">
            <summary>
            Sos2
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.Differentiable">
            <summary>
            Differentiable function
            A term with this flag is valid as a goal in differentiable nonlinear models, and (if Boolean) as a constraint in the same.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.TermStructure.DifferentiableConstraint">
            <summary>
            AND of differentiable functions and/or Boolean constants
            A term with this flag is valid as a constraint in differentiable nonlinear models.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ConstantTerm">
            <summary>
            A constant numeric term.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ConstantTerm._value">
            <summary>
            The numeric value of this term, as a Rational.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ConstantTerm.#ctor(Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Construct a constant numeric term.
            </summary>
            <param name="value">The constant value.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.StringConstantTerm">
            <summary>
            A constant string term.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.StringConstantTerm.#ctor(System.String)">
            <summary>
            Construct a constant string term.
            </summary>
            <param name="value">The constant value.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.BoolConstantTerm">
            <summary>
            A constant Boolean term. This is also a numeric term, with the value 1.0 if true or 0.0 if false.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.BoolConstantTerm.#ctor(System.Boolean)">
            <summary>
            Construct a constant boolean term.
            </summary>
            <param name="value">The constant value.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.EnumeratedConstantTerm">
            <summary>
            A constant enumerated term. This is basically a numeric term, where the number is associated with a string.
            Each constant enumerated term is associated with a specific enumerated domain, and is only compatible with
            other enumerated terms from the same domain.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.EnumeratedConstantTerm._symbolDomain">
            <summary>
            The enumerated domain this constant belongs to
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.EnumeratedConstantTerm.#ctor(Microsoft.SolverFoundation.Services.Domain,System.Int32)">
            <summary>
            Construct a constant enumerated term
            </summary>
            <param name="symbolDomain">An enumerated domain. This must have a ValueClass of Enumerated.</param>
            <param name="index">The constant value, as the index of a string within the enumerated domain.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IdentityTerm">
            <summary>
            A term that does nothing but wrap another term. It is useful to keep nested comparisons operations from being flattened.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IdentityTerm._input">
            <summary>
            The wrapped term.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IdentityTerm.#ctor(Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Construct an identity term
            </summary>
            <param name="input">The term to wrap</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.OperatorTerm">
            <summary>
            A term representing a mathematical operation, such as addition or equality.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.OperatorTerm._valueClass">
            <summary>
            The type of value (Boolean, numeric, etc.), which is determined by the operation and the inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OperatorTerm.#ctor(Microsoft.SolverFoundation.Services.Term[],Microsoft.SolverFoundation.Services.TermValueClass)">
            <summary>
            Construct a term representing a mathematical operation
            </summary>
            <param name="inputs">The inputs of the operation. An input can be a ForEachTerm representing multiple values.</param>
            <param name="valueClass">The value class of the result, which is determined by the operation and inputs.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OperatorTerm.GetHeadSymbol(Microsoft.SolverFoundation.Rewrite.RewriteSystem)">
            <summary>
            Get the NL Symbol representing the mathematical operation this Term performs
            </summary>
            <param name="rs">The RewriteSystem the symbol should belong to</param>
            <returns>A Symbol</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OperatorTerm.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.OperatorTerm.ToString">
            <summary>Returns a string that represents the current Decision.
            </summary>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.OperatorTerm.Operation">
            <summary>
            The mathematical operation this term performs
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.OperatorTerm.Inputs">
            <summary>
            The inputs of the operation. An input might be a ForEachTerm which represents multiple values.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IndexTerm">
            <summary>
            A Term representing indexing a decision or parameter table.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IndexTerm._inputs">
            <summary>
            The indexes being used
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IndexTerm._table">
            <summary>
            The term representing the decision or parameter being indexed into.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IndexTerm._valueClass">
            <summary>
            The type of the single element (Boolean, numeric, etc.)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IndexTerm.#ctor(Microsoft.SolverFoundation.Services.IIndexable,Microsoft.SolverFoundation.Services.Model,Microsoft.SolverFoundation.Services.Term[],Microsoft.SolverFoundation.Services.TermValueClass)">
            <summary>
            Construct a term representing indexing a table to get a specific element.
            </summary>
            <param name="table">The decision or parameter being indexed. Must have a ValueClass of Table.</param>
            <param name="owningModel">The model that this IndexTerm should be added to.</param>
            <param name="inputs">The indexes. Must match the index sets of the table.</param>
            <param name="valueClass">The ValueClass of the resulting element.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IndexTerm.ToString">
            <summary>Returns a string that represents the current Decision.
            </summary>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IndexTerm.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.IterationTerm">
            <summary>
            A dummy term used as an iteration variable.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IterationTerm._name">
            <summary>
            The name of this term, for debugging purposes. Not necessarily unique.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.IterationTerm._valueClass">
            <summary>
            The type of this term (Boolean, numeric, etc.)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.IterationTerm.#ctor(System.String,Microsoft.SolverFoundation.Services.TermValueClass,Microsoft.SolverFoundation.Services.Domain)">
            <summary>
            Constructs a new dummy term for use as an iteration variable.
            </summary>
            <param name="name">A name for the term. Doesn't need to be unique.</param>
            <param name="valueClass">The type of the term.</param>
            <param name="domain">The domain of the term.</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ForEachTerm">
            <summary>
            A term representing iterating over a set to construct a group of values. Unlike most terms, a ForEach
            represents multiple values.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ForEachTerm._iterator">
            <summary>
            A dummy term representing the iteration variable.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ForEachTerm._set">
            <summary>
            The set of values to iterate over. The actual values don't need to be filled in until data is bound to the model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ForEachTerm._valueExpression">
            <summary>
            The resulting value, using _iterator as a placeholder which will be replaced with each element of _set after data is bound.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ForEachTerm.#ctor(Microsoft.SolverFoundation.Services.IterationTerm,Microsoft.SolverFoundation.Services.Set,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Construct a term representing multiple values generated by substituting every element of a set into an expression.
            </summary>
            <param name="iterator">A dummy term used as a placeholder for each element of the set.</param>
            <param name="set">The set of values to iterate over.</param>
            <param name="valueExpression">The expression that will be produced for each element of the set, using the iterator as placeholder.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ForEachTerm.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
            <remarks>
            The "n" format causes the decision names to be printed rather than values.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ForEachWhereTerm">
            <summary>
            A term representing iterating over a set to construct a group of values. Unlike most terms, a ForEach
            represents multiple values.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.ForEachWhereTerm._condExpression">
            <summary>
            The condition, using _iterator as a placeholder which will be replaced with each element of _set after data is bound.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ForEachWhereTerm.#ctor(Microsoft.SolverFoundation.Services.IterationTerm,Microsoft.SolverFoundation.Services.Set,Microsoft.SolverFoundation.Services.Term,Microsoft.SolverFoundation.Services.Term)">
            <summary>
            Construct a term representing multiple values generated by substituting a subset of elements of a set into an expression.
            </summary>
            <param name="iterator">A dummy term used as a placeholder for each element of the set.</param>
            <param name="set">The set of values to iterate over.</param>
            <param name="valueExpression">The expression that will be produced for each element of the set, using the iterator as placeholder.</param>
            <param name="condExpression">The condition that determines which elements will be produced, using the iterator as placeholder.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ForEachWhereTerm.ToString(System.String,System.IFormatProvider)">
            <summary>Formats the value of the current instance using the specified format.
            </summary>
            <param name="format">The format to use (or null).</param>
            <param name="formatProvider">The provider to use to format the value (or null).</param>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ForEachWhereTerm.ToString">
            <summary>Returns a string that represents the current instance.
            </summary>
            <returns>The value of the current instance in the specified format.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.NamedConstantTerm">
            <summary>
            A NamedConstantTerm represents a named constant ("Parameters[..., P = constant]" in OML), or
            a simple function of one or more inputs.
            
            It can be indexed just like a Parameter.
            
            It is possible that the value of a NamedConstantTerm could depend on the value of a Parameter
            or another NamedConstantTerm. Ensuring that there are no loops is the job of the OML importer.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.RowTerm">
            <summary>
            This represents a sum of products by as a row of a sparse matrix.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowTerm._model">
            <summary>
            A linear model whose coefficient matrix is used to find the coefficients of the sum
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowTerm._variables">
            <summary>
            A mapping from variable vids to Terms representing the variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Services.RowTerm._vid">
            <summary>
            The vid of the row this term corresponds to
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.RowTerm.TryEvaluateConstantValue(Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Services.Term.EvaluationContext)">
            <summary>
            This is a stub method which always returns false. The variables will generally be decisions, so a RowTerm almost always can't be evaluated.
            </summary>
            <param name="value"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.SumTermBuilder">
            <summary>A SumTermBuilder is used to build Sum terms efficiently.
            </summary>
            <remarks>
            This class represents a list of operand terms that will be combined into a Sum term.
            The resulting Sum term can be used in goals or constraints. This class is useful when
            the number of terms in the sum is unknown at compilation time (otherwise the operands
            may be passed as an array to Model.Sum). Individual terms are added to SumTermBuilder
            using the Add method. The ToTerm method returns a Sum term with the previously added
            terms as operands.  The Clear method is convenient when the same SumTermBuilder is
            used repeatedly to create Sum terms.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SumTermBuilder.#ctor(System.Int32)">
            <summary>Creates a new instance with the specified initial capacity.
            </summary>
            <param name="capacity">The initial capacity of the SumTermBuilder.</param>
            <remarks>If the number of terms exceeds the capacity the SumTermBuilder will be 
            resized appropriately.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SumTermBuilder.Clear">
            <summary>Clears the SumTermBuilder.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SumTermBuilder.Add(Microsoft.SolverFoundation.Services.Term)">
            <summary>Add a new Term.
            </summary>
            <param name="term">A term to add to the SumTermBuilder.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.SumTermBuilder.ToTerm">
            <summary>Returns a Term object that represents the Sum of the previously added operand terms.
            </summary>
            <returns>A Sum term.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ValueSet">
            <summary>
            A set of values, which can be any type (strings, doubles, etc).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueSet.Create(Microsoft.SolverFoundation.Services.Domain)">
            <summary>
            Creates a new ValueSet.
            </summary>
            <param name="domain">The domain of values the ValueSet can accept.</param>
            <returns>A new ValueSet.</returns>
            <exception cref="T:System.NotSupportedException">Thrown if the domain is an enumerated domain.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueSet.Add(System.Object)">
            <summary>Try to add an item to the ValueSet. Returns true if the set contains the item after the call is completed.
            </summary>
            <param name="value">The value to add.</param>
            <returns>Returns true if the set contains the item. If the ValueSet is locked then new items cannot be added.
            This may still result in Add returning true if the item was added before the ValueSet was locked.
            </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Services.ValueSet.IsLocked">
            <summary>Gets whether new values can be added to the ValueSet.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Services.ValueTable`1">
            <summary>
            A table of values indexed by some number of keys, which can be any type (strings, doubles, etc).
            This implementation supports a maximum of five keys.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueTable`1.Create(Microsoft.SolverFoundation.Services.Domain,Microsoft.SolverFoundation.Services.ValueSet[])">
            <summary>
            Factory method to construct a value table with the specified types.
            </summary>
            
            <param name="domain"></param>
            <param name="indexSets"></param>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Thrown if there are too many index sets.</exception>
            <exception cref="T:System.NotSupportedException">Thrown if the domain is not numeric.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueTable`1.Add(`0,System.Object[])">
            <summary>
            Add a value to the value table.
            </summary>
            <param name="value"></param>
            <param name="indexes"></param>
            <exception cref="T:System.ArgumentException">Thrown if there is already a value for the specified indexes.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidModelDataException">Thrown if the data or the indexes are out-of-range.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueTable`1.TryGetValue(`0@,System.Object[])">
            <summary>
            Get a value from the value table. Retsurns false if the key is not found.
            </summary>
            <param name="value"></param>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Services.ValueTable0`1.AddImpl(`0,System.Object[])">
            <summary>Adds a value.
            </summary>
            <param name="value">The value.</param>
            <param name="keys">The keys.</param>
            <exception cref="T:System.ArgumentException">Thrown if there is already a value.</exception>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspVariable">
            <summary> A Variable with a Finite CspSolverDomain
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSolverTerm">
            <summary> A Term is the ConstraintSystem unit of modelling, representing a CspVariable or a Function.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspTerm">
            <summary> A Term is the InnerSolver unit of modelling, representing a CspVariable or a Function.
                      A Term is not changed by solving (if you look at how solutions are returned, the ValueSets
                        are paired but distinct) and multiple solutions will return the same instances for the Variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.Fields(System.Object)">
            <summary>
            Get the field labeled with the given key.
            </summary>
            <param name="key"></param>
            <returns>An array of terms that correspond to all elements in the field. If the field is a singleton, then the returned array has only one element.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.Field(System.Object,System.Int32)">
            <summary>
            Get the ith element of the field labeld with the given key.
            </summary>
            <param name="key"></param>
            <param name="index">The index</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.Field(System.Object)">
            <summary>
            Get the first element (or the only element if the field is a singleton) of the fielded labeled by the given key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Addition(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents term1 + term2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Addition(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Term that represents term + num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Addition(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num + term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Addition(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Term that represents term + num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Addition(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num + term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Subtraction(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents term1 - term2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Subtraction(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Term that represents term - num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Subtraction(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num - term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Subtraction(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Term that represents term - num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Subtraction(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num - term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Multiply(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents term1 * term2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Multiply(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Term that represents term * num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Multiply(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num * term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Multiply(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Term that represents term * num
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_Multiply(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents num * term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_UnaryNegation(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Term that represents -term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LogicalNot(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Not(term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_BitwiseOr(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Or(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_BitwiseAnd(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents And(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents LessEqual(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Boolean Term that represents LessEqual(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThanOrEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents LessEqual(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Boolean Term that represents LessEqual(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThanOrEqual(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents LessEqual(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThan(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Less(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThan(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Boolean Term that represents Less(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThan(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Less(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThan(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Boolean Term that represents Less(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_LessThan(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Less(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents GreaterEqual(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Boolean Term that represents GreaterEqual(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThanOrEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents GreaterEqual(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Boolean Term that represents GreaterEqual(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThanOrEqual(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents GreaterEqual(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThan(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Greater(term1, term2)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThan(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
            Return a Boolean Term that represents Greater(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThan(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Greater(num, term)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThan(Microsoft.SolverFoundation.Solvers.CspTerm,System.Double)">
            <summary>
            Return a Boolean Term that represents Greater(term, num)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspTerm.op_GreaterThan(System.Double,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return a Boolean Term that represents Greater(num, term)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.Model">
            <summary> The ConstraintSystem that this Term belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.Key">
            <summary>  All Variable Terms are created with a key object that serves as their identifier.
                        Variable keys will be added to a Dictionary and must be non-null and unique.
                       A Function Term by default has no key.  You can assign a key if you wish.  The Key is then
                        added to the Dictionary and will appear in the Solution.
                      Attempting to change an existing key will cause an InvalidOperationException.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.Kind">
            <summary>
            Return the value kind of this Term
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.CurrentValues">
            <summary>
            Enumerates current possible values in the domain of this Term. Returned values need to be cast into the
            correct type depending on the data type of this Term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.IsBoolean">
            <summary>  Is this Term tied to a Boolean Domain?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspTerm.Inputs">
            <summary> The array of Terms which are inputs to this Term.  This will be null if there are no inputs,
                      which includes all Variables.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IVisitable">
            <summary>
            Part of the Visitor pattern for visiting all components of a ConstraintSystem.
            These are embedded in all of the lower level parts of the model where we wish to dispatch the Visitation. 
            The implementations are trivial in most cases (call Visit on the visitor with 'this' as an argument).  It will be different wherever there
            are deep substructures  (see ConstraintSystem.Accept() for a more complex version).  Calling accept on a Term will use polymorphism to 
            get to the deepest class hierarchy class where the pattern is implemented.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverTerm.TermKinds,System.Int32)">
            <summary> A Term is the ConstraintSystem unit of modelling, representing a CspVariable or a Function.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.IsWatched(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Is the specified Variable currently watched by this xConstraint?  Some Constraints
                      (for example, CNF) have dynamically changing watch lists.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Forward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Forward">
            <summary> Enumerate all allowed choices from least to greatest.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Backward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Backward">
            <summary> Enumerate all allowed choices from greatest to least.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Contains(System.Int32)">
            <summary> Check if the given value is an element of the current domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.TestIntersect(System.Int32[])">
            <summary> Check if any of the given choices is an element of the current domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.TestIntersect(System.Int32,System.Int32)">
            <summary> Check if any of the given choices is an element of the current domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SameAs(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Check if this Expression and the other Expression have identical value sets.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Restrain(Microsoft.SolverFoundation.Solvers.CspSolverDomain)">
            <summary> Change to a new, tighter domain.  Return the new cardinality.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Force(System.Boolean,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Set the boolean to be true or false.  Return true if the CspSolverDomain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverTerm@,System.Int32[])">
            <summary> Intersect with the specified otherSet.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Intersect with the specified interval.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Intersect with the specified domain.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverTerm@,System.Int32[])">
            <summary> Exclude the specified otherSet.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Exclude(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Exclude the specified interval.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Exclude the specified domain.  Return true if the domain changed.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Reset">
            <summary> Override this to clear any internal temporary propagation state.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Backtrack(System.Int32)">
            <summary> Revert to the state at the time of some earlier decision
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Propagate(Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> After a xDomain or a Decision (which is a singular xDomain)
                        is assigned to a Variable, the consequences may be propagated.
            </summary>
            <param name="conflict"> Conflict Term if contradiction occurs. </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SubArray(System.Int32[],System.Int32,System.Int32)">
            <summary> Utility function to create a new integer array subsetting an existing one
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SubArray(System.Int32[],System.Int32)">
            <summary> Utility function to create a new integer array subsetting an existing one
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.IndexOf(System.Int32,System.Int32[])">
            <summary> Find an integer value in a sorted otherSet where the item must exist in the otherSet
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.GetValue(System.Int32)">
            <summary>
            Return the actural value of this CspSolverTerm that is mapped to the input. 
            Based on the value type, the returned value could be an integer, a double, or a string.
            </summary>
            <param name="intval">The internal integer value</param>
            <returns>The external value that is mapped to the input integer value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.GetInteger(System.Object)">
            <summary>
            Return the internal integer representation of the given value, based on its value type.
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspSolverTerm.MaxSafePositiveValue">
            <summary> Maximum Value manipulated by local search 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspSolverTerm.MinSafeNegativeValue">
            <summary> Minimum Value manipulated by local search
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.IsSafe(System.Int32)">
            <summary> True if the value is within a safe range where it can
                      be added/subtracted to another safe value without overflow
            </summary>
            <remarks> During the computations made in local search some values may
                      occasionally out of this range. This will systematically be
                      detected and cause a very strong increase in the penalty
                      function, so solutions for which this happens will be ignored
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Naive recomputation: Recompute the value of the term 
                      from the value of all its inputs
            </summary>
            <remarks> Naive, non-incremental. Used, in particular, for initialization
            </remarks>
            <param name="ls">The local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            <remarks> Naive, non-incremental. Used, in particular, for initialization
            </remarks>
            <param name="ls">The local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            <remarks> Redefined only if something incremental can be done -
                      otherwise the default behaviour is to naively recompute
            </remarks>
            
            <param name="modifiedArg">A subterm that has been modified</param>
            <param name="oldValue">The value the subterm had last time we 
                      recomputed this Term, in internal format
            </param>
            <param name="newValue">The currrent value of the modified subterm,
                      in internal format
            </param>
            <param name="ls">The local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.PropagateGradientChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Incremental recomputation of the gradients: update the
                      gradients when one of the arguments is changed
            </summary>
            <remarks> Redefined only if something incremental can be done -
                      otherwise the default behaviour is RecomputeGradients
            </remarks>
            
            <param name="modifiedArg">A subterm that has been modified</param>
            <param name="ls">The local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.DispatchValueChange(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Update the value of all dependents of the Term
            </summary>
            <param name="oldValue">the value of the Term before its last modification
            </param>
            <param name="newValue">the current value of the Term,
                      in internal format
            </param>
            <param name="ls">
            The local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.DispatchGradientChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> 
            Update the gradients of all dependents of the Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.AssertValueStable(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary>
            Asserts that the value of this term has been freshly re-computed:
            if we re-run a forced Recomputation the value would be unchanged
            </summary>
            <remarks>
            Precondition of many gradient recomputations: they
            assume that the evaluation of the current value of the
            term has been called
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            <param name="ls">The local search algorithm in which we are working </param>
            <param name="target">A value we would like to obtain for this Term,
                      in external format
            </param>=
            <returns> A sub-term paired with a hint, or value that should be targetted
                      for this subterm. The hint is in external format and should 
                      belong to the domain of the term.
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SelectFlipInternal(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a flip that is likely to bring this term closer to the 
                      target value
            </summary>
            <param name="ls">The local search algorithm in which we are working </param>
            <param name="target">A value we would like to obtain for this Term,
                      in external representation
            </param>
            <returns> A variable paired with a hint, or value worth considering for 
                      this variable. The hint is in internal format and should 
                      belong to the domain of the variable.
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.SelectFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a flip that is likely to bring this term closer to the 
                      target value
            </summary>
            <param name="ls">The local search algorithm in which we are working </param>
            <param name="target">A value we would like to obtain for this Term,
                      in external representation
            </param>
            <returns> A variable paired with a hint, or value worth considering for 
                      this variable. The hint is in external format and should 
                      belong to the domain of the variable.
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverTerm.CreateFlipSuggestion(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Random)">
            <summary> Given a Term, takes a non-checked hint for the term and 
                      returns a correct suggestion, where the hint is checked
                      and corrected if needed
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Depth">
            <summary> Depth of the term: 0 for terms with no inputs; 
                      otherwise 1 + max(depth of the inputs)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.IsConstraint">
            <summary> Flag set to true iff the term is a Boolean term
                      that is imposed as a constraint
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Participates">
            <summary> Does this Term have any influence on the model?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.OutputScale">
            <summary>
            Return the scale factor of the output.
            </summary>
            <returns>The scale factor</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Symbols">
            <summary>
            Return the symbols if this CspSolverTerm is a string variable. Otherwise, return null.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Width">
            <summary> The count of inputs on this xConstraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Count">
            <summary> The count of possible choices of this Term.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.First">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.Last">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.ChangeCount">
            <summary> The ChangeCount records the time of the most recent propagation through
                      this Term.  The ChangeCount of inputs and dependents are compared to see
                      if the dependent needs to be re-evaluated or is up-to-date.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverTerm.IsBoolean">
            <summary>  Is this Term tied to a Boolean Domain?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverTerm.TermKinds,System.Object)">
            <summary> A Variable with a Finite CspSolverDomain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSymbolDomain,System.Object,System.Int32)">
            <summary> A variable that represents a symbol constant
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.ToString">
            <summary> String representation of this variable
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspVariable.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspVariable.Kind">
            <summary>
            Get the value kind of this variable
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspVariable.Width">
            <summary> There are no inputs to a Variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspVariable.Participates">
            <summary> Does this Variable have any influence on the model?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspVariable.Args">
            <summary> There are no inputs to a Variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspBooleanVariable.ToString">
            <summary> Represent.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspBooleanVariable.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanFunction">
            <summary> Abstract base class for all Boolean-result constraints
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspFunction">
            <summary> Abstract base class for all Integer-result constraints
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> This is for protected internal use only
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ComputeDepth(Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary>
              the depth of a function is 1 + max of the depth of the inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> Abstract base class for all Integer-result constraints
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToOutput(System.Int32,System.Int32)">
            <summary>
            Scale a value at the input scale to the output scale.
            </summary>
            <param name="valueAtInputScale"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToOutput(Microsoft.SolverFoundation.Solvers.CspSolverDomain,System.Int32)">
            <summary>
            Scale a Domain at the input scale to the output scale.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToOutput(System.Int32[],System.Int32)">
            <summary>
            Scale an array of values at the input scale to the output scale.
            </summary>
            <param name="valuesAtInputScale"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToInput(System.Int32,System.Int32)">
            <summary>
            Scale a value at the output scale to the input scale.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToInput(Microsoft.SolverFoundation.Solvers.CspSolverDomain,System.Int32)">
            <summary>
            Scale a value at the output scale to the input scale.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ScaleToInput(System.Int32[],System.Int32)">
            <summary>
            Scale an array of values at the output scale to the input scale.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.ToString">
            <summary> String representation of this function
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.RandomlyEnumerateValuesInRange(System.Int32,System.Int32,System.Random)">
            <summary> Enumerates all values of a range first..last-1
                      in a random order
            </summary>
            <remarks> The order is weakly random: we start from a random point
                      and enumerate circularly
            </remarks>
            <param name="first">first value of the range, inclusive</param>
            <param name="last">last value of the range, exclusive</param>
            <param name="prng">a Pseudo-Random Number Generator</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.RandomlyEnumerateSubterms(System.Random)">
            <summary> Enumerates all inputs but in a random order
            </summary>
            <param name="prng">A Pseudo-Random Number Generator</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.RandomlyEnumerateValues(Microsoft.SolverFoundation.Solvers.CspSolverDomain,System.Random)">
            <summary> Enumerates the values of a Domain in a random order
            </summary>
            <param name="dom">a Domain</param>
            <param name="prng">A Pseudo-Random Number Generator</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.PickInput(System.Random)">
            <summary> Picks an input at random; preferably one whose domain
                      is non-constant
            </summary>
            <param name="prng">A Pseudo-Random Number Generator</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspFunction.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            <remarks> This is a default overload for any function term; 
                      It simply picks one input at random.
                      Redefine for every class where something more clever can be done
            </remarks>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspFunction.Kind">
            <summary>
            Get the value kind of this function
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspFunction.Width">
            <summary> The count of inputs on this CspFunction.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> Abstract base class for all Boolean-result constraints
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.ToString">
            <summary> Represent this class
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanFunction.Violated">
            <summary> A possible violation for a false term. By no means normative
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanFunction.Satisfied">
            <summary> A possible violation for a True term. By no means normative
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.ScaleDown(System.Int32)">
            <summary> Scales a possibly large number down to something within the
                      range [-32, +32]. Scaling-down is sign-preserving 
                      and reflects somehow how far we are from 0. In particular 
                      the result is guaranteed to be 0 only for the input 0
            </summary>
            <remarks> Used for two reasons: (1) we don't want some violations to 
                      have an overwhelmingly large value: if an equality between
                      two large numbers has a violation equal to the
                      distance between them this will tend to make the violation
                      of an Unequal term negligible. (2) by systematically scaling
                      down any potentially large number we avoid any overflow
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.ScaleDown(System.Int64)">
            <summary> Scales a possibly large number down to something within the
                      range [-64, +64]. Scaling-down is sign-preserving 
                      and reflects somehow how far we are from 0. In particular 
                      the result is guaranteed to be 0 only for the input 0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.NonNegative(System.Int32)">
            <summary> Given a non-zero violation as represented internally, returns 
                      a non-negative version (if the expression is true we return a 
                      violation of 0 instead of the negative truth indicator)
            </summary>
            <param name="violation">A non-zero violation indicator 
                      (the higher the more violated)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.NonZero(System.Int32)">
            <summary> Given a non-negative violation, returns a non-zero version
                      as suitable for an internal representation (if the
                      violation is 0 then we return -1)
            </summary>
            <param name="violation">A non-zero violation indicator 
                      (the higher the more violated)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.IsSatisfied(System.Int32)">
            <summary> Given a non-zero violation as represented internally, 
                      checks if it actually represents falsity (negative)
                      of truth (positive)
            </summary>
            <param name="violation">A non-zero violation indicator 
                      (the higher the more violated)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.And(System.Int32,System.Int32)">
            <summary> And of two (non-zero) violations
            </summary>
            <param name="l">A non-zero violation indicator 
                      (the higher the more violated)</param>
            <param name="r">A non-zero violation indicator 
                      (the higher the more violated)</param>
            <remarks>
              if both sides are positive (violated) then the conjunction is 
              positive and equals the work to do to truthify both, i.e. sum;
              if both sides are negative (satisfied) then the conjunction is 
              negative and as satisfied as the least satisfied, i.e. max;
              if exactly 1 side is positive (violated) then the conjunction is
              as violated as this side which being the only positive is the max
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.Or(System.Int32,System.Int32)">
            <summary> Or of two (non-zero) violations
            </summary>
            <param name="l">A non-zero violation indicator 
                      (the higher the more violated)</param>
            <param name="r">A non-zero violation indicator 
                      (the higher the more violated)</param>
            <remarks>
              if both sides are negative (satisfied) then the disjunction is 
              negative and equals the work to do to falsify both, i.e. sum;
              if both sides are positive (violated) then the disjunction is 
              positive and as violated as the least violated, i.e. min;
              if exactly 1 side is negative (satisfied) then the disjunction is
              as satisfied as this side which being the only negative is the min
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.Not(System.Int32)">
            <summary> Negation of a violation  </summary>
            <param name="violation">A non-zero violation indicator 
                      (the higher the more violated)</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.LessEqual(System.Int32,System.Int32)">
            <summary> Returns a score of how much l and r violate the LessEqual order
            </summary>
            <remarks>
              LessEqual(0, 0) gives -1, not violated and one-unit move
              would suffice to violate;
              LessEqual(0, 10) gives something a bit more negative
              LessEqual(1, 0) gives +1 : violated and a one-unit move
              would suffice to satisfy;
              LessEqual(10, 0) gives something a bit more positive
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.LessStrict(System.Int32,System.Int32)">
            <summary> Returns a score of how much l and r violate the LessStrict order
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.Equal(System.Int32,System.Int32)">
            <summary> Returns a score of how much l and r violate the equality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanFunction.Unequal(System.Int32,System.Int32)">
            <summary> Returns a score of how much l and r violate the disequality
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Comparison">
            <summary> A boolean which is equal to the sequential ordering of a otherSet of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to the sequential ordering of a otherSet of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.SelectSubtermToFlipTowardsEquality(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Suggests a subterm and a suggestion of value for it
                      that are likely to make the inputs as equal as possible
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.SelectSubtermToFlipTowardsDifference(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Suggests a subterm and a suggestion of value for it
                      that are likely to make the inputs as different as possible
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.SelectFreeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Random,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Picks a value for the term that is preferably not
                      currently used by an input
            </summary>
            <remarks> Makes a bounded number of attempts as the desired value
                      may not always exist and this is used only for heuristic
                      purposes anyway
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.SelectValueOfOtherInput(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Random,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Picks a value used by a subterm but different from the
                      indicated one </summary>
            <param name="ls">The Local Search we work in</param>
            <param name="prng">a Pseudo random Number Generator</param>
            <param name="skipped">the subterm to avoid</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Comparison.IsUsedByAsubterm(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> True if a subterm has the indicated value
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Equal">
            <summary> A boolean which is equal to the mutual inequality of all the input expressions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Equal.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to the mutual inequality of all the input expressions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Equal.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Equal.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Equal.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Equal.Name">
            <summary> Represent this class
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Unequal">
            <summary> A boolean which is equal to the mutual inequality of all the input expressions.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Unequal.SizeLimit">
            <summary> Size at which we start using the incremental version
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to the mutual inequality of all the input expressions.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.ResolveSingles(System.Boolean@,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Scan the unresolveds for inputs which are now single-valued
                      and move them to the end of the inputs.  Also measure the
                      overall cardinality.
            </summary>
            <returns>True iff more work needs to be done after this method returns.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.RemoveClosedSubsets(System.Boolean,System.Boolean,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> In cases where cardinality exactly matches the inputs,
                        look for value sets which exactly cover a matching count
                        of inputs, and exclude them from any other input
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Unequal.OrdinalAmongUnequalTerms">
            <summary> A unique ID from 0 to [number of unequal terms]-1,
                      used as index for data specific to Unequal terms
            </summary>
            <remarks> The extra data are used to count (in a dictionary) the
                      number of inputs that take any given value
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Naive recomputation: Recompute the value of the term 
                      from the value of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.RecomputationWithoutCounters(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Algorithm that is preferable for small sizes </summary>
            <remarks> Will give better distance information.
                      Also does not allocate the dictionary, which would be
                      a waste for small disequalities.
                      Quadratic complexity so not appropriate for large sizes.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.GetLocalSearchData(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Gets the dictionary living in the context of the
                      given local search. Will be created the first time
                      this method is called and looked-up afterwards.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Unequal.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Unequal.Name">
            <summary> Represent this class
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Unequal.LocalSearchData">
            <summary> The type of data that has to be allocated by
                      every local search thread for each Unequal term
            </summary>
            <remarks> Currently this is just an alias for a Dictionary
                      but we might change later to a class that aggregates
                      a dictionary and other things, hence the alias
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1">
            <summary> A specialized Mapping from keys of type LS_Value to an arbitrary
                      IEquatable type. Will have best efficiency when the keys 
                      are taken from a contiguous range, otherwise is equivalent to a
                      dictionary.
            </summary>
            <remarks> The representation depends on whether the keys are contiguous. 
                      If such is the case we use an array representation. If on
                      the contrary the keys have vastly different values then indexing is
                      not a reasonable option anymore and then we use a dictionary.
                      In the current version the choice is made dynamically and we switch
                      at some point from contiguous to general (dictionary) representation 
                      if this ever needed, i.e. if some very different values appear.
                      In the current version we do not switch back to a contiguous
                      representation: once we use a dictionary this choice is not reversible. 
                      An estimate of number of values to be stored, given by the user
                      at construction time, is currently used to determine how large a
                      different we allow between the values in a contiguous representation.
            </remarks>
            <remarks> Invariant: at most one of the arrays is not-null
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.#ctor(System.Int32,`0)">
            <summary> A specialized Dictionary whose keys are Integer values
                      from a restricted range
            </summary>
            <param name="estimatedSize">An estimate of how many entries
                      will be entered in the dictionary
            </param>
            <param name="defaultValue">The value associated to any entry 
                      by default, i.e. if not explicitly overwritten
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.Clear">
            <summary> Resets the value associated to all keys to the default
            </summary>
            <remarks> We don't change representation, we just reset - 
                      the allocated collection remains allocated
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.EnumerateModifiedEntries">
            <summary> Enumerates all value pairs where the value is not the default
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.CreateContiguousRepresentation(System.Int32,`0)">
            <summary> Create a contiguous representation 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.SwitchToGeneralRepresentation">
            <summary> Construct a non-contiguous representation
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._array">
            <summary> An array used when the representation is dense
                      (null otherwise)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._dictionary">
            <summary> A dictionary used when the representation is sparse
                      (null otherwise)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._lowerBound">
            <summary> Lowest acceptable value</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._upperBound">
            <summary> Highest acceptable value</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._defaultValue">
            <summary> Value associated to any key by default</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1._estimatedSize">
            <summary> Expected number of entries </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LS_ValueMap`1.Item(System.Int32)">
            <summary> Gets/sets the value associated to a key
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspInequality">
            <summary>
            A Boolean which is equal to the sequential ordering of a otherSet of integers
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Less">
            <summary> A boolean which is equal to whether a sequence of integers is strictly ascending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Less.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to whether a sequence of integers is strictly ascending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Less.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Less.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Less.Name">
            <summary> Represent this class
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LessEqual">
            <summary> A boolean which is equal to whether a sequence of integers is ascending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LessEqual.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to whether a sequence of integers is ascending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LessEqual.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LessEqual.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LessEqual.Name">
            <summary> Represent this class
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Greater">
            <summary> A boolean which is equal to whether a sequence of integers is strictly descending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Greater.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to whether a sequence of integers is strictly descending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Greater.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Greater.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GreaterEqual">
            <summary> A boolean which is equal to whether a sequence of integers is descending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GreaterEqual.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A boolean which is equal to whether a sequence of integers is descending.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GreaterEqual.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Naive recomputation: Recompute the value of the term 
                      from the value of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GreaterEqual.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.GreaterEqual.Name">
            <summary> Represent this class
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LogicFunction">
            <summary>
            A base class for all logic operators
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LogicFunction.NumberInputsSatisfied(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Counts the number of inputs of the term that are 
                      currently satisfied 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LogicFunction.PickSatisfiedInput(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Picks an input, preferably one that is satisfied
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LogicFunction.PickViolatedInput(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Picks an input, preferably one that is violated
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LogicFunction.SelectSubtermWithWrongPolarity(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Selects a subterm that is in a direction opposite
                      to the one that is targetted for this function
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanNot">
            <summary> A constraint of the form bResult == (b0 != b1 != ...) where bN are Booleans
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanNot.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> bResult == !b0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanNot.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanNot.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanNot.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IsElementOf">
            <summary> A constraint of the form bResult == (b0 != b1 != ...) where bN are Booleans
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IsElementOf.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.CspSolverDomain)">
            <summary> bResult == !b0
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IsElementOf.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IsElementOf.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IsElementOf.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanAnd">
            <summary> A constraint of the form bResult == (b0 &amp; b1 &amp; ...) where bN are Booleans
                      There is no support for shortcut "&amp;&amp;" in the solver: that is not declarative.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanAnd.SizeLimit">
            <summary> Size at which we start using the incremental version
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A constraint of the form bResult == (b0 &amp; b1 &amp; ...) where bN are Booleans
                      There is no support for shortcut "&amp;&amp;" in the solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanAnd.OrdinalAmongBooleanAndTerms">
            <summary> A unique ID from 0 to [number of BooleanAnd terms]-1,
                      used as index for data specific to Unequal terms
            </summary>
            <remarks>
              The extra LS_Value is used to maintain incrementally the 
              sum of positive violations 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            <remarks> The violation of the Term is an indicator of whether the 
                      values currently assigned by the local search algorithm to 
                      all inputs are negative (subterms satisfied). 
                      If such is the case we take the max of the negative values. 
                      If on the contrary some terms have a positive violation
                      the violation of this is their sum.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.RecomputeMaxNegativeViolations(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputes the highest negative values
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.NaiveRecomputationForSmallSize(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Algorithm used when we have few inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanAnd.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanOr">
            <summary> A constraint of the form bResult == (b0 | b1 | ...) where bN are Booleans
                      There is no support for shortcut "||" in the solver: that is not declarative.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanOr.SizeLimit">
            <summary>
              size at which we start using the incremental version
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A constraint of the form bResult == (b0 | b1 | ...) where bN are Booleans
                      There is no support for shortcut "||" in the solver: that is not declarative.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BooleanOr.OrdinalAmongBooleanOrTerms">
            <summary> A unique ID from 0 to [number of BooleanOr terms]-1,
                      used as index for data specific to BooleanOr terms
            </summary>
            <remarks>
              The extra LS_Value is used to maintain incrementally the 
              sum of negative violations 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            <remarks> The violation of the Term is an indicator of whether the 
                      value currently assigned by the local search algorithm to 
                      one of the inputs is negative (subterm satisfied). 
                      If such is the case we take the sum of the negative inputs.
                      If all inputs are positive we take the min of these 
                      positive values.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.RecomputeMinPositiveViolations(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputes the highest negative values
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.NaiveRecomputationForSmallSize(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Algorithm used when wehave few inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanOr.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanImplies">
            <summary> A constraint of the form bResult == (a -> c) where a and c are Booleans
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanImplies.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> A constraint of the form bResult == (a -> c) where a and c are Booleans
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanImplies.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
             <summary> Recompute the value of the term from the value of its inputs
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanImplies.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanImplies.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.MOfNConstraint">
            <summary> A constraint about M of the N Boolean Term inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> Exactly M of the N Boolean Term inputs must be true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.SumTleastViolatedFalseTerms(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Finds the T violated terms that are least violated 
                      and sums their violations.
                      The result is guaranteed to be a positive violation:
                      if no term is violated then we return +1, otherwise
                      if the number N of violated terms is less than T we
                      sum these N terms.
            </summary>
            <param name="ls">Local search algorithm in which we are working
            </param>
            <param name="T">Number of violated terms to consider</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.SumTleastSatisfiedTrueTerms(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Finds the T satisfied terms that are least satisfied 
                      and sums their violations. 
                      The result is guaranteed to be a negative violation:
                      if no term is satisfied then we return -1, otherwise
                      if the number N of satisfied terms is less than T we
                      sum these N terms.
            </summary>
            <param name="ls">Local search algorithm in which we are working
            </param>
            <param name="T">Number of satisfied terms to consider</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.GetOrderedSubTermViolations(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Puts the violations of all subterms in an array and
                      sorts them in increasing order
            </summary>
            <param name="ls">Local search algorithm in which we are working
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.PseudoBooleanSum(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary>
            Computes the number of inputs that are true
            </summary>
            <remarks>
            Sum of 0/1 values will never overflow so no check to do
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MOfNConstraint.PseudoBooleanSumWithGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary>
            Computes the sum of the 0/1 values of all the (Boolean)
            inputs together with their gradients
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ExactlyMOfN">
            <summary> Exactly M of the N Boolean Term inputs must be true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ExactlyMOfN.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> Exactly M of the N Boolean Term inputs must be true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ExactlyMOfN.ToString">
            <summary> Represent this class.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ExactlyMOfN.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
             <summary> Recompute the value of the term from the value of its inputs
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ExactlyMOfN.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ExactlyMOfN.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AtMostMOfN">
            <summary> At most M of the N Boolean Term inputs may be true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AtMostMOfN.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> At most M of the N Boolean Term inputs may be true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AtMostMOfN.ToString">
            <summary> Represent this class.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AtMostMOfN.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AtMostMOfN.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AtMostMOfN.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanEqual">
            <summary> Constraint for bResult == (b0 == b1 == ...) between boolean args
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanEqual.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> bResult == (b0 == b1 == ...)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanEqual.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Naive recomputation: Recompute the value of the term 
                      from the value of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanEqual.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanUnequal">
            <summary> A constraint of the form bResult == (b0 != b1 != ...) where bN are Booleans
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanUnequal.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> bResult == (b0 != b1 != ...)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanUnequal.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanUnequal.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.sForbiddenList">
            <summary> A combination of variables with particular choices which are forbidden.
                      This is designed to be used for Learned Clauses.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenList.Create(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[],System.Int32[],System.Int32,System.Int32)">
            <summary> A list of variables and choices, which are a forbidden combination.
                      This is designed to be used for Learned Clauses.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenList.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenList.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.sForbiddenRange">
            <summary> A combination of variables and choices, which are a forbidden combination.
                      This is designed to be used for Learned Clauses.  All but the final
                      variable have just one value to avoid, and the final one may be a otherSet
                      of avoidances.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenRange.Create(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[],System.Int32[],System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain)">
            <summary> A combination of variables and choices, which are a forbidden combination.
                      This is designed to be used for Learned Clauses.  All but the final
                      variable have just one value to avoid, and the final one may be a otherSet
                      of avoidances.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenRange.ToString">
            <summary> Represent this class
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenRange.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sForbiddenRange.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisjointPacking">
            <summary>  A constraint imposing that the start times of a number of tasks be 
                       scheduled so that at no time instant their total consumption of
                       a shared resource is larger than the availability of this resource
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[],System.Int32[],System.Int32[],System.Int32)">
            <summary>  A constraint imposing that the start times of a number of tasks be 
                       scheduled so that at no time instant their total consumption of
                       a shared resource is larger than the availability of this resource
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.PropagateUnknown(Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary>
            Propagation algorithm when the constraint is
            negated or unknown
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.PropagateUntilStable">
             <summary>
             Main propagation method for the usual case
             where the constraint IsTrue
             </summary>   
             <returns>
             False if inconsistency found;
             note that this convention is different from the one in Propagate()
             </returns>
             <remarks>
             Use if we want to reach stable bounds...
             Or is it best to leave this to the propagator queue 
             (constraint will be re-activated anyway)
             This version is better for unit testing - easier to
             know what it's doing
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.PropagateOneStep">
             <summary>
             Main propagation method for the usual case
             where the constraint IsTrue
             </summary>
             <remarks>
             Use if we rely on propagation queue to re-activate
             this constraint until the bounds are stable
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.UpdateVarBounds(Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.Pair{System.Int32,System.Int32})">
            <returns>
            false if inconsistency found;
            note that this convention is different from the one in Propagate()
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.ReviseBounds(Microsoft.SolverFoundation.Solvers.DisjointPacking.TimeWindow,Microsoft.SolverFoundation.Solvers.DisjointPacking.Task,Microsoft.SolverFoundation.Solvers.Pair{System.Int32,System.Int32}@)">
            <summary>
            Compute a new pair [lower bound, upper bound]
            for the start time of the task
            considering its intersection with a particular time window
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.EnumerateTimeWindows">
            <summary>
            Enumerates all time intervals of interest in which some
            energy is consumed. These windows are the basis of reasoning
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.GetKeyTimeSteps">
            <summary>
            Gets the ordered non-redundant sequence of 
            time steps corresponding to a task's
            earliest/latest release or earliest/latest completions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.InPlaceSortUnique(System.Collections.Generic.List{System.Int32})">
            <summary>
            modifies the array in-place so that its elements 
            are sorted non-redundant
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisjointPacking.TimeWindow">
            <summary>
            A time window during which some energy is consumed
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisjointPacking.PackingState">
            <summary>
            Result of one iteration of propagator
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task">
            <summary>
            A Task groups together a start time (typically a variable), 
            a duration and a consumption
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task.Intersection(System.Int32,System.Int32)">
            <summary>
            Lower bound on energy consumed by the task
            during the time interval [start, end]
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task.IntersectionEarly(System.Int32,System.Int32)">
            <summary>
            Energy consumed by the task duing the time interval [start, end]
            ASSUMING the tast is scheduled as early as possible
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task.IntersectionLate(System.Int32,System.Int32)">
            <summary>
            Energy consumed by the task duing the time interval [start, end]
            ASSUMING the tast is scheduled as late as possible
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task.StartTimeIsPossible(System.Int32,Microsoft.SolverFoundation.Solvers.DisjointPacking.TimeWindow)">
            <summary>
            Would it be ok to schedule the task at the given 
            candidate start time considering the available energy in the
            time window?
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisjointPacking.Task.Energy">
            <summary>
            Resource * time consumed
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSystem">
            <summary>
            Main class that contains model construction and solving APIs
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem._propagator">
            <summary>
            Propagator that propagates value changes in variables through the constraint network.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem._baseSolver">
            <summary>
            Decider that maintains the decision stack during the backtrack search.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem._termMap">
            <summary>
            Term map that maps model terms to IntegerSolver terms. Created only when a clone ctor is called
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem._allTermCount">
            <summary> Counts the number of all terms created in this solver, including the ones created in Composites and Composites variables
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.#cctor">
            <summary> A Solver for Constraint problems on variables which have finite domains.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.#ctor">
            <summary> A general purpose finite solver implementation capable of handling a mix of logic and
                      non-linear math over domains up to +- 1 billion.  Create an IntegerSolverParams with
                      default values and the specified function for asynchronous querying of Abort status.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.#ctor(System.Func{System.Boolean},System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary> A general purpose finite solver implementation capable of handling a mix of logic and
                      non-linear math over domains up to +- 1 billion.  Create an IntegerSolverParams with
                      default values and the specified function for asynchronous querying of Abort status.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.#ctor(System.Func{System.Boolean},System.Collections.Generic.IEqualityComparer{System.Object},System.Int32)">
            <summary> A general purpose finite solver implementation capable of handling a mix of logic and
                      non-linear math over domains up to +- 1 billion.  Create an IntegerSolverParams with
                      default values and the specified function for asynchronous querying of Abort status.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Shutdown">
            <summary> Shutdown the ConstraintSystem instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report
            </summary>
            <param name="context"></param>
            <param name="solution"></param>
            <param name="solutionMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Constant(System.Int32)">
            <summary> Get a Term for the immutable value k
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Constant(System.Double)">
            <summary> Get a Term for the immutable real value k with the default precision
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Constant(System.Int32,System.Double)">
            <summary> Get a Term for the immutable real value k
            <param name="precision">Only allows 1, 10, 100, 1000, and 1000</param>
            <param name="k">Value</param>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Constant(Microsoft.SolverFoundation.Solvers.CspDomain,System.String)">
            <summary>
            Get a Term for the immutable symbol value k
            </summary>
            <param name="valueSet">The domain that the constant belongs to</param>
            <param name="k">the value of the constant</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Not(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is a Boolean inverse of its Boolean input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Or(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is a Boolean OR of its Boolean inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.IsElementOf(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> This function is true iff input is a member of domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Implies(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is a Boolean implication of the form antecedent -> consequent
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.And(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is a Boolean AND of its Boolean inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ExactlyMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff exactly m of its Boolean inputs are true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AtMostMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff at most m of its Boolean inputs are true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Equal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff all of its inputs are equal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Unequal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff every pairing of its inputs is unequal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Less(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.LessEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Greater(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GreaterEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Equal(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff all of its inputs are equal to the constant.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Unequal(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff every pairing of its inputs is unequal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Less(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.LessEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Greater(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GreaterEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Abs(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the absolute value of its input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Neg(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the negation of its input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Power(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary> This function is its input raised to the power.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Sum(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of its inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Min(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the minimum of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Max(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the minimum of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Product(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the product of its inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.SumProduct(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of the pairwise-product of its inputs.
            </summary>
            <remarks> The input vectors must be of equal length </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.FilteredSum(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of the conditional inputs.
            </summary>
            <remarks> The input vectors must be of equal length </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [index] input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> This function is the value of the [index] input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspDomain,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the value of the input selected by the keys,
                      which map into the data with the first key being most major.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspDomain[])">
            <summary> This function is the value of the input selected by the keys,
                      which map into the data with the first key being most major.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableInteger(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Int32[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableDecimal(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Double[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableSymbol(Microsoft.SolverFoundation.Solvers.CspTerm[],System.String[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableTerm(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableDomain(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspDomain[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableTerm(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.CspTerm}})">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableDomain(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.CspDomain}})">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TableCore(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[][])">
            <summary>
            Core method to creat a table. We assume all input validation has been done prior to the call to this method.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Packing(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Int32[],System.Int32[],System.Int32)">
            <summary> 
            A constraint imposing that the start times of a number of tasks be 
            scheduled so that at no time instant their total consumption of
            a shared resource is larger than the availability of this resource
            </summary>
            <param name="starts">start time of every task</param>
            <param name="durations">duration of each task</param>
            <param name="consumptions">consumptio of each task</param>
            <param name="capacity">availability of the resource</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AddConstraints(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> Specify which Function Terms are to be considered Constraints.  Not all Functions
                        automatically become constraints, indeed only Boolean-valued functions are
                        eligable to be Constraints since a Constraint "must be true".
                      All the other Functions are interior nodes in expression-trees which come in as
                        inputs to the Constraints.  Please consult examples in the user guide if this is unclear.
            </summary>
            <returns> True if and only if all constraints are valid.
            </returns>
            <remarks> There is no "AddVariables" method because all Variables are automatically known to the Solver.
                        It would just be extra clutter to ask a user to list them again.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.RemoveConstraints(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
            Remove constraints which were added by AddConstraints.
            </summary>
            <param name="constraints"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TryAddMinimizationGoals(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> Specify Terms which are to be minimized as the optimization goal of the solver.
                      If the solver is not given any goal, then the solver will find all feasible solutions.
                      If one Term is specified, the solver will find all solutions equalling the best value of the goal.
                      If more than one goal Term is supplied, then each Term is considered only within the set of
                        solutions satisfying the optimum of all preceding goals.
                      If TryAddMinimizationGoals is called separately then Terms will be appended to prior registered goals.
            </summary>
            <returns> false if the underlying solver cannot TryAddMinimizationGoals the given terms. </returns>
            <remarks> To maximize a goal, TryAddMinimizationGoals its negative.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.RemoveAllMinimizationGoals">
            <summary>
            Removes all minimization goals.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateIntegerSet(System.Int32[])">
            <summary>
            Create a Domain of the allowed integer values you provide (which must be in strictly ascending order)
            </summary>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateIntegerSet(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Create a Domain of the allowed integer values you provide (which must be in strictly ascending order)
            </summary>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <param name="from">The starting position in orderedUniqueSet</param>
            <param name="count">The number of elements from the starting position that should be included into the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalSet(System.Double[])">
            <summary>
            Create a Domain of the allowed real values with the default precision (which must be in strictly ascending order)
            </summary>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalSet(System.Int32,System.Double[])">
            <summary>
            Create a Domain of the allowed real values you provide (which must be in strictly ascending order)
            </summary>
            <param name="precision">The precision for this real value set</param>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalSet(System.Double[],System.Int32,System.Int32)">
            <summary>
            Create a Domain of the allowed real values with the default precision (which must be in strictly ascending order)
            </summary>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <param name="from">The starting position in orderedUniqueSet</param>
            <param name="count">The number of elements from the starting position that should be included into the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalSet(System.Int32,System.Double[],System.Int32,System.Int32)">
            <summary>
            Create a Domain of the allowed real values you provide (which must be in strictly ascending order)
            </summary>
            <param name="precision">The precision for this real value set</param>
            <param name="orderedUniqueSet">The ordered sequences of values to include in the set</param>
            <param name="from">The starting position in orderedUniqueSet</param>
            <param name="count">The number of elements from the starting position that should be included into the set</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateSymbolSet(System.String[])">
            <summary>
            Create a Domain of symbols.
            </summary>
            <param name="uniqueSymbols">The symbols in the Domain. Must contain no duplicates. We respect the order of the symbols.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateIntegerInterval(System.Int32,System.Int32)">
            <summary> Create a Domain of the integer interval [first .. last]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalInterval(System.Double,System.Double)">
            <summary> Create a Domain of the real interval [first .. last] with the default precision
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateDecimalInterval(System.Int32,System.Double,System.Double)">
            <summary> Create a Domain of the real interval [first .. last]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateComposite(System.Object)">
            <summary>
            Create an empty composite to which fields can be added.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateComposite">
            <summary>
            Create an empty composite with an auto-generated key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariable(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object)">
            <summary> Create a finite variable with the specified domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariable(Microsoft.SolverFoundation.Solvers.CspComposite,System.Object)">
            <summary>
            Create a composite variable
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariable(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> Create a finite variable with the given domain and an auto-generated key
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariable(Microsoft.SolverFoundation.Solvers.CspComposite)">
            <summary> Create a composite variable with an auto-generated key
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateBoolean(System.Object)">
            <summary> Create a boolean variable initially either false or true
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateBoolean">
            <summary>
            Create a boolean variable with an auto-generated key
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateUserVariable(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object)">
            <summary>
            Create a user variable whose value can be interactively set/unset
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateUserVariable(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
            Create a user variable with auto-generated key
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateUserBoolean(System.Object)">
            <summary>
            Create a user Boolean variable whose value can be interactively set/unset
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateUserBoolean">
            <summary>
            Create a user Boolean variable with auto-generated key
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariableVector(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object,System.Int32)">
            <summary> Create a vector of Finite Variable Terms all of the same initial domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariableVector(Microsoft.SolverFoundation.Solvers.CspComposite,System.Object,System.Int32)">
            <summary>
            Create a vector of Finite Variable Terms all of the same composite domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateVariableArray(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object,System.Int32,System.Int32)">
            <summary> Create an array of Finite Variable Terms all of the same initial domain.
                      It is defined as two-level to facilitate use of rows as inputs to the functions.
                      See the GetColumn helper method, below, for slicing the array a column at a time.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateBooleanVector(System.Object,System.Int32)">
            <summary> Create a vector of Boolean Variable Terms all of the same initial domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateBooleanArray(System.Object,System.Int32,System.Int32)">
            <summary> Create an array of Boolean Variable Terms all of the same initial domain.
                      It is defined as two-level to facilitate use of rows as inputs to the functions.
                      See the GetColumn helper method, below, for slicing the array a column at a time.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.TryGetVariableFromKey(System.Object,Microsoft.SolverFoundation.Solvers.CspTerm@)">
            <summary> If key corresponds to a variable, set term to the variable and return true.
            Otherwise, return false.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.StartNarrowingDomains">
            <summary>
            Start the domain narrowing thread. This method should be invoked only once. All constraints must
            be added to the solver prior to the invocation of this method.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.StopNarrowingDomains">
            <summary>
            Stop the domain narrowing thread. This method must be called after StartNarrowingDomains().
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.IsDomainNarrowingFinished">
            <summary>
            Test if the domain narrowing is finished.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ResetSolver">
            <summary>
            Reset the solver state for another round of solver from scratch
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateSolver">
            <summary>
            Create a solver instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateSolver(Microsoft.SolverFoundation.Services.ISolverEnvironment)">
            <summary>
            Create a solver instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CreateSolver(System.Func{System.Boolean},System.Collections.Generic.IEqualityComparer{System.Object},System.Int32)">
            <summary>
            Create a solver instance with the given parameters
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Solve">
            <summary>
            Solve the model using the default solver parameter.  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary>
            Solve the model using given solver parameter.  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AppendModel(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary>
            Append the model from the source solver to the target solver
            </summary>
            <param name="source">The solver that contains the model to be cloned</param>
            <param name="target">The solver that will contain the cloned model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AppendModel(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm})">
            <summary>
            Append the model from the source solver to the target solver
            </summary>
            <param name="source">The solver that contains the model to be appended</param>
            <param name="target">The solver whose model will be appended</param>
            <param name="preClonedTermMap">Record a set of terms that have been created in the target for the appending operation. 
            Maps the term in the source to the term in the target.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AppendModel(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.IntegerSolver)">
            <summary>
            Append the model from the source solver to the target solver
            </summary>
            <param name="source">The solver that contains the model to be cloned</param>
            <param name="target">The solver that will contain the cloned model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AppendModel(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.IntegerSolver,System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm})">
            <summary>
            Append the model from the source solver to the target solver
            </summary>
            <param name="source">The solver that contains the model to be appended</param>
            <param name="target">The solver whose model will be appended</param>
            <param name="preClonedTermMap">Record a set of terms that have been created in the target for the appending operation. 
            Maps the term in the source to the term in the target.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Presolve(System.Func{System.Boolean},Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Invoke propagation only to eliminate infeasible values from variable domains
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.SolveCore(Microsoft.SolverFoundation.Solvers.ConstraintSolverParams)">
            <summary>
              Solve the model; constructs a solution enumerator 
              specific to a particular directive
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.SymbolicConstant(System.Int32,System.Object)">
            <summary> Get a Term for the immutable value k.  Give it a key for convenience,
                      though this will NOT (as a constant) be visible in the Variables dictionary.
            </summary>
            <remarks> For OML compatibility only. Deprecated.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Save(System.IO.TextWriter)">
            <summary>
            Public interface for saving a model.
            </summary>
            <param name="textWriter"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GetColumn(Microsoft.SolverFoundation.Solvers.CspTerm[][],System.Int32)">
            <summary> This is a convenience function.  It will compose a Vector from any column of a Term array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GetNextRandomGenerator">
            <summary> Get a random generator
            </summary>
            <remarks> This is for local search in order to guarantee
                      that we explore the same initial assignments and
                      make the same "random" moves from this assignment
                      independently of the number of threads. Each time
                      we do a restart we pick the next generator,
                      which guarantees that if N restarts happen they
                      will explore the same points, independently on the
                      number fo threads.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.EnumerateSolutions">
            <summary> Get a sequence of solutions (or optimal solutions when there are goals) to the model.  Each solution is copied into a Dictionary.
                      The solution values are immutable.  You may overlap reading and using a solution with
                      solving for subsequent solutions. In case there are optimization goals, only optimal
                      solutions will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.EnumerateInterimSolutions">
            <summary> Get a sequence of interim solutions to the model when doing optimization.  Each solution is copied into a Dictionary.
                      The solution values are immutable.  You may overlap reading and using a solution with
                      solving for subsequent solutions. In case there are optimization goals, both optimal
                      and suboptimal solutions will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.EnumerateIntegerSolutions">
            <summary> Get a sequence of solutions to the model.  Each solution is copied into a Dictionary.
                      The solution values are immutable.  You may overlap reading and using a solution with
                      solving for subsequent solutions. In case there are optimization goals, only optimal
                      solutions will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.FixUserVariable(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Fix/Unfix the given user variable's value based on var.IsFixing(). 
            </summary>
            <param name="var">The user variable to fix/unfix</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AddChange(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> Record the Term which changed and how deep its prior value stack was
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Backtrack(System.Int32)">
            <summary>
            Backtrack to an earlier consistent point in the decision stack.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CheckAbort">
            <summary>
            Check to see if the solving should be aborted
            </summary>
            <remarks>Note that the method has a side-effect that caches the value into _isInterrupted</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.CheckForPower(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> Check to see if all inputs are the same term. If so, the product can be rewritten to a power.
            </summary>
            <returns>The exponent of the power if > 0. Otherwise, inputs are not the same term.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.QueryAbort">
            <summary> Callback for ending the solve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.MinFinite">
            <summary>
            Minimal integer value that CspSolver can use.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.MaxFinite">
            <summary>
            Maximal integer value that CspSolver can use.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.DefaultInterval">
            <summary> An CspIntervalDomain from the minimum to the maximum supported Finite value of the underlying Solver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.DefaultBoolean">
            <summary>
            A Boolean Domain that contains 0(false) and 1(true).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Empty">
            <summary> The Domain with Count zero and any attempt to get its first or last values will
                        throw InvalidOperationException.  Enumerations Forward or Backwards will be empty.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Precision">
            <summary>
            Get the global precision for real values in this solver obeject.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Parameters">
            <summary> Create a set of IntegerSolverParams with default values and the specified
                      function to use for asynchronous querying of Abort status.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AbortDomainNarrowing">
            <summary> Check if the Solver currently has been stopped by external request or such a request is pending.
                      Set to True to request an asynchronous stop.  The stop request is checked at frequent safe points
                        within the solver.
                      Setting to False when the solver is running is undefined: the solver may already have seen the request
                        but not finished acting on it.
            </summary>
            <remarks> The only guaranteed correct time to set False is prior to starting first solve. </remarks>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Variables">
            <summary> Enumerate the Variables that have been instantiated for this Solver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Constraints">
            <summary> Enumerate the Functions which have been added to this Solver as Constraints.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.MinimizationGoals">
            <summary> Enumerate the Functions which have been added to this Solver as Constraints.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.IsEmpty">
            <summary>
            Return true if and only if the model in the solver is empty
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.BacktrackCount">
            <summary>
            Get the number of backtracks during search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Version">
            <summary>
            Getter for solver version as a string.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.False">
            <summary> The Boolean Term {false} which is immutable and can be used anywhere you need a false constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.True">
            <summary> The Boolean Term {true} which is immutable and can be used anywhere you need a true constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.GoalCount">
            <summary>
            Get the number of minimization goals (>= 0)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.IsInterrupted">
            <summary>
            Return if the last solve is interrupted or not
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.Mode">
            <summary>
            Get or set the mode of the solver. If Debug* mode is set, then the solver will search for conflicts whenever a
            constraint is added.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.IsPureIntegerModel">
            <summary>
            Get/set the flag that indicates whether the model is pure integer model (thus suitable for IntegerSolver)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.AllTerms">
            <summary>
            Enumerate all terms that are constructed, including constants, variables (decisive and indecisive), and functions.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ModelConstructionMode">
            <summary>
            The model construction mode
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ModelConstructionMode.FullSpeed">
            <summary>
            Neither propagation nor search is performed. Load the model in full speed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ModelConstructionMode.DebugLight">
            <summary>
            Perform propagations after each constraint is added. Does not guarantee there is no conflicts
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ModelConstructionMode.DebugHeavy">
            <summary>
            Search for one solution after each constraint is added. Guarantees there is no conflicts
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ElementKey">
            <summary> A composite key for a Symbol which is an element in a vector or an array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ElementKey.ToString">
            <summary> Generate a name for this object upon demand
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ElementKey.Key">
            <summary>
            Get the key for the variable vector or array
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSystem.ElementKey.Index">
            <summary>
            Get the index that the key is associated with
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IDomainNarrowing">
            <summary> A user variable interface
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.Fix(System.Object)">
            <summary>
            Fix the value of this user var.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.Unfix">
            <summary>
            Unfix this user var.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.IsFinished">
            <summary>
            Test if domain narrowing is finished for this user var.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.IsSingleton">
            <summary>
            Test if the domain of feasible values of this user var is a singleton.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.IsFixing">
            <summary>
            Is the user variable just been fixed
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IDomainNarrowing.FeasibleValues">
            <summary>
            Return the current computed array of feasible values of this user var.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams">
            <summary>
            Optional solver parameters specifying the search strategy of the 
            CSP algorithm. Use for performance tuning 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary> adaptor to convert Directive into SimplexSolverParams
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.#ctor(System.Collections.ObjectModel.Collection{Microsoft.SolverFoundation.Solvers.CspTerm})">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSolverParams,System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm})">
            <summary>
            Copy constructor
            </summary>
            <param name="dir">The solver parameter to clone</param>
            <param name="termMap">The mapping between the modeling terms and actual solver terms. Needed to clone the SearchFirst list.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.FillInSolverParams(Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Fill in this ISolverParameters instance based on the given directive instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.SetElapsed(System.Int32)">
            <summary>
            Internal method to set the time used in search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.QueryAbort">
            <summary>
            Get/set the callback function that decides when to abort the search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.Solving">
            <summary>
            Callback called during solve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.Algorithm">
            <summary>
            Specifies which class of algorithm should be used
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.VariableSelection">
            <summary>
            Get/set the variable ordering heuristic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.ValueSelection">
            <summary>
            Get/set the value ordering heuristic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.MoveSelection">
            <summary>
            Get/set the move selection heuristic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.CustomizedHeuristic">
            <summary> Get/set the customized (user-defined) heuristic 
            </summary>
            <remarks> This strategy will effectively be used only if the properties
                      describing the choice of heuristic specify that the 
            </remarks>
                      
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.UserOrderVariables">
            <summary> Provide a list of variables that should be searched, breadth first,
                      in priority over the internal search strategy.
                      If called multiple times, the subsequent calls append terms to the
                      list (appended terms are searched later than those already in).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.RestartEnabled">
            <summary> Restarts are used to prevent investing too much time searching.
                      By default they are enabled.  When restarting, FDModel records learned
                      constraints that summarize the search space already covered
                      and then resumes in some other part of the state space.
                      It can be useful to disable restarts if you are supplying a
                      SearchFirst list.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.EnumerateInterimSolutions">
            <summary> Whether to enumerate interim solutions or only optimal solutions. Default is true. Local search algorithm ignores this flag and will always return interim solutions.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.Abort">
            <summary> The Solver will check the abort flag frequently and will
                      come to a graceful stop then return to the caller if the
                      abort flag is set.  This is useful when running the solver
                      on a background thread.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TimeLimitMilliSec">
            <summary> The limit on the CPU time before giving up.  This is a
                      simple alternative to spinning off a separate thread and
                      using Abort, if the interval is short.  Clear is forever.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.ElapsedMilliSec">
            <summary> The time it took to solve the most recent solution.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.CspSearchAlgorithm">
            <summary>
            Choice of algorithm 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.CspSearchAlgorithm.Any">
            <summary>
            Let the solver choose the search algorithm
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.CspSearchAlgorithm.TreeSearch">
            <summary>
            Backtracking based complete search algorithm
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.CspSearchAlgorithm.LocalSearch">
            <summary>
            Local search algorithm
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering">
            <summary>
            Choice of tree search algorithm  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.Any">
            <summary>
            Let the solver choose the variable ordering heuristics
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.MinimalDomainFirst">
            <summary>
            Enumeration that chooses a variable with smallest domain
            </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.DeclarationOrder">
            <summary>
            Enumeration following the declaration order of the variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.DynamicWeighting">
            <summary>
            Weigh variables dynamically according to their dependents and current domain sizes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.ConflictDriven">
            <summary>
            Enumeration based on conflict analysis following a variant 
            of the VSIDS heuristic used in SAT solvers
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.ImpactPrediction">
            <summary>
            Enumeration based on a forecast of the impact 
            of the decision
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchVariableOrdering.DomainOverWeightedDegree">
            <summary>
            Enumeration based on the "domain over weighted degree"
            </summary> 
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchValueOrdering">
            <summary>
            Choice of value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchValueOrdering.Any">
            <summary>
            Let the solver choose the variable ordering heuristics
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchValueOrdering.SuccessPrediction">
            <summary>
            Value enumeration based on a prediction of the success
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchValueOrdering.ForwardOrder">
            <summary>
            Value enumeration that follows the order of the values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.TreeSearchValueOrdering.RandomOrder">
            <summary>
            Value enumeration that picks uniformly at random
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove">
            <summary>
            Choice of moves for local search
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.Any">
            <summary>
            Let the solver choose the move heuristics
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.Greedy">
            <summary>
            Violation-guided greedy move
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.SimulatedAnnealing">
            <summary>
            Simulated annealing
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.GreedyNoise">
            <summary>
            Violation-guided greedy with noise
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.Tabu">
            <summary>
            Violation-guided greedy with noise and tabu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove.Gradients">
            <summary>
            Gradient-guided with tabu and escape strategy
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution">
            <summary>
            Represent a solution computed by a ConstraintSystem
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary>
            Internal constructor to create a ConstraintSolverSolution instance. Also forbid outsiders to create ConstraintSolverSolution instances.
            </summary>
            <param name="solver">A ConstraintSystem instance that does the actual solving of the model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver)">
            <summary>
            Internal constructor to create a ConstraintSolverSolution instance. Also forbid outsiders to create ConstraintSolverSolution instances.
            </summary>
            <param name="solver">A ConstraintSystem instance that does the actual solving of the model</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetNext">
            <summary>
            Compute the next solution and update the solution.
            </summary>
            <returns>Returns true if and only if a solution is found.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetIntegerValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetDoubleValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetSymbolValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetIntegerSetListValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetDoubleSetListValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.GetSymbolSetListValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Retrieve the value of the variable in this solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.TryGetValue(Microsoft.SolverFoundation.Solvers.CspTerm,System.Object@)">
            <summary>
            Try get the value of the given variable. This method never fails
            </summary>
            <returns>True if and only if the variable exists and its value is successfully retrieved</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.Quality">
            <summary>
            Get the solution quality 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.HasFoundSolution">
            <summary>
            Return true if and only if no more solutions exist
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.Item(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Overload [] for convenience
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.SolutionQuality">
            <summary>
            Solution quality
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.SolutionQuality.Unknown">
            <summary>
            Search was interrupted and solver hasn't found a feasible solution
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.SolutionQuality.Infeasible">
            <summary>
            Model is infeasible
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.SolutionQuality.Feasible">
            <summary>
            Solver found a feasible solution
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConstraintSolverSolution.SolutionQuality.Optimal">
            <summary>
            Solver found an optimal solution
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspComposite">
            <summary>
            A composite data type that is consist of finite set of Term members each of which has its own domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Constant(System.Double)">
            <summary> Get a Term for the immutable real value k with the default precision
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Constant(System.Int32)">
            <summary> Get a Term for the immutable value k
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Constant(System.Int32,System.Double)">
            <summary> Get a Term for the immutable real value k
            <param name="precision">Only allows 1, 10, 100, 1000, and 1000</param>
            <param name="k">Value</param>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Constant(Microsoft.SolverFoundation.Solvers.CspDomain,System.String)">
            <summary>
            Get a Term for the immutable symbol value k
            </summary>
            <param name="stringValueSet">The domain that the constant belongs to</param>
            <param name="symbol">the value of the constant</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Abs(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the absolute value of its input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.And(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is a Boolean AND of its Boolean inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.AtMostMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff at most m of its Boolean inputs are true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Equal(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff all of its inputs are equal to the constant.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Equal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff all of its inputs are equal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.IsElementOf(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> This function is true iff input is a value in the domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.ExactlyMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff exactly m of its Boolean inputs are true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.FilteredSum(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of the conditional inputs.
            </summary>
            <remarks> The input vectors must be of equal length </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Greater(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Greater(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.GreaterEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.GreaterEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is greater than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Implies(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is a Boolean implication of the form antecedent -> consequent
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the value of the input selected by the keys,
                      which map into the data with the first key being most major.
                      This allows generalization to multiple keys, though we choose
                      to represent the terms as a single vector instead of an
                      arbitrary-dimension array (which in C# is awkward to build or use).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [index] input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the value of the [row][column] input
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Less(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Less(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.LessEqual(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.LessEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff each of its inputs is less than or equal to the following input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Neg(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is the negation of its input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Not(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> This function is a Boolean inverse of its Boolean input.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Or(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is a Boolean OR of its Boolean inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Power(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary> This function is its input raised to the power.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Product(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the product of its inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Sum(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of its inputs.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.SumProduct(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is the sum of the pairwise-product of its inputs.
            </summary>
            <remarks> The input vectors must be of equal length </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Unequal(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff every pairing of its inputs is unequal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Unequal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> This function is true iff every pairing of its inputs is unequal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableTerm(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.CspTerm}})">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableDomain(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.CspDomain}})">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableDecimal(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Double[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableInteger(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Int32[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableSymbol(Microsoft.SolverFoundation.Solvers.CspTerm[],System.String[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            value combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableTerm(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.TableDomain(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspDomain[][])">
            <summary>
            This function creates a relation constraint using the column variables and the
            inputs. colVars define the variables for all columns. inputs are rows of valid
            Domain combinations of column variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.AddConstraints(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
            Add composite-wise constraints
            </summary>
            <param name="constraints">Constraints to be added. Must be constructed using Field Terms.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.AddField(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object,System.Int32)">
            <summary>
            Add a member to the composite.
            </summary>
            <param name="domain">DomainComposite of the field</param>
            <param name="key">The key by which we can refer to this field later</param>
            <param name="arity">The number of fields of this domain</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.Fields(System.Object)">
            <summary>
            Access the field of the composite that has the given key.
            </summary>
            <param name="key"></param>
            <returns>An array of Terms that represent the fields. The length of the array is the same as the arity of this field.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspComposite.ToString">
            <summary> String representation of this Composite
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspComposite.IsEmpty">
            <summary>
            Return true if and only if the model in the solver is empty
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspComposite.True">
            <summary> The Boolean Term {true} which is immutable and can be used anywhere you need a true constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspComposite.False">
            <summary> The Boolean Term {false} which is immutable and can be used anywhere you need a false constant.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspComposite.Key">
            <summary>
            Get the key of this composite
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSolverDomain">
            <summary> A CspSolverDomain represents the allowed values of a Term.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspDomain">
            <summary> A Domain represents the allowed values of a Term.
                      A Domain is immutable.  An implementation of a Solver may choose to
                        pool equal value sets partially or completely.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.SetEqual(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> Check if this Domain and the other Domain have identical contents.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Values">
            <summary>
            Enumerate all values in this domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.ContainsValue(System.Object)">
            <summary> Check if the given value is an element of the domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Forward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Forward">
            <summary> Enumerate all allowed choices from least to greatest.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Backward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Backward">
            <summary> Enumerate all allowed choices from greatest to least.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspDomain.Contains(System.Int32)">
            <summary> Check if the given value is an element of the domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.Kind">
            <summary>
            Return the kind of values in this Domain.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.Count">
            <summary> How many distinct choices is this restriction allowing?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.FirstValue">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.LastValue">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.First">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspDomain.Last">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspDomain.ValueKind">
            <summary>
            Valid kinds allowed in domains.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspDomain.ValueKind.Integer">
            <summary>
            Integer values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspDomain.ValueKind.Decimal">
            <summary>
            Decimal values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspDomain.ValueKind.Symbol">
            <summary>
            Symbolic values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.#ctor">
            <summary> A CspSolverDomain represents the allowed values of a Term.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Values">
            <summary>
            Enumerate all values in this domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.ContainsValue(System.Object)">
            <summary> Check if the given value is an element of the domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Forward">
            <summary> Enumerate all allowed choices from least to greatest.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Backward">
            <summary> Enumerate all allowed choices from greatest to least.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Pred(System.Int32)">
            <summary> The predecessor within the domain, of the given value, or Int32.minVal if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Succ(System.Int32)">
            <summary> The successor within the domain, of the given value, or Int32.maxVal if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.IndexOf(System.Int32)">
            <summary> Return the index for the exact match of value x if the Domain were enumerated.
                      Returns an undefined negative number if x is not a member of the Domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <param name="min">lowerbound</param>
            <param name="max">upperbound</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <param name="orderedUniqueSet">The set to intersect</param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the other CspSolverDomain.  Return false if no change to this.
            </summary>
            <param name="otherValueSet">The set to intersect</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Exclude(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Remove the range [min..max] from the interval.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Remove the orderedUniqueSet from this CspSolverDomain.  Return false if no change.
            </summary>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <param name="orderedUniqueSet">The set to exclude</param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Remove the other CspSolverDomain from this.  Return false if no change.
            </summary>
            <param name="otherValueSet">The set to exclue</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Clone">
            <summary> Clone this domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.GetValue(System.Int32)">
            <summary>
            Return the actural value of in the domain that is mapped to the input integer. 
            Based on the value type, the returned value could be an integer, a double, or a string.
            </summary>
            <param name="intval">The internal integer value</param>
            <returns>The external value that is mapped to the input integer value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.GetInteger(System.Object)">
            <summary>
            Return the internal integer representation of the given value, based on its value type.
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Pick(System.Random)">
            <summary> Pick a value at random from the domain
            </summary>
            <param name="prng">a Pseudo-Random Number Generator</param>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverDomain.FirstValue">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverDomain.LastValue">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSolverDomain.Item(System.Int32)">
            <summary> Get the i'th value of the Domain.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.sEmptyDomain">
            <summary> A Term with no value consistent with the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.#ctor">
            <summary> Please use immutable instance ConstraintSystem.DEmpty.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Forward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Forward">
            <summary> Enumerate allowed choices.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Backward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from last to first inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Backward">
            <summary> Enumerate allowed choices in reverse order.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Contains(System.Int32)">
            <summary> Check if the given value is an element of the domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.SetEqual(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> Check if this CspSolverDomain and the other CspSolverDomain have identical contents.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Pred(System.Int32)">
            <summary> The predecessor within the domain, of the given value, or Int32.MinValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Succ(System.Int32)">
            <summary> The successor within the domain, of the given value, or Int32.MaxValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.IndexOf(System.Int32)">
            <summary> Return the index for the exact match of value x if the Domain were enumerated.
                      Returns an undefined negative number if x is not a member of the Domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.EmptyOperation(Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Operations on an Empty CspSolverDomain usually indicate a programming error.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the other CspSolverDomain.  Return false if no change to this.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Exclude(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Exclude the given bounds.  Return false if no change.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Exclude the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Exclude the other CspSolverDomain.  Return false if no change to this.
            </summary>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.sEmptyDomain.ToString">
            <summary> Represent.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Count">
            <summary> How many distinct choices is this restriction allowing?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.sEmptyDomain.First">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Last">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.sEmptyDomain.Item(System.Int32)">
            <summary> Get the i'th value of the Domain.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspIntegerDomain">
            <summary> An integer interval [min .. max].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.#ctor">
            <summary> An integer restraint.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.FirstBound(System.Int32,System.Int32[])">
            <summary> Return the index of the initial value greater-or-equal to the given first value.
            </summary>
            <returns> a number in range [0 .. Length], where Length means beyond-end. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.LastBound(System.Int32,System.Int32[])">
            <summary> Return the index of the final value less-or-equal to the given last value.
            </summary>
            <returns> a number in range [-1 .. Length-1], where -1 means before-start. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspIntervalDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="otherValueSet"> The interval from which min,max are defined, null if none </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Intersect(System.Int32[],Microsoft.SolverFoundation.Solvers.CspSetDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <param name="orderedUniqueSet">The set to intersect</param>
            <param name="otherValueSet"> The otherSet from which the restriction otherSet is defined </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <param name="orderedUniqueSet">The set to intersect</param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Intersect(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the other CspSolverDomain.  Return false if no change to this.
            </summary>
            <param name="otherValueSet">the set to intersect</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Exclude the other CspSolverDomain.  Return false if no change to this.
            </summary>
            <param name="otherValueSet">The set to exclude</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntegerDomain.AreDecimalsEqual(System.Int32,System.Double,System.Double)">
            <summary>
            Compare whether the two given decimals are equal according to the precision
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspIntervalDomain">
            <summary> An integer interval [min .. max].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Create(System.Int32,System.Int32)">
            <summary> An integer interval [min .. max].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Create(System.Int32,System.Double,System.Double)">
            <summary>
            A discrete real interval [min .. max] with the given precision.
            </summary>
            <param name="min">The min value of the interval</param>
            <param name="max">The max value of the interval</param>
            <param name="precision">The values in the interval are accurate upto 1/precision</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Contains(System.Int32)">
            <summary> Does the domain include item?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Forward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Backward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.SetEqual(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> Check if this CspSolverDomain and the other CspSolverDomain have identical contents.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Pred(System.Int32)">
            <summary> The predecessor within the domain, of the given value, or Int32.MinValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Succ(System.Int32)">
            <summary> The successor within the domain, of the given value, or Int32.MaxValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.ToString">
            <summary> String representation of this interval domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.IndexOf(System.Int32)">
            <summary> Return the index for the exact match of value x if the Domain were enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspIntervalDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="otherValueSet"> Allows sharing the other set, if that proves to be answer </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Intersect(System.Int32[],Microsoft.SolverFoundation.Solvers.CspSetDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <param name="orderedUniqueSet">The set to </param>
            <param name="otherValueSet"> Allows sharing the other set, if that proves to be answer </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Exclude(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Remove the range [min..max] from the interval.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Remove the orderedUniqueSet from the interval.  Return false if no change.
            </summary>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <param name="orderedUniqueSet">The set to exclude</param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Count">
            <summary> How many distinct choices is this restriction allowing?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.First">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Last">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspIntervalDomain.Item(System.Int32)">
            <summary> Get the i'th value of the Domain.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSymbolDomain">
            <summary>
            A value set of symbols
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSymbolDomain.Create(System.String[])">
            <summary> A string value set {string1, string2, ...}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSymbolDomain.ToString">
            <summary> String representation of this symbol domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSymbolDomain.GetSymbol(System.Int32)">
            <summary>
            Return the string value represented by integer i
            </summary>
            <param name="i">The interger representation (starts from 0)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSymbolDomain.GetIntegerValue(System.String)">
            <summary>
            Return the integer representation of the string
            </summary>
            <param name="s"></param>
            <returns>0 if s does not belong to this CspSymbolDomain</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSetDomain">
            <summary> An integer otherSet of choices {j, j, r, ..}
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.#ctor(System.Int32[],Microsoft.SolverFoundation.Solvers.CspDomain.ValueKind,System.Int32)">
            <summary> An integer otherSet {j, j, r, ..}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Create(System.Int32[],System.Int32,System.Int32)">
            <summary> An integer otherSet {j, j, r, ..}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Create(System.Int32[])">
            <summary> An integer otherSet {j, j, r, ..}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Create(System.Int32,System.Double[],System.Int32,System.Int32)">
            <summary> An integer otherSet {j, j, r, ..}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Create(System.Int32,System.Double[])">
            <summary> An integer otherSet {j, j, r, ..}.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Contains(System.Int32)">
            <summary> Does the domain include item?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Forward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Backward(System.Int32,System.Int32)">
            <summary> Enumerate allowed choices from first to last inclusive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.SetEqual(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary> Check if this CspSolverDomain and the other CspSolverDomain have identical contents.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Pred(System.Int32)">
            <summary> The predecessor within the domain, of the given value, or Int32.MinValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Succ(System.Int32)">
            <summary> The successor within the domain, of the given value, or Int32.MaxValue if none.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.ToString">
            <summary> String representation of this set domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.IndexOf(System.Int32)">
            <summary> Return the index for the exact match of value x if the Domain were enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Intersect(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspIntervalDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given bounds.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="otherValueSet"> Allows sharing the other set, if that proves to be answer </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Intersect(System.Int32[],Microsoft.SolverFoundation.Solvers.CspSetDomain,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Intersect with the given ordered distinct otherSet.  Return false if no change.
            </summary>
            <param name="orderedUniqueSet">The set to intersect</param>
            <param name="otherValueSet"> Allows sharing the other set, if that proves to be answer </param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Exclude(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverDomain@)">
            <summary> Remove the range [min..max] from the otherSet.  Return false if no change.
            </summary>
            <param name="min">the lowerbound</param>
            <param name="max">the upperbound</param>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetDomain.Exclude(Microsoft.SolverFoundation.Solvers.CspSolverDomain@,System.Int32[])">
            <summary> Remove the orderedUniqueSet from the interval.  Return false if no change.
            </summary>
            <param name="newD"> New CspSolverDomain, or "this" if no change. </param>
            <param name="orderedUniqueSet">The set to exclude</param>
            <returns> True iff a narrower restraint is resulting. </returns>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSetDomain.Count">
            <summary> How many distinct choices is this restriction allowing?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSetDomain.Set">
            <summary> Return the otherSet of permitted choices.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSetDomain.First">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSetDomain.Last">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspSetDomain.Item(System.Int32)">
            <summary> Get the i'th value of the Domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspCompositeVariable.ToString">
            <summary> String representation of this Composite variable
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ProductOrPower">
            <summary> A constraint of the form result == arg^power
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ProductOrPower.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> A constraint of the form result == arg^power
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Power">
            <summary> A constraint of the form result == arg^power
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Power.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> A constraint of the form result == arg^power
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Power.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Power.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Power.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Product">
            <summary> An integer equals the product of a sequence of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> An integer equals the product of a sequence of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RestrictProportion(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> this == v * iProd
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RestrictProduct(Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Restrict the bounds of z to the limits of (v * w * iProd)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.BoundBy1stOver2nd(Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Restrict the bounds of v to the limits of (z / (w * iProd))
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RestrictMultiples(System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Restrict Z to be multiples of iProd
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.AddFactors(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary> Add the positive factors of n to the factors. The generated factors will not contain duplicates.
                      But factors list may have contained other factors, so we don't guarantee that the whole factors list is duplicate-free.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RestrictFactors(Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Restrict v and w to being possible factors of z/iProd.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of  its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Product.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Min">
            <summary> A constraint of the form result = min (arglist)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Min.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> An integer equals the minimum of a sequence of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Min.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Min.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Min.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Min.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Max">
            <summary> A constraint of the form result = max (arglist)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Max.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> An integer equals the maximum of a sequence of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Max.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Max.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Max.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Max.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Abs">
            <summary> A constraint of the form result == Abs(arg)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Abs.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> A constraint of the form result == Abs(arg)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Abs.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Abs.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Abs.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Negate">
            <summary> A constraint of the form result == -arg
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Negate.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> A constraint of the form result == -arg
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Negate.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Negate.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Negate.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Sum">
            <summary> A constraint of the form resultV == i0 + i1 + i2 + ... where the iN are integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Sum.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[])">
            <summary> An integer equals the sum of a sequence of integers.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Sum.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Sum.PropagateChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Incremental recomputation: update the value of the term 
                      when one of its arguments is changed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Sum.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Sum.SelectSubtermToFlip(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,System.Int32)">
            <summary> Suggests a sub-term that is likely to be worth flipping,
                      together with a suggestion of value for this subterm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IntMap">
            <summary> A map is an N-dimensional index.  The axes each have a discrete otherSet of possible choices,
                      and the axes provide coordinates to select minus100 of the variables referenced by the map.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntMap.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspSolverTerm[],Microsoft.SolverFoundation.Solvers.CspSolverDomain[])">
            <summary> {arg0, arg1, ..argN-1} [argN] [argN+1] [..].  A map is an N-dimensional index.
                      The axes each have a discrete otherSet of possible choices,
                      and the axes provide coordinates to select one of the variables referenced by the map.
                      The variables being indexed are [0..N-1] of the inputs, then follow the indexer args.
                      
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntMap.RecomputeValue(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recompute the value of the term from the value of its inputs
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntMap.RecomputeGradients(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary> Recomputation of the gradient information attached to the term
                      from the gradients and values of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntMap.ComputePosition(Microsoft.SolverFoundation.Solvers.LocalSearchSolver)">
            <summary>
            looks-up the current values of the index terms
            and computes the corresponding position in the input array
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntMap.EstimateIndexChange(Microsoft.SolverFoundation.Solvers.LocalSearchSolver,Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary>
            What would be the value if we re-assigned one of the index terms to newval?
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor">
            <summary>
            Concrete implementation of the Visitor pattern which produces the CspNative Format for ConstraintSystem models
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IVisitor">
            <summary>
            Part of the Visitor pattern for visiting all components of a ConstraintSystem.  This does the work of the Visitor pattern.
            The Visit methods are overloaded for all the types where we are interested in exploring.  Different concrete implementations can have
            very different behavior.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.writer">
            <summary>
            stream writer used when saving.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.solver">
            <summary>
            The ConstraintSystem which we are visiting.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.domainTable">
            <summary>
            Symbol table for all domains
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.outError">
            <summary>
            Used when saving.  The visitor pattern has no facilities for passing the extra pattern.  I has to be part of the 
            Visitor concrete object.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.GenerateName(Microsoft.SolverFoundation.Solvers.CspSolverDomain)">
            <summary>
            Helper which generates a string when a domain is given.  This name will have the "generated format".  It does not
            include the quotes.
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.GenerateName(Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary>
            Helper which gteneratees a string when a ConstraintSystem is given.  This name will have the "generated format".
            It does not include the quotes.
            </summary>
            <param name="solv"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.EscapeAndQuoteChars(System.String,System.Char)">
            <summary>
            This adds escape characters and quotes to a symbol name as directed.
            </summary>
            <param name="inputString"></param>
            <param name="quoteChar"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.FormatDomainName(Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.TermNameEntry)">
            <summary>
            For a domain, this will format the domain name in preparation for output.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.FormatVarName(System.String,System.Boolean)">
            <summary>
            for a variable this will format the name in preparation for output.
            </summary>
            <param name="strName"></param>
            <param name="generated"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.FormatTermName(System.String)">
            <summary>
            Format term this will format the name in preparation for output.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.FormatSymbol(System.String)">
            <summary>
            For a symbol this will format the name in preparation for output
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.WriteTermString(Microsoft.SolverFoundation.Solvers.CspSolverTerm@,System.Boolean)">
            <summary>
            This helper method figures out what to do with a particular term.  It figures out the base type for the term
            and either outputs the name or the definition.
            </summary>
            <param name="t"></param>
            <param name="definingTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitMultiTermOperator(System.String,Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            If an operator may have multiple terms this is called to output the operator, the name, and the 
            references to each term in the multi-term operator.
            </summary>
            <param name="operatorTerm"></param>
            <param name="term"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitIsElementOfOperator(System.String,Microsoft.SolverFoundation.Solvers.IsElementOf)">
            <summary> IsElementOf operator.
            </summary>
            <param name="operatorTerm"></param>
            <param name="term"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitMofNTermOperator(System.String,Microsoft.SolverFoundation.Solvers.MOfNConstraint)">
            <summary>
            This is very similar to a multi-term operator except that the M of N structures are more strict.
            </summary>
            <param name="operatorTerm"></param>
            <param name="term"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Less)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="lessTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Greater)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="greaterTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.LessEqual)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="lessEqualTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.GreaterEqual)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="greaterEqualTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Equal)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="equalTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Unequal)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="unequalTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanImplies)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="impliesTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanNot)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="notTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanAnd)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="andTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanOr)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="orTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanEqual)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="bEqualTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.BooleanUnequal)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="bUnequalTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Product)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="productTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Abs)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="absTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Sum)">
            <summary>
            The work is delegated to the Multi-term operator
            </summary>
            <param name="sumTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Negate)">
            <summary>
            The work is delegated to the Multi-term operator.  This appears odd except that the format for a single
            term is identical, there just happens to only be one of them.
            </summary>
            <param name="negTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitConstraint(Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary>
            This writes the Constraint keyword and the terms after.
            </summary>
            <param name="constraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitGoal(Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary>
            This writes the goal keyword and the terms after.
            </summary>
            <param name="goal"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.Power)">
            <summary>
            This writes the power keyword, name, term name, and integer exponent.
            </summary>
            <param name="powTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.IsElementOf)">
            <summary> Delegate to helper for IsElementOf terms
            </summary>
            <param name="isElementOfTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.ExactlyMOfN)">
            <summary>
            The work is delegated to the helper for M of N terms
            </summary>
            <param name="exMofNTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.AtMostMOfN)">
            <summary>
            The work is delegated to the helper for M of N terms
            </summary>
            <param name="atMMofNTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.IntMap)">
            <summary>
            Outputs the intmap term.  
            </summary>
            <param name="intmapTerm"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.CspSolverDomain)">
            <summary>
            This writes the domain definition regardless of the type of domain.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.VisitDefinition(Microsoft.SolverFoundation.Solvers.CspVariable@)">
            <summary>
            Visits the definition of a variable (as opposed to a reference to it).
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Visit(Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            Visits a reference to a variable usually from within an expression.
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.WriteHeaderBlock">
            <summary>
            Writes the header block for the required format..
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspNativeSaveVisitor.Save(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.IO.TextWriter)">
            <summary>
            Main entry point into the serialization code.
            </summary>
            <param name="cspSolver"></param>
            <param name="textWriter"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspPowerSet">
            <summary>
            A composite class that is designed specific for representing power-set domains.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspPowerSet.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Object,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
            Construct a composite that represents the power-set of the baseline.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspPowerSet.Kind">
            <summary>
            Get the value kind of this power-set domain.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSetListHelper">
            <summary>
            Base class for Set/List related operations
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.CheckForBadInputs(System.Boolean,Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Validate inputs
            </summary>
            <param name="isCheckingForSets">Whether we are verifying the input vars for set variables</param>
            <param name="solver">The solver</param>
            <param name="setlistVar1">The first set/list variable</param>
            <param name="setlistVar2">The second set/list variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.IsSetVariable(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Check if the Term is a Set variable
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.IsListVariable(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Check if the Term is a List variable
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.NormalizeConstantSet(System.Int32[])">
            <summary>
            Sort the given integer subset
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.NormalizeConstantSet(System.Int32,System.Double[])">
            <summary>
            Sort the given decimal subset
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.NormalizeConstantList(System.Int32[],System.Int32[]@)">
            <summary>
            Sort the given integer list and remove duplicates
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.NormalizeConstantList(System.Int32,System.Double[],System.Double[]@)">
            <summary>
            Sort the given decimal list and remove duplicates
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.IsTrue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Decide if the booleanVar is fixed to value True.
            </summary>
            <param name="booleanVar">A CspBooleanVariable whose value must be fixed</param>
            <returns>Whether booleanVar is fixed to True</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetDecimalValue(Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32)">
            <summary>
            Convert the integer into a decimal in the domain.
            </summary>
            <param name="domain">A decimal domain</param>
            <param name="ival">An integer representation of the decimal in the domain</param>
            <returns>The decimal value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetSymbolValue(Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32)">
            <summary>
            Convert the integer into a symbol in the domain.
            </summary>
            <param name="domain">A symbol domain</param>
            <param name="ival">An integer representation of the symbol in the domain</param>
            <returns>The symbol value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.ValueEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Object)">
            <summary>
            Create a Term that represents the equality Term: var = val, based on var's kind
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.AsCspSolverTerm(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Cast Term t to CspSolverTerm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.AsCspSolverDomain(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
            Cast Domain d to CspSolverDomain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerSetDomain(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Get the CspPowerSet composite from the setVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerSetListBaseline(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Get the CspPowerSet or CspPowerList composite baseline from the setlistVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerSetValueIndexMap(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Get the CspPowerSet composite ValueIndexMap from the setVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerSetFields(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm@,Microsoft.SolverFoundation.Solvers.CspTerm[]@)">
            <summary>
            Get the Fields and Cardinality Terms from the setVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerListDomain(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Get the CspPowerList composite from the listVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerListFields(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm@,Microsoft.SolverFoundation.Solvers.CspTerm[]@)">
            <summary>
            Get the list and length field Terms from the listVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.GetPowerListMaxLength(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Get the max length of the sublists in the power-list domain from the listVar
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.CompareCspValues(Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32,Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32)">
            <summary>
            Compare two domains and two integer representations of values in the domains. The two domains must be of the same kind.
            If they are symbol domains, they must also be the same domain object.
            </summary>
            <returns>negative value if v1 less than v2; 0 if v1 = v2; positive value if v1 greater than v2</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetListHelper.DomainUnion(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspDomain,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
            Compute the union of the two input domains
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSetOperators">
            <summary>
            Helper class to model all set operators
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.CreatePowerSet(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Object,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
            Create a CspPowerSet, which works as a power-set domain of the baseline
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.ConstantIntegerSet(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[])">
            <summary>
            Create a constant integer set
            </summary>
            <param name="solver">The solver</param>
            <param name="subset">An array of unique integers</param>
            <returns>Term representing the constant interger set</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.ConstantDecimalSet(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Double[])">
            <summary>
            Create a constant decimal set using the given scale
            </summary>
            <param name="solver">The solver</param>
            <param name="subset">An array of unique decimals</param>
            <returns>Term representing the constant decimal set</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.ConstantSymbolSet(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspDomain,System.String[])">
            <summary>
            Create a constant symbol set
            </summary>
            <param name="solver">The solver</param>
            <param name="symbolDomain">The symbol domain to which the given symbols belong</param>
            <param name="subset">An array of unique symbols that belong to the symbol domain (symbols that do not belong to symbolDomain will be discarded silently)</param>
            <returns>Term representing the constant symbol set</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SetEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents setVar1 = setVar2
            </summary>
            <param name="solver">The solver</param>
            <param name="setVar1">The CspPowerSet variable that represents the first set variable</param>
            <param name="setVar2">The CspPowerSet variable that represents the second set variable</param>
            <returns>Term representing setVar1 = setVar2</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SetEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32[])">
            <summary>
            Create a Term that represents setVar1 = set2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SetEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents set1 = setVar2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.MemberOf(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "val is a member of setVar"
            </summary>
            <param name="solver">The solver</param>
            <param name="valVar">The value</param>
            <param name="setVar">The set where the value belongs</param>
            <returns>Term representing "val is a member of setVar"</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.MemberOf(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "val is a member of setVar"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.MemberOf(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32[])">
            <summary>
            Create a Term that represents "valVar is a member of set"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SubsetEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "setVar1 is a subset of setVar2"
            </summary>
            <param name="solver">The solver</param>
            <param name="setVar1">The first set variable (the subset)</param>
            <param name="setVar2">The second set variable (the superset)</param>
            <returns>Term representing "setVar1 is a subset of setVar2"</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SubsetEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32[])">
            <summary>
            Create a Term that represents "setVar1 is a subset of set2"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.SubsetEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "set1 is a subset of setVar2"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.Cardinality(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "the cardinality of setVar"
            </summary>
            <param name="solver">The solver</param>
            <param name="setVar">The set variable</param>
            <returns>Term representing the cardinality of setVar</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.Union(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "the union of setVar1 and setVar2". Two set variables must have the same value kind.
            </summary>
            <returns>Term representing the union of setVar1 and setVar2</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.Intersection(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "the intersection of setVar1 and setVar2". Two set variables must have the same value kind.
            </summary>
            <returns>Term representing the intersection of setVar1 and setVar2</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSetOperators.Difference(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "the set difference of setVar1 with setVar2". Two set variables must have the same value kind.
            </summary>
            <returns>Term representing the set difference of setVar1 with setVar2</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspPowerList">
            <summary>
            A composite class that is designed specific for representing power-list domains.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspPowerList.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Object,Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32)">
            <summary>
            Construct a composite that represents the power-set of the baseline.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspPowerList.Kind">
            <summary>
            Get the value kind of this power-set domain.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspListOperators">
            <summary>
            Helper class to model all list operators
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ConstantIntegerList(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[])">
            <summary>
            Create a constant integer list
            </summary>
            <param name="solver">The solver</param>
            <param name="list">An array of integers</param>
            <returns>Term representing the constant interger list</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ConstantDecimalList(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Double[])">
            <summary>
            Create a constant decimal list using the given scale
            </summary>
            <param name="solver">The solver</param>
            <param name="list">An array of decimals</param>
            <returns>Term representing the constant decimal list</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ConstantSymbolList(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspDomain,System.String[])">
            <summary>
            Create a constant symbol list
            </summary>
            <param name="solver">The solver</param>
            <param name="symbolDomain">The symbol domain to which the given symbols belong</param>
            <param name="list">An array of symbols that belong to the symbol domain</param>
            <returns>Term representing the constant symbol list</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.CreatePowerList(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Object,Microsoft.SolverFoundation.Solvers.CspDomain,System.Int32)">
            <summary>
            Create a CspPowerList, which works as a power-list domain of the baseline
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ListEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents listVar1 = listVar2
            </summary>
            <param name="solver">The solver</param>
            <param name="listVar1">The CspPowerList variable that represents the first list variable</param>
            <param name="listVar2">The CspPowerList variable that represents the second list variable</param>
            <returns>Term representing listVar1 = listVar2</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ListEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32[])">
            <summary>
            Create a Term that represents listVar1 = list2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ListEqual(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents list1 = listVar2
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.SublistEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "listVar1 is a sublist of listVar2"
            </summary>
            <param name="solver">The solver</param>
            <param name="listVar1">The first list variable (the sublist)</param>
            <param name="listVar2">The second list variable (the superlist)</param>
            <returns>Term representing "listVar1 is a sublist of listVar2"</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.SublistEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32[])">
            <summary>
            Create a Term that represents "listVar1 is a subset of list2"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.SublistEq(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Int32[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "list1 is a sublist of listVar2"
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.Length(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term that represents "the length of listVar"
            </summary>
            <param name="solver">The solver</param>
            <param name="listVar">The list variable</param>
            <returns>Term representing the length of listVar</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ElementAt(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Return Boolean Term that says the element in listVar at position index equals the elementToBe
            </summary>
            <param name="solver">The solver</param>
            <param name="index">Index Term (must be a constant integer Term or have an integer interval from 0 to listVar's power-list domain's MaxLength - 1)</param>
            <param name="listVar">The list variable</param>
            <param name="elementToBe">The target Term</param>
            <returns>A Boolean Term that says the element in listVar at position index equals result</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.ElementCount(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Term whose value will be the number of times that element Term appears in listVar
            </summary>
            <param name="solver">The solver</param>
            <param name="element">the element to count</param>
            <param name="listVar">the list variable</param>
            <returns>A Term whose value will be the number of times that element appears in listVar</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.FirstOccurrence(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Boolean Term that says the index (0-based) of the first occurrence of element in listVar is the indexToBe
            </summary>
            <param name="solver">The solver</param>
            <param name="element">The element</param>
            <param name="listVar">The list variable</param>
            <param name="indexToBe">The target index</param>
            <returns>A Boolean Term that says the index (0-based) of the first occurrence of element in listVar is result</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.LastOccurrence(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a Boolean Term that says the index (0-based) of the last occurrence of element in listVar is the indexToBe
            </summary>
            <param name="solver">The solver</param>
            <param name="element">The element</param>
            <param name="listVar">The list variable</param>
            <param name="indexToBe">The target index</param>
            <returns>A Boolean Term that says the index (0-based) of the last occurrence of element in listVar is result</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspListOperators.Concatenation(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
            Create a CspPowerList Term that represents the concatenation of the two input list varaibles, with listVar1 proceeding listVar2
            </summary>
            <param name="solver">The solver</param>
            <param name="listVar1">The first list</param>
            <param name="listVar2">The second list</param>
            <returns>A CspPowerList Term that represents the concatenation</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolver.Search(System.Boolean)">
            <summary> Runs the algorithm; every time a solution is found the method
                      yield-returns and a solution can be accessed either value by
                      value or by batch using a snapshot
            </summary>
            <param name="yieldSuboptimals">true if intermdiate solutions 
                      found during the search should be returned, false
                      if we should only return provably optimal solutions</param>
            <returns> A sequence of ints, each of which indicates the solution number
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolver.GetValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> Gets the current value associated to a Term by this algorithm
            </summary>
            <param name="variable">A CspSolverTerm</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolver.SnapshotVariablesIntegerValues">
            <summary> Creates a representation of the current solution
                      where values are integers
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSolver.SnapshotVariablesValues">
            <summary> Creates a representation of the current solution
                      where values are objects
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics">
            <summary> Public abstract class that contains user defined heuristics
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.GetNextDecisionVariable">
            <summary> Decide the next decision variable. Will be called when we want to branch.
            </summary>
            <remarks> When this method is called, we guarantee that the current partial assignment is
                      consistent</remarks>
            <remarks> Query callback </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.UndoDecisionVariable(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> Undo the most recent decision variable selection. Will be called when we backtrack.
            </summary>
            <remarks> Query callback </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.TryNextValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> Decide the next value to try out given that chosenDecisionVariable is the branching 
                      variable. Will be called after branching variable is chosen.
            </summary>
            <remarks> Query callback </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.ConflictFound(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> Notify that a conflict has been found. Will be called when propagation finds a conflict.
            </summary>
            <remarks> Notification callback </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.Init(Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary> Initialization callback. Will be called before search phase starts 
            </summary> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.GenerateInitialAssignment">
            <summary> Generate an initial assignment </summary> 
            <remarks> Query callback</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.SelectMove">
            <summary> Select a move according to the current assignment </summary> 
            <remarks> Query callback </remarks> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.InitialAssignmentInPlace(System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,System.Object})">
            <summary> Notify user that we have set the initial assignment. 
                      This is the time for user to  initialize any data structure that
                      will be used during local search. </summary> 
            <remarks> Notification callback </remarks> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConstraintSolverHeuristics.ReportFlip(Microsoft.SolverFoundation.Solvers.CspTerm,System.Object,System.Object)">
            <summary> Notify user that we have made a flip </summary> 
            <remarks> Notification callback </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess">
            <summary>Exposes the methods and a properties of a Local Search
                     solver that are used by local search strategies
            </summary>
            <remarks>A Local Search solver is a stateful object which is
                     always in a certain configuration. This configuration is
                     essentially defined by the value currently associated to 
                     each term of a given problem. This can be queried through
                     this interface.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.GetCurrentIntegerValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Gets the current value of an integer term</summary>
            <param name="expr">A Term, which should belong to the Model 
                     of the LocalSearch solver
            </param> 
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.EvaluateFlip(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>Estimates the effect of changing a variable to a candidate value.
                     The flip is not effectively performed
            </summary>
            <param name="x">A variable of the problem</param>
            <param name="newValue">A new value, from the domain of the variable</param>
            <returns>A numerical indicator whose value is low if the flip is expected
                     to reduce the penalty or of a minimization goal. 
                     This value is 0 if the flip is not expected to change the quality,
                     strictly positive if the new configuration is expected to be worse,
                     strictly negative if the new configuration is expected to be better.
            </returns>
            <remarks>The comparison between configurations takes into account both the 
                     violation and all minimization goals. A configuration B is better
                     than a configuration A if either:
                     (1) A violates the constraints and B has a lower violation
                     (2) A and B satisfy the constraints and B gives a lower value to 
                     the minimization goal. If several minimization goals are defined their
                     priority is considered: B has a lower evaluation on one objective
                     and does not increase the value over any higher priority objective
                     
                     CODE REVIEW (lucasb): for consistency we probably want a more uniform
                     way of evaluating arbitrary *moves*
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.SubscribeToMove(Microsoft.SolverFoundation.Solvers.LocalSearch.MoveListener)">
            <summary>Subscribes a delegate that will be called by the local search
                     every time a move is attempted, even if the move was ultimately rejected
            </summary>
            <param name="listener">A listener for the Move event</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.SubscribeToRestarts(System.Action)">
            <summary>Subscribes a delegate that will be called by the local search
                     every time a restart takes place
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.SelectBestVariable">
            <summary>Gives a variable hint, i.e. a variable whose re-assignment is
                     likely to increase the overall quality. The variable is preferably
                     selected among those that are not filtered-out.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.Filter(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Excludes x from the set of variables that are likely to
                     be returned by the SelectBestVariable method
            </summary>
            <param name="x">A variable</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.Unfilter(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Cancels the effect of filtering x, i.e. allows x to 
                     be returned by the SelectBestVariable method
            </summary>
            <param name="x">A variable</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.IsFiltered(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>True iff the variable is likely to
                     be returned by the SelectBestVariable method
            </summary>
            <param name="x">A variable</param>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.CurrentViolation">
            <summary>Gets the constraint violation, an indication of how far
                     the current configuration is from satisfying the constraints
            </summary>
            <returns>Zero if all constraints of the Model are satisfied. Otherwise
                     a strictly positive value: the higher the value the
                     further we estimate to be from a satisfying configuration.
            </returns>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ILocalSearchProcess.Model">
            <summary>Gets the constraint system solved by this Local Search solver
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspUserVariable">
            <summary> A user variable that implements INotifyPropertiesChanged
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.Fix(System.Object)">
            <summary>
            Fix the value of this user var.
            </summary>
            <param name="val"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.Unfix">
            <summary>
            Unfix this user var.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.IsFinished">
            <summary>
            Test if domain narrowing is finished for this user var.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.IsSingleton">
            <summary>
            Test if the domain of feasible values of this user var is a singleton.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.IsFixing">
            <summary>
            Is the user variable just been fixed
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.EnableEvent">
            <summary>
            Enable the call to the PropertyChanged event handler on Update
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.GetFixedValue">
            <summary>
            Get the value to which this user var needs to be fixed
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.SetFinished">
            <summary>
            Set the flags that indicate we have finished domain narrowing for this user var.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.ClearFinished">
            <summary>
            Clear the flags that indicate we have finished domain narrowing for this user var.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.Update">
            <summary>
            Tell the user var that its feasible value list has been updated.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.DecideValue(System.Int32)">
            <summary>
            Add the input val to the feasible value list of this user var. If the val exists already,
            no duplicate will be added then.
            </summary>
            <param name="val">A feasible value</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.ClearFeasibleValues">
            <summary>
            Clear the feasible value list
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspUserVariable.SetWorkingDomain">
            <summary>
            Remove feasible values and infeasible values from the domain as they have been tested.
            </summary>
            <returns>The cardinality of the new working domain</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CspUserVariable.FeasibleValues">
            <summary>
            Return the current computed array of feasible values of this user var.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NativeFormatTokens">
            <summary>
            Internal tokens for serialization.  These are all the sytax tokens in the format.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SerializationStatus">
            <summary>
            Encapsulates error conditions occuring during serialization.  Success is indicated by the Status Code member being set to OK
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SerializationStatus.#ctor">
            <summary>
            default construction implies everything is OK.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SerializationStatus.#ctor(Microsoft.SolverFoundation.Solvers.SerializationStatus.Status,System.String,System.UInt32)">
            <summary>
            Used from the 'save' side of serialization.
            </summary>
            <param name="cd">enumeration of failure</param>
            <param name="errorMessage">unique string for failure</param>
            <param name="lineNo">line number for the failure.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SerializationStatus.#ctor(Microsoft.SolverFoundation.Solvers.SerializationStatus.Status,System.String,System.UInt32,System.String,System.String,Microsoft.SolverFoundation.Solvers.SerializationStatus)">
            <summary>
            Used from the parsing side of serialization
            </summary>
            <param name="cd">enumeration of the failure</param>
            <param name="errorMessage">uniuqe string for failure</param>
            <param name="lineNo">line number for the failure</param>
            <param name="_token">the parser token where the issue is noticed</param>
            <param name="fullText">the full line of text where the issue is noticed</param>
            <param name="prev">the previous Status in the stack from the parser.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SerializationStatus.Trace(System.IO.TextWriter)">
            <summary>
            Traces the source of an error the stream.  includes error code, token (if available), line number (or zero if not availble) , and line contents (if available)
            </summary>
            <param name="writer"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SerializationStatus.Source">
            <summary>
            Full text of line where a parsing error occurred on load
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SerializationStatus.Code">
            <summary>
            Error code which is an enumeration.  Indicates parsing and/or saving failures.  There is a distinct OK value which indicates success.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SerializationStatus.Message">
            <summary>
            Distinct text per source of failure.  
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SerializationStatus.Token">
            <summary>
            This is set to the unrecognized parse token when parsing.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SerializationStatus.SourceLine">
            <summary>
            This is set to the complete line of text when a failure occurs during parsing.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status">
            <summary>
            Indication of success/failure-code during ConstraintSystem serialization.  OK indicates that the operation was successful.  On error, see the message text for 
            further informaiton on the error.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.INTERNALERROR">
            <summary>
            Indicates an internal error in the parser -- unhandled conditions.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.WRITEFAILED">
            <summary>
            Indicates a failure when writing to the output stream on Save
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEMODEL">
            <summary>
            Indicates an error duringparsing of a model.  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEHEADER">
            <summary>
            Inidicates an error when parsing the header block.  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEUNARYTERM">
            <summary>
            Indicates an error when parsing a unary operator 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSETERMNAME">
            <summary>
            Indicates a failure when parsing a term name
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEDOMAIN">
            <summary>
            Indicates an error when parsing a domain
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSELINE">
            <summary>
            Indicates an error when parsing a line in the input stream.  
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSENUMBER">
            <summary>
            Indicates an error when parsing a number
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSESTRING">
            <summary>
            Indicates an error when parsing a string.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.NOSYMBOLSINSET">
            <summary>
            Indicates an error when parsing symbols in a symbol set
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.NOINTSINSET">
            <summary>
            Indicates a problem parsing the integers in an integer set
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEVARIABLE">
            <summary>
            Indicates an error when parsing a variable line
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEMULTITERM">
            <summary>
            Indicates an error when parsing multiple terms on one line.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSESYMBOL">
            <summary>
            Indicates an error when parsing a symbol refrence
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSECONSTRAINT">
            <summary>
            Indicates an error when parsing a constraint line
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEMOFN">
            <summary>
            Indicates an error when parsing an M of N term
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEPOWER">
            <summary>
            Indicates an error when parsing a Power term
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEINDEX">
            <summary>
            Indicates an error when parsing an index term
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSESYMBOLREF">
            <summary>
            Indicates an error when parsing a symbol reference
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.DUPLICATEVARNAME">
            <summary>
            Duplicate variable name detected.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.INVALIDNUMTERMSIMPLIES">
            <summary>
            Invalid number of terms in an "implies" operator.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSENONDECISIVE">
            <summary>
            Unable to parse non-decisive variable definition.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.NONDECISIVEPARSE">
            <summary>
            Error parsing non-decisive tokens.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.OK">
            <summary>
            Successful operation
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SerializationStatus.Status.UNABLETOPARSEISELEMENTOF">
            <summary>
            Failed when parsing IsElementOf term.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch">
            <summary>Contains a number of static utilities for advanced users
                     of the Local Search framework
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.RestartNever">
            <summary>Returns a simple restart strategy in which we never restart
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.RestartWhenThresholdHit(System.Double)">
            <summary>Returns a basic restart strategy in which try to detect when we 
                     are stuck for too long in a local minima because the percentage
                     of recent moves that improved the score is below a threshold
            </summary>
            <param name="threshold">A percentage that tunes how agressively we restart:
                    restart will happen when the percentage of improved moves becomes
                    lower than this threshold (higher values therefore mean more agressive)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.RestartWhenStuckForTooLong">
            <summary>Returns a basic restart strategy in which try to detect when we 
                     are stuck for too long in a local minimum because the number
                     of moves that did not improve the quality is larger than a limit
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.InitializeRandomly(System.Int32,System.Double)">
            <summary>Returns a simple initialization strategy in which all or some
                     of the variables are re-set to a value picked uniformly at
                     random from their domain
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            <param name="percentage">A value between 0 and 1 saying which percentage
                     of the variables are perturbated on a typical restart
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptIfImproved">
            <summary>Returns a classic acceptance strategy in which a configuration 
                     is accepted iff it does not degrade the quality
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptAlways">
            <summary>Returns an acceptance strategy in which moves are always
                     accepted
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptProbabilistically(System.Double,System.Int32)">
            <summary>Returns an acceptance strategy in which a configuration is always 
                     accepted if it improves the quality, and accepted with some
                     probability P when the quality is degraded
            </summary>
            <param name="probability">the probability of acceptance</param>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptWithSimulatedAnnealing(System.Int32)">
            <summary>Returns a probabilistic acceptance strategy in which the probability
                     of acceptance evolves with time according to a temperature factor
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveRandomly(System.Int32)">
            <summary>Returns a move strategy that flips variables at random
            </summary>
            <remarks>The selection of the value taken for the variable is not
                     complitely random but biased towards a good quality, so that
                     the search is not completely blind
            </remarks>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveByConstraintGuidedFlips(System.Int32)">
            <summary>Returns a move strategy where the moves are random flips  
                     that are computed in a constraint-driven way
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveByGradientGuidedFlips(System.Int32)">
            <summary>Returns a move strategy where the moves are random flips  
                     that are computed in a gradient-driven way
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveByGreedyImprovements(System.Int32)">
            <summary>Returns a move strategy in which the moves are as follows:
                     If the constraints are violated then a constraint-guided move
                     is selected aiming at repairing them;
                     If the constraints are satisfied then a sample of moves is
                     considered and the most promising is selected
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveUsingTabu(System.Int32,System.Int32)">
            <summary>A move strategy that uses a Tabu list, i.e. has a short-term
                     memory of forbidden moves. At every step the strategy tries
                     to find a good move that is not marked Tabu
            </summary>
            <param name="randomSeed">A seed for the Random generator used in this 
                     strategy. Set to fixed value by default
            </param>
            <param name="tabuListLength">Number of iterations for which a variable
                     flip remains Tabu. Set by default according to a slowly 
                     increasing function of the number of variables
            </param>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearch._defaultRandomSeedInitializer">
            <summary>An arbitrary, but fixed, number to initialize random sequences
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.CreateVariableFlip(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>Creates a Move whose effect is to flip a certain
                     variable to a certain value
            </summary>
            <param name="target">The term that is being flipped. 
                     This term must be a used-defined variable
            </param>
            <param name="value">The new value for the term. 
                     This value must belong to the initial domain of the variable
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.CreateVariableSwap(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Creates a Move whose effect is to swap the
                     values of two variables
            </summary>
            <param name="var1">A term, which must be a user-defined variable</param>
            <param name="var2">A term, which must be a user-defined variable</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.CreateStop">
            <summary>Returns a null move, meaning that no suggestion of improvement
                     can be found in the current configuration.
                     This effectively tells the local search algorithm to restart
                     if no other strategy applies next
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.ScaleDownLogarithmically(System.Int32)">
            <summary>A function that increases very slowly
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearch.ScaleDownUsingRoot(System.Int32)">
            <summary>For small values the function returns the value unchanged,
                     when the number gets higher the function grows fairly slowly
            </summary>
            <remarks>Use when an iteration needs to take into account a range
                     but should not grow unreasonably large if the range is large.
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.RestartStrategy">
            <summary>Delegate type for a restart strategy, called at every
                     iteration of a local search loop
            </summary>
            <param name="solver">The local search solver that is calling this
                     delegate to ask for advice
            </param>
            <remarks>Unless it is stateless, the delegate should not be associated
                     to several ILocalSearchSolver objects
            </remarks>
            <returns>True when a restart is advised. This will in general mean that
                     we have detected that the local search is stuck in a local
                     minimum and should try to escape from it
            </returns>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.InitializationStrategy">
            <summary>Delegate type for an initialization strategy, called every 
                     time a local search solver (re)-starts to a new point
            </summary>
            <param name="solver">The local search solver that is calling this
                     delegate to ask for advice
            </param>
            <remarks>Unless it is stateless, the delegate should not be associated
                     to several ILocalSearchSolver objects
            </remarks>
            <returns>A Dictionary describing the next new starting point. 
                     Defines a new value for some (not necessarily all) of the
                     variables of the problem
            </returns>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveStrategy">
            <summary>Delegate type for a move strategy, called at every iteration
                     of a local search loop to indicate which change should be done
            </summary>
            <param name="solver">The local search solver that is calling this
                     delegate to ask for advice
            </param>
            <remarks>Unless it is stateless, the delegate should not be associated
                     to several ILocalSearchSolver objects
            </remarks>
            <returns>A Move indicating which change the local search algorithm 
                     should perform
            </returns>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptanceStrategy">
            <summary>Delegate type for a move strategy, called every time a move
                     is performed, to decide whether the new configuration should
                     be accepted
            </summary>
            <param name="solver">The local search solver that is calling this
                     delegate to ask for advice
            </param>
            <param name="move">move that has just been performed</param>
            <param name="moveCost">estimate of the cost of undoing the move</param>
            <param name="qualityChange">A numerical indicator of whether how the
                     penalty of the configuration has changed.
                     The lower the value, the better the move:
                     0 if it was unchanged;
                     a strictly negative value if the penalty decreased;
                     a strictly positive valie of the penalty increased.
            </param>
            <remarks>Unless it is stateless, the delegate should not be associated
                     to several ILocalSearchSolver objects
            </remarks>
            <returns>True iff the move should be accepted
                     otherwise it will be undone
            </returns>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveListener">
            <summary>Delegate that can be subscribed to a local search algorithm
                     and that is then called every time the algorithm attempts
                     a move
            </summary>
            <remarks>Even the failed attempts of move cause a call-back</remarks>
            <param name="move">change that was just attempted</param>
            <param name="improvedQuality">true if the move improved the quality</param>
            <param name="accepted">true if the move was effectively accepted</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.Move">
            <summary>A move, indicating a state that can be performed by a
                     local search solver
            </summary>
            <remarks>The only legal way to construct Moves is through the
                     factory methods of the LocalSearch class
            </remarks>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.Type">
            <summary>The type of move</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.Value">
            <summary>Optional value of the move</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.Var1">
            <summary>Primary variable affected by the move;
                     Null only if the move does not affect anything
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.Var2">
            <summary>Optional variable affected by the move;
                     Non-null only if the move is a variable swap
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.FirstVariable">
            <summary>Primary variable affected by the move;
                     Precondition: the move should affect at least one variable
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearch.Move.SecondVariable">
            <summary>Secondary variable affected by the move;
                     Precondition: the move should affect 2 variables
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearch.MoveType">
            <summary>Possible types of moves </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ValueWithGradients">
            <summary>
            A value that has both increasing and decreasing gradients, 
            i.e. we have an (over-)estimate of how much the value
            can be decreased/increased, together with hints w.r.t. which
            variables should be modified to obtain this variation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueWithGradients.#ctor(System.Int32,System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            A value that has both increasing and decreasing gradients
            </summary>
            
            <param name="val">
            Current value
            </param>
            <param name="dec">
            Decreasing gradient (always negative or zero):
            by how much may the value decrease? 
            </param>
            <param name="decvar">
            Hint attached to the decreasing gradient:
            which variable should we re-assign to decrease the value?
            (may be null only iff the decreasing gradient is 0)
            </param>
            <param name="inc">
            Increasing gradient (always positive or zero):
            by how much can the value increase?
            </param>
            <param name="incvar">
            Hint attached to the increasing gradient:
            which variable should we re-assign to icrease the value?
            (may be null only if the increasing gradient is 0)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueWithGradients.#ctor(System.Int32)">
            <summary>
            A value which cannot be increased or decreased: 
            both gradients are null
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueWithGradients.op_Implicit(System.Int32)~Microsoft.SolverFoundation.Solvers.ValueWithGradients">
            <summary>
            Implicit conversion of constants: a constant is a 
            value that cannot be increased or decreased (gradients are 0)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueWithGradients.Expand(Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32)">
            <summary>
            Modify the gradient by informing that: 
            re-assigning hint variable we may reach the value newval
            </summary>
            <remarks>
            Some gradients are more easily computed when we initialize
            to null gradients and do a number of expansions. 
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueWithGradients.ExpandNegative(Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32)">
            <summary>
            Modifify the gradient by informing that:
            re-assigning the hint variable may reach the value newval 
            where newval is guaranteed to be LessEqual to current value
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ValueWithGradients.Value">
            <summary>
            Current value 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ValueWithGradients.DecGradient">
            <summary>
            Decreasing gradient (always negative or zero):
            by how much may the value decrease? 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ValueWithGradients.IncGradient">
            <summary>
            Increasing gradient (always positive or zero):
            bu how much can the value increase?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ValueWithGradients.DecVariable">
            <summary>
            Hint attached to the decreasing gradient:
            which variable should we re-assign to decrease the value?
            (may be null e.g. for constant terms)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.ValueWithGradients.IncVariable">
            <summary>
            Hint attached to the increasing gradient:
            which variable should we re-assign to icrease the value?
            (may be null if increasing gradient is 0)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Gradients">
            <summary>
            Static utilities on gradients
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Minus(Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            computes the gradient of -x
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Sum(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            computes the gradient of x+y
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Min(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of min (x, y)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Max(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of max (x, y)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Product(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of x * y
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Power(Microsoft.SolverFoundation.Solvers.ValueWithGradients,System.Int32)">
            <summary>
            Computes the value of x ^ exponent together with its gradients
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Abs(Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the value of Abs(x) together with its gradients
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Not(Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            computes the gradient of not x
            where x is a (non-zero) violation score
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.And(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of x and y
            where x and y are both (non-zero) violation scores
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Or(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of x or y
            where x and y are both (non-zero) violation scores
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Implies(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of x implies y
            where x and y are both (non-zero) violation scores
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Equivalent(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the gradient of x iff y
            where x and y are both (non-zero) violation scores
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.LessEqual(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the violation of x lessEqual to y
            together with its gradient info
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.LessStrict(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the violation of x lessStrict to y
            together with its gradient info
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Unequal(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the violation of x != y
            together with its gradient info
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Equal(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Computes the violation of x = y
            together with its gradient info
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Gradients.Evaluate(Microsoft.SolverFoundation.Solvers.ValueWithGradients,Microsoft.SolverFoundation.Solvers.ValueWithGradients,System.Func{System.Int32,System.Int32,System.Int32})">
             <summary>
             Given a binary function and two points with gradients,
             computes the result and its gradients. 
             <remarks>
             The function has to be monotonic in the sense that 
             evaluating the inputs with maximal gradients should
             suffice to evaluate the gradients (i.e. extremal
             points should not be in the middle of a variable's range).
            </remarks>
             </summary>
             <param name="x">A point with its gradients</param>
             <param name="y">A point with its gradients</param>
             <param name="f">A monotone function</param>
             
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_Strategy">
            <summary>A class from which some local search strategies may derive 
                     (this is by no means the only allowed pattern)
                     to benefit from a few utilities which help dealing with state
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.Initialize(Microsoft.SolverFoundation.Solvers.ILocalSearchProcess)">
            <summary>Initialization of the strategy's state
                     (does nothing by default)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.CheckSolver(Microsoft.SolverFoundation.Solvers.ILocalSearchProcess)">
            <summary>Call this method every time a parameter of type
                     ILocalSearchSolver is received
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.Sample(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Func{System.Int32,System.Int32})">
            <summary>Samples a number of values (in external format)
                     from the domain of a Term. The samples are non-redundant;
                     their number is dependent on the domain size
            </summary>
            <param name="scaling">A function that determines the sample size as
                     a function of the cardinality of the domain. The function 
                     should be monotonic (increasing) but should never give
                     unreasonably large values if the cardinality if large
            </param>
            <param name="t">The term whose domain is sampled</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.LargeSample(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>Samples a number of values (in external format)
                     from the domain of a Term. The samples are non-redundant.
                     Up to a certain size the sample set will cover all values.
                     For large domains we make sure that the size of the sample
                     set grows slowly
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.SmallSample(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>Samples a number of values (in external format)
                     from the domain of a Term. The samples are non-redundant.
                     The sample set contains a small (logarithmic) number of values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_Strategy.RandomFlip">
            <summary> Returns a random flip;
                      use occasionally for default moves or perturbations
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LS_Strategy.Solver">
            <summary>The solver, cast into its concrete type</summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LS_Strategy.Model">
            <summary>The model (cached)</summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_ThresholdEscapeStrategy">
            <summary>A restart strategy in which we restart when the 
                     percentage of recent moves that lead to improvements is
                     below a certain threshold
            </summary>
            <remarks>In this version we keep a record of the N last attempted moves,
                     where N is the number of variables. Information on these moves
                     is simply kept in a queue of bounded size. From this we can
                     determine the percentage of successful moves over the time window.
                     We simply restart if this percentage is less than a threshold.
                     Note that this strategy will never restart until the queue has
                     reached the correct size. This makes sure that even if we restart
                     requently we leave some time to each restart
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_SimpleMinimaEscapeStrategy">
            <summary>A restart strategy in which we restart when the
                     number of moves without improvement hits a limit
            </summary>
            <remarks>
            Difficult tuning of the limit, we want to escape from minima
            after a while but we want to leave enough time
            for the exploration to have a chance to improve quality.
            Tuned as function of number of variables
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_RandomInitializationStrategy">
            <summary>A simple initialization strategy in which all or some
                     of the variables are re-set to a value picked uniformly at
                     random from their domain
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_SimulatedAnnealingAcceptanceStrategy">
            <summary>A local search acceptance strategy in which the probability
                     to accept non-improving moves varies with time using a
                     "temperature" (metropolis) policy
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_ConstraintGuidedMoveStrategy">
            <summary>A Local Search Move Strategy in which we select the best
                     move in a constraint-driven way
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_ConstraintGuidedMoveStrategy.NextMove(Microsoft.SolverFoundation.Solvers.ILocalSearchProcess)">
            <summary>Computes the next move considered by the local search solver
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_GradientGuidedMoveStrategy">
            <summary>A Local Search Move Strategy in which we select the best
                     move in a gradient-driven way
            </summary>
            <remarks> RENAME AS TABU????????????
                      e.g. if old Tabu deprecated
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_GreedyImprovementStrategy">
            <summary>A Local Search Move Strategy in which we scan all variables 
                     greedily in a round-robin fashion and try a small number of 
                     values for each considered variable. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_GreedyImprovementStrategy.NextMove(Microsoft.SolverFoundation.Solvers.ILocalSearchProcess)">
            <summary>Computes the next move considered by the local search solver
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy">
            <summary> A move strategy that uses a Tabu list, i.e. has a short-term
                      memory of forbidden moves. At every step the strategy tries
                      to find a good move that is not marked Tabu
            </summary>
            <remarks> Here the Tabu list contains variables
                      that cannot be flipped. The algorithm tries to find a variable 
                      flip that improves the quality and is not Tabu. 
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy.NextMove(Microsoft.SolverFoundation.Solvers.ILocalSearchProcess)">
            <summary>Computes the next move considered by the local search solver
            </summary>
            <remarks>The move selection is doing a exhaustive search through
                     the variables and skips the ones that are Tabu; it samples
                     a number of values for each of them and keeps the best move.
                     The algorithm is essentially naive but we use the following
                     refinements to avoid a too costly loop:
                     (1) the search is interrupted as soon as we have found a
                         non-Tabu variable which stricltly improves the penalty function
                     (2) the enumeration is in order starting from a initial position.
                         By default this initial position is random but when we can
                         we try to find a slightly better-informed choice, which is
                         likely to directly find a satisfying move
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy.MarkTabu(Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary> Mark the variable as Tabu - it should be be flipped
                      for _tabuLength steps
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy.IsTabu(Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary> True if the variable is currently Tabu, i.e. 
                      it is currently forbidden to flip it
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy._tabuList">
            <summary> The tabu list. For each variable (indexed by their ordinals)
                      we keep the time step up to which it remains Tabu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy._tabuLength">
            <summary> Length (conceptually) of the Tabu queue; i.e. number of time
                      steps a value remains Tabu
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LS_TabuMoveStrategy._currentTimeStep">
            <summary> Counter of number of moves performed
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LS_NoiseStrategy">
            <summary>A strategy that takes a move and acceptance strategy 
                     and makes then noisy
            </summary>
            <remarks>The call-backs are dispatched to the move and acceptance 
                     strategies unless noise is made (with some probability),
                     in which case a random flip is done and we keep state in
                     order to accept this move
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AggregateQuality">
            <summary> The quality associated to a solution. 
                      This quality is the aggregation of a number of 
                      numerical values, ordered by decreasing importance.
            </summary>
            <remarks> First value: 1 if the evaluation of the solution cannot
                      even be evaluated correctly (e.g. overflow); 0 otherwise.
                      Second value: 0 if the solution satisfies the hard 
                      constraints; a positive value otherwise.
                      Other values: the value of the minimization goals, 
                      ordered by decreasing importance.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary> Construction of an initial quality dimensioned for the
                      solver. By default the quality is set to the worst
                      (highest possible) value.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.Reset">
            <summary> Sets a quality to the worst (highest) possible value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.CopyFrom(Microsoft.SolverFoundation.Solvers.AggregateQuality)">
            <summary> Sets this to another aggregate quality 
                      of the same dimension
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.Difference(Microsoft.SolverFoundation.Solvers.AggregateQuality)">
            <summary> Difference with another quality: returns 0 if the two qualities 
                      are equal, otherwise finds the first objective where there is
                      a difference and returns this difference
            </summary>
            <remarks> Can serve as a CompareTo function:
                      Negative if this is lexicographically lower than other; 
                      Zero if this is equal to lower; 
                      Positive otherwise (i.e. other is lower).
                      If the change is in the numerical overflow flag we return
                      a huge positive or negative value rather than -1 or +1, to indicate
                      that the difference is major
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.LessStrict(Microsoft.SolverFoundation.Solvers.AggregateQuality)">
            <summary> Is this quality strictly lower (meaning better)
                      than the other one?
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AggregateQuality.LessEqual(Microsoft.SolverFoundation.Solvers.AggregateQuality)">
            <summary> Is this quality lower (meaning better) than 
                      or equal to the other one?
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AggregateQuality._values">
            <summary> Quality criteria, aggregated by decreasing order
                      of importance
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.AggregateQuality.Overflow">
            <summary> Get/set a flag that is true for a solution whose
                      quality cannot be correctly evaluated because it
                      causes a numerical overflow. 
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.AggregateQuality.Violation">
            <summary> Get/set the violation of the solution, i.e. a
                      penalty term that is 0 if the hard constraints
                      are satisfied, and positive otherwise
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.AggregateQuality.Item(System.Int32)">
            <summary> Get/set the value of the minimization goal 
                      of the given index
            </summary>
            <param name="idx">The index of a minimization goal</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchSolver">
            <summary> Root class for local search algorithms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem)">
            <summary>A generic local search solver for finite CSPs
            </summary>
            <param name="model">The model containing all information
                     on the instance to be solved 
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove)">
            <summary>A generic local search solver for finite CSPs
            </summary>
            <param name="model">The model containing all information
                     on the instance to be solved 
            </param>
            <param name="strategy">A parameter (optional) specifying
                      one of the pre-defined combinations of strategies
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,Microsoft.SolverFoundation.Solvers.LocalSearch.RestartStrategy,Microsoft.SolverFoundation.Solvers.LocalSearch.InitializationStrategy,Microsoft.SolverFoundation.Solvers.LocalSearch.MoveStrategy,Microsoft.SolverFoundation.Solvers.LocalSearch.AcceptanceStrategy)">
            <summary>Construction of a local search algorithm,
                     customized by a number of call-backs
            </summary>
            <param name="model">The model containing all information
                     on the instance to be solved 
            </param>
            <param name="restart">Delegate specifying the restart strategy:
                     returns true iff a restart is needed
            </param>
            <param name="reset">Delegate specifying the initialization strategy:
                     returns a value for each variable that needs to be reset
            </param>
            <param name="move">Delegate specifying the move strategy:
                     returns the next move that the local search should perform
            </param>
            <param name="accept">Delegate specifying the acceptance strategy:
                     returns true if a move should be accepted
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.InitializeInternals">
            <summary>Allocate all fields from the Model
                     (called during construction)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.InitializeCallbacks(Microsoft.SolverFoundation.Solvers.ConstraintSolverParams.LocalSearchMove)">
            <summary>Create the callbacks from a pre-selected choice
                     (called during construction)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.InitializeValuesAndGradients">
            <summary> Recomputes the values of all Terms
                      in a naive, non-incremental way;
                      if gradients are used they will be recomputed too
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Recompute(System.Boolean,System.Boolean)">
            <summary> Recomputes the value of all differentiable expressions
                      in an incremental way by propagating changes
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RecomputeModifiedTerms(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32}})">
            <summary>
            Recompute (non-incrementally) the values and gradients of
            all terms in the given list. 
            This method is the inner loop of Initialization method
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.DispatchModifiedTerms(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32}},System.Boolean,System.Boolean)">
            <summary>
            Dispatches the change of a number of terms so that the dependents 
            of this term update their value and gradients incrementally.
            This method is the inner loop of Recompute
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.UpdatePostponedVariables(System.Boolean)">
            <summary>
            Solves the potential issues due to the fact that 
            gradients are not systematically re-evaluated: 
            when we skip a gradient recomputation but do recompute
            the values we have to save the modified variables in order to 
            make sure to consider them during the next gradient evaluation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RecomputeValues">
            <summary> Recomputes the values only (not the gradients)
                      of all CspSolverTerms
                      in an incremental way by propagating changes
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RecomputeGradients">
            <summary> Recomputes the gradients only (not the values) 
                      of all CspSolverTerms 
                      The update is incremental by propagating changes
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.PropagateChangeInViolation(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,System.Int32)">
            <summary> Method called when the violation of a constraint
                      changes, for update of the global violation
            </summary>
            <param name="constraint">a constraint whose violation changed</param>
            <param name="oldValue">old violation of the constraint</param>
            <param name="newValue">new violation of the constraint</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RecomputeCurrentQuality(System.Boolean)">
            <summary> Recomputes the quality of the current solution
            </summary>
            <param name="incremental">True iff the violation should
                      be recomputed incrementally, rather than 
                      recomputed from scratch
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.UpdateViolatedConstraintSet(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Adds or removes the term from the set of violated constraints
            depending on its updated value
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetIntegerValue(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Gets the current value of the Term, as an integer
                      (i.e. in external representation)
            </summary>
            <remarks> A Boolean is represented as 0/1
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetExtraData(Microsoft.SolverFoundation.Solvers.BooleanAnd)">
            <summary> Gets the type-specific data attached to the term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SetExtraData(Microsoft.SolverFoundation.Solvers.BooleanAnd,System.Int32)">
            <summary> Sets the type-specific data attached to the term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Get the current value of the term together with
            its gradient information
            </summary>
            <remarks>
            if the term is Boolean the value and gradients are in 
            terms of its violation
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetIntegerGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Get the integer value of the term together with its
            gradient information
            </summary>
            <remarks>
            We have to check if the term is Boolean since a Boolean
            term can be involved in, say, a sum.
            For instance if a term is Boolean and has violation -10
            its current value is 1 (term is true);
            Now if the increasing gradient is +12 that means that we
            can decrease the integer value by to 0 (decreasing gradient of -1)
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SetGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            Sets the gradient information attached to a term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SetGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm,Microsoft.SolverFoundation.Solvers.ValueWithGradients)">
            <summary>
            Sets the gradient information attached to a term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CancelGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Sets both gradients to 0
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.IsFiltered(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            A term is frozen if its gradients are fixed to 0, meaning
            that we (often temporarily) do not wish to modify its value
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.HasOneNullGradients(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Has the term got at least one its gradients that is currently zero?
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.MarkAsModified(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>
            Add term to queue of modified terms unless it's already there
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SignalOverflow(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Signals that an inconsistency has been reached;
                      this adds a large penalty to the current evaluation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Filter(Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            Temporarily freeze the variable (gradients become 0)
            meaning that we (temporarily) do not wish to modify its value.
            variable must NOT already be filtered
            </summary>
            <remarks>
            This prevents the variable from being taken as a hint for
            gradients of other terms. Can be seen as a form of "tabu-ing"
            We have to recompute the value and gradients: otherwise we
            might simply RecomputeValue and loose the fact that 
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Unfilter(Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            When a variable has been filtered out this cancels the
            effects of filtering and recomputes its gradient.
            Variable must currently be filtered
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Swap(Microsoft.SolverFoundation.Solvers.CspVariable,Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary> Flips x to the value of y and vice-versa
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Flip(Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32)">
            <summary> Change the current state by flipping a variable to a new value
            </summary>
            <param name="x">The variable to flip</param>
            <param name="newValue">A new value in internal format</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CheckTerm(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary>Makes sure a downcasted Term is correct</summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.ConvertToInternal(System.Collections.Generic.KeyValuePair{Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32})">
            <summary>Takes a non-trusted flip in external format, checks 
                     it and converts to the internal format
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.ConvertToInternal(Microsoft.SolverFoundation.Solvers.LocalSearch.Move)">
            <summary> Takes a non trusted move where the value (if any) is
                      in external format. Checks it and converts to internal format
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.ToInternalRepresentation(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> Changes an external representation to an internal one
            </summary>
            <remarks> If the variable is Boolean its 0/1 value will be
                      converted to a non-zero violation
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.ToExternalRepresentation(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> Changes an internal representation into an external one
            </summary>
            <remarks> If the variable is Boolean its non-zero violation value
                      is converted into a 0/1 integer value
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.ViolationToZeroOne(System.Int32)">
            <summary> Given a non-zero violation as represented internally, 
                      returns its 0/1 integer value (0 if violated, 1 if satisfied)
            </summary>
            <param name="violation">A non-zero violation indicator 
                      (the higher the more violated)
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CheckInternal(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> Checks that the given value for the given term is in 
                      internal format, i.e. Booleans represented as violations
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CheckExternal(Microsoft.SolverFoundation.Solvers.CspSolverTerm,System.Int32)">
            <summary> Checks that the given value for the given term is in 
                      external format, i.e. Booleans represented as 0/1
            </summary>
                      
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary> Gets the current value associated to a Term by this algorithm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SnapshotVariablesIntegerValues">
            <summary> Creates a representation of the current solution 
                      where values are integers
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SnapshotVariablesValues">
            <summary> Creates a representation of the current solution 
                      where values are objects
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Search(System.Boolean)">
            <summary> Runs the algorithm; every time a solution is found
                      the method yield-returns and a solution can be accessed
                      either value by value or by batch using a snapshot 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Perform(Microsoft.SolverFoundation.Solvers.LocalSearch.Move)">
            <summary> Changes the current configuration of this
                      Local Search as specified by the Move
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Undo(Microsoft.SolverFoundation.Solvers.LocalSearch.Move,System.Int32)">
            <summary> Undoes the effect of a rejected move
            </summary>
            <remarks> If the move was a restart its effects are not undone
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SetNewStartingPoint">
            <summary>Reinitialize the coniguration of the local search
                     Use for initialization and diversification (restart)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetAcceptance(Microsoft.SolverFoundation.Solvers.LocalSearch.Move,System.Int32,System.Int32)">
            <summary>Determines whether the move is accepted, using a call-back
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetMove">
            <summary>Determines the next candidate move, using a call-back
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetRestartDecision">
            <summary>Determines whether we restart, using a call-back
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.TakeControlBackFromCaller">
            <summary>Makes the checks that are required when 
                     a call-back returns
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GetCurrentIntegerValue(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Gets the current value of an integer term</summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.EvaluateFlip(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>Estimates the effect of changing a variable to a candidate value.
                     The flip is not effectively performed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SubscribeToMove(Microsoft.SolverFoundation.Solvers.LocalSearch.MoveListener)">
            <summary>Subscribes a delegate that will be called by the algorithm
                     every time a move is attempted, even if the move was ultimately rejected
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SubscribeToRestarts(System.Action)">
            <summary>Subscribes a delegate that will be called by the local search
                     every time a restart takes place
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.PickVariable(System.Random)">
            <summary>Picks at random a term that may be flipped</summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SelectBestVariable">
            <summary>Gives a variable hint, i.e. a variable whose re-assignment is
                     likely to increase the overall quality. The variable is preferably
                     selected among those that are not filtered-out.
            </summary>
            <remarks>gradient-guided</remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SelectBestViolationDecrease">
            <summary>
            Selects a variable that is expected to allow a
            maximal decrease of the violation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.SelectBestObjectiveDecrease">
            <summary>
            Selects a variable that is likely to decrease the
            value of an objective
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Filter(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Excludes x from the set of variables that are likely to
                     be returned by the SelectBestVariable method
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Unfilter(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>Cancels the effect of filtering x, i.e. allows x to 
                     be returned by the SelectBestVariable method
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.IsFiltered(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>True iff the variable is likely to
                     be returned by the SelectBestVariable method
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.PickViolatedVariable(System.Random)">
            <summary>Selects a variable whose value is conflicting with 
                     one of the constraints, and suggest a value for it that
                     is heuristically likely to reduce the violation
            </summary>
            <remarks>
            Should be deprecated?
            Somehow redundant with SelectMaxViolationDecrease but provides
            alternative top-down method instead of the bottom-up gradient-based
            approach
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.FindViolatedConstraint">
            <summary>
            Picks a random violated constraint 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RecoverFromOverflow(System.Random)">
            <summary> Method used to recover from an overflow
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._modifiedTerms">
            <summary> Modified terms that need to be considered in re-evaluation; 
                      Each is paired with its Value before modification. 
                      The terms are ranked by depth in order to allow efficient, 
                      sound re-evaluation.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._values">
            <summary> Values currently associated to all terms </summary> 
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._isEnqueued">
            <summary> For each term we keep a flag saying whether it's enqueued
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._gradientInfo">
            <summary> Gradient Info associated to all terms</summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._postponedVariables">
            <summary> 
            Variables that need to be considered by the 
            next gradient recomputation 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._filtered">
            <summary>
            We keep track of variables that are filtered, i.e. 
            their gradients are temporarily fixed to 0, meaning
            that we (often temporarily) do not wish to modify its value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._bestQuality">
            <summary> quality of the best solution found by the local search so far
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._currentQuality">
            <summary> quality of the current solution
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._oldQuality">
            <summary>A quality that can be used in terminal calls to keep track of
                     the quality before a move
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._prng">
            <summary> Pseudo-random number generator used in this algorithm
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._step">
            <summary> A counter that is increased every time we do a recomputation
            </summary>
            <remarks> Int64 may look like an overkill but we want to be on the safe
                      side even for a local search which would be run for weeks,
                      in which case 2 billion moves might sometimes be conceivable
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._useGradients">
            <summary> True if the data-structures for gradients is
                      allocated and gradients should be recomputed
            </summary>
            <remarks> gradients multiply the memory allocated by each
                      local search thread by some factor; so in principle it
                      may make sense to disable them if the heuritic tuning
                      that is being used does not require them
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._numTermRecomputations">
            <summary> Number of unit changes done in this algorithm;
                      this counts the iterations of the inner recomputation loop
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._restartAdvisor">
            <summary>Delegate specifying the restart strategy:
                     returns true iff a restart is needed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._initializationAdvisor">
            <summary>Delegate specifying the initialization strategy:
                     returns true iff a restart is needed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._moveAdvisor">
            <summary>Delegate specifying the move strategy:
                     returns the next move that the local search should perform
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._acceptanceAdvisor">
            <summary>Delegate specifying the acceptance strategy:
                     returns true if a move should be accepted
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._overflowCause">
            <summary> When an overflow is raised this keeps the place where it happened
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._violatedConstraints">
            <summary>
            Set of (the Ordinals of the) violated constraints, maintained incrementally; 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Item(Microsoft.SolverFoundation.Solvers.CspSolverTerm)">
            <summary> Gets / sets the value currently associated to the 
                      term by the local search algorithm
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.RandomSource">
            <summary> Get the pseudo-random number generator of the solver
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CurrentQuality">
            <summary> Quality of the point currently considered by the algorithm
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.BestQuality">
            <summary> Quality of the best solution explored so far by this algorithm
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Satisfying">
            <summary> True iff the current state satisfies all hard constraints
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.End">
            <summary> True if the local search should terminate
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Overflow">
            <summary> True if a numerical error happened during the last
                      recomputation. 
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.NumberOfRecomputations">
            <summary> Gets the number of recomputations performed by this algorithm;
                      for statistics
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.UseGradients">
            <summary>
            Checks / specifies whether the data-structures
            for gradient should be allocated and gradients be computed
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.CurrentViolation">
            <summary>Gets the constraint violation, an indicator of how well
                     the current configuration violates or satisfies the constraints
            </summary>
            <remarks>In case of the overflow flag is raised we systematically
                     return the highest possible violation
            </remarks>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.Model">
            <summary>Gets the constraint system solved by this Local Search solver
            </summary>
            
        </member>
        <member name="E:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._moveAttempted">
            <summary>Event raised when a move has been attempted
            </summary>
        </member>
        <member name="E:Microsoft.SolverFoundation.Solvers.LocalSearchSolver._restartOccurred">
            <summary>Event raised when a restart has occurred
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GradientInfo">
            <summary>
            Gradient Information attached to a Term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchSolver.GradientInfo.Load(System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable,System.Int32,Microsoft.SolverFoundation.Solvers.CspVariable)">
            <summary>
            Assigns all the fields of the gradient info
            </summary>
            <returns>
            True iff a change occurred
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveLocalPropagation.Propagate(Microsoft.SolverFoundation.Solvers.CspSolverTerm@)">
            <summary> Advance through the Restriction List, propagating the consequences
                      of each Restriction, until all the List has been processed.  Note
                      that the List grows during this because new Restrictions caused
                      by propagation are added to the end of the List, so reaching the
                      end of the list is synonymous with propagating all consequences.
            </summary>
            <returns> true if no conflict, false and sets the conflict Term.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchSolver.NextDecisionVariable">
            <summary> Choose the next undecided Decision Variable
            </summary>
            <returns> false if no decision variables remain to be tried </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchSolver.TryNextValue">
            <summary> With the current decision variable, narrow its value set
            </summary>
            <returns> False when all values of this variable have been exhausted </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.NextDecisionVariable">
            <summary> Choose the next undecided Decision Variable
            </summary>
            <returns> false if no decision variables remain to be tried </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.OptimizeDecisionOrder">
            <summary> Choose the best next variable.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.ScanA">
            <summary> Scan for maximizing Credit * card
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.TryNextValue">
            <summary> With the current decision variable, narrow its value set
            </summary>
            <returns> False when all values of this variable have been exhausted </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.Restart">
            <summary> Go back to find the most recent decision we are allowed to change.
                        Remove all decisions made since then.
                        Alter the order of our strategy for future.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AdaptiveConflictSeeking.LearnClauses">
            <summary> Learning clauses here is not the same as the classic technique.
                        Instead of pushing backwards from the contradiction to find
                        the causes, we go directly to the root - the current guesses.
                        The guess sequence is analyzed to yield not just the current
                        failure but also all those we enumerated to get to here, and
                        then it is simplified by the factoring technique described
                        below.  We only need to call for this on a restart, not on
                        every backtrack.  The result is compact and complete, so it
                        has the guaranteed property that we will cut short any future
                        exploration of the same subtrees of the solution (so we
                        converge, an important consideration when using restarts).
            </summary>
            <returns> true if we learned, false if we discovered we were at the end.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DomainNarrowingWithACS.AbortDomainNarrowing">
            <summary>
            Tell the decision algorithm to stop running.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DomainNarrowingWithACS.TryFixUserVariable(Microsoft.SolverFoundation.Solvers.CspUserVariable)">
            <summary>
            Set flags to fix/unfix the user var to a value
            </summary>
            <param name="var"></param>
            <returns>true iff the user var needs to be fixed to a new value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DomainNarrowingWithACS.IsFixChangedUserVar">
            <summary>
            Check if user has fixed/freed variables from outside.
            </summary>
            <returns>true iff there is need to fix new user vars</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DomainNarrowingWithACS.SearchForValidValues">
            <summary>
            Start the loop of narrowing domains of user variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.NextDecisionVariable">
            <summary> Choose the next undecided Decision Variable
            </summary>
            <returns> false if no decision variables remain to be tried </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.DecideNextDecisionVar">
            <summary> Decide the next decision variable for branching
            </summary>
            <returns>true iff we have found a decision var for branching</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.NextDecisionVariableCore">
            <summary> Wrapper of DecisionNextDecisionVar that uses return values to indicate different scenarios
            </summary>
            <returns>true: found the next decision var; false: found optimal solution; null: found feasible solution, took the snapshot of the decsion stack, backtracked to the top, and tightened the goal</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.NextDecisionVariableYieldOnSuboptimal">
            <summary> Choose the next undecided Decision Variable
            </summary>
            <returns> false if no decision variables remain to be tried </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.SnapshotDecisions">
            <summary>
            Add a new decision layer when we find a feasible solution. -- lengliu
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.UndoGoalSettings">
            <summary>
            Rewind all previous range restrictions to goals upto the point of _tighteningGoalN
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.SetEarlyGoals">
            <summary>
            Set optimal values to goals that are earlier than _tighteningGoalN
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.TightenGoal">
            <summary>
            Try to tighten the range of current working goal (indexed by _tighteningGoalN)
            </summary>
            <returns>true if and only if no conflicts found after the goal is tightened</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.TryNextValue">
            <summary> With the current decision variable, narrow its value set
            </summary>
            <returns> False when all values of this variable have been exhausted </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LinearSearchOnGoalsWithACS.RestoreSnapshot">
            <summary>
            Restore the previous decision snapshot.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Backtrackable`1">
             <summary>
               Generic class used to make backtrackable ints, strings, bools, 
               whatever. A Backtrackable (say) int is connected to a Trail of ints,
               so that any save operation on the trail allows to later change back
               to the previous state of all the backtrackable ints connected to it.
             </summary>
             <remarks>
               The only way to modify something backtrackable is by assigning it.
               For instance: if we use a backtrackable struct (say a Backtrackable 
               pair of ints, call it P) it cannot be modified field by field 
               (p.Value.First = 3), it has to be completely assigned 
               (p.Value = new PairIntInt(3, p.Value.Second).
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Backtrackable`1.#ctor(Microsoft.SolverFoundation.Solvers.Trail{`0},`0)">
            <summary>
              Construct a Backtrackable item, connected to a trail of the
              corresponding type. Initial value needs be provided.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Backtrackable`1.Value">
            <summary>
              Access to / modification of the Content stored.
              The modification will be backtrackable.
            </summary>
            <remarks>
              One design choice for "set" would be to test whether the assigned
              value is equal to the current one and, if so, to avoid saving. 
              We don't because we don't want to constrain the Content type.
              The user is, however, encouraged to test equality before assigning,
              as this can prevent saving a non-modified backtrackable object.
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Trail`1">
             <summary>
               Trailing datastructure: Backtrackable objects (of the corresponding
               Content type) can be registered to it. Then we can save the
               Trail whenever needed, modify the contents, and a restore operation
               will bring them back to their previous state.
             </summary>
             
             <remarks>
               TODO with the design choice for stacks of vectors and trails it should
               be easy to allow returning cheaply several n steps back among previous
               states. Can be useful for non-chronological backtracking.
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Trail`1.Save">
            <summary>
              Saves the state of all Backtrackable objects registered to
              the trail. We can save as many times as we wish, and states
              will be restored in a LIFO fashion.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Trail`1.Restore">
            <summary>
              Restore the state of all Backtrackable objects registered to the
              trail, in a LIFO fashion, i.e. we go 1 step back to previous states.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Trail`1.Clear">
            <summary> 
              Removes all content. This does not undo any modification on the
              backtrackable objects (used when memory consumption too high
              and re-computation policy must be activated)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Trail`1.TotalLength">
            <summary>
              sum of the numbers of elements stored at each level
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet">
             <summary>
               Class of finite subsets of the integers, that are backtrackable.
             
               The integer values that can be stored within this set have to be
               bounded between a lower and upper bounds, and these bounds should
               not be unreasonably large (underlying is an array representation).
            
               A BacktrackableIntSet int is connected to a TrailOfIntSets,
               so that any save operation on the trail allows to later change back
               to the previous state of all the backtrackable sets connected to it.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.#ctor(Microsoft.SolverFoundation.Solvers.TrailOfIntSets,System.Int32,System.Int32)">
            <summary>
              Construction; the set is initially empty
            </summary>
            <param name="t">trail to which the set is connected</param>
            <param name="minvalue">min value storable in the set</param>
            <param name="maxvalue">max value storable in the set</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Add(System.Int32)">
            <summary>
              Adds an integer to the set.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Remove(System.Int32)">
             <summary>
               Removes an integer from the set.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Fill">
            <summary>
              Adds all values to the set (this is typically used for a 
              freshly constructed set, to have it initially full, because
              the constructor makes it empty by default)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.GetEnumerator">
            <summary>
              Enumeration
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Contains(System.Int32)">
            <summary>
              Returns true iff elt included in the set.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Item(System.Int32)">
            <summary>
              Get the i-th element of the set
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BacktrackableIntSet.Cardinal">
            <summary>
              Number of elements effectively stored in the vector
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TrailOfIntSets">
             <summary>
               Trailing datastructure: BacktrackableIntsets
               can be registered to it. Then we can save the
               Trail whenever needed, modify the contents, and a restore operation
               will bring them back to their previous state.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfIntSets.#ctor">
            <summary>
              Construction
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfIntSets.Save">
            <summary>
              Saves the state of all Backtrackable objects registered to
              the trail. We can save as many times as we wish, and states
              will be restored in a LIFO fashion.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfIntSets.Restore">
            <summary>
              Restore the state of all Backtrackable objects registered to the
              trail, in a LIFO fashion, i.e. we go 1 step back to previous states.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfIntSets.Clear">
            <summary>
              Removes all content. This does not undo any modification on the
              backtrackable objects (used when memory consumption too high
              and re-computation policy must be activated)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TrailOfIntSets.TotalLength">
            <summary>
              sum of the numbers of elements stored at each level
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.FiniteDomain">
             <summary>
               Finite Domain in sparse representation, i.e. we have a bit vector
               saying whether each particular value is present or has been removed.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteDomain.#ctor(Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
              Construction; the domain will contain exactly the values
              specified in the initial Range.
            </summary>
            <param name="t">trail to which the set is connected</param>
            <param name="initialRange">set of initial values</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteDomain.Remove(System.Int64)">
             <summary>
               Removes an integer from the set.
               Will have no effect if the value is not actually contained but 
               the value has to be within the bounds effectively representable
               in the set.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteDomain.Contains(System.Int64)">
            <summary>
              Returns true iff elt included in the set.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteDomain.LowestValue(System.Int64,System.Int64)">
            <summary>
              Returns the smallest value that is within the specified
              interval and that is also contained in the domain.
              Returns MaxValue if no such value is found.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteDomain.HighestValue(System.Int64,System.Int64)">
            <summary>
              Returns the largest value that is within the specified 
              interval and that is also contained in the domain.
              Returns MinValue if no such value is found.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.FiniteDomain.Cardinality">
            <summary>
              Number of values currently allowed in the Finite domain
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains">
            <summary>
              Trailing datastructure: Finite Domains
              can be registered to it. Then we can save the
              Trail whenever needed, modify the contents, and a restore operation
              will bring them back to their previous state.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains.Save">
            <summary>
              Saves the state of all Backtrackable objects registered to
              the trail. We can save as many times as we wish, and states
              will be restored in a LIFO fashion.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains.Restore">
            <summary>
              Restore the state of all Backtrackable objects registered to the
              trail, in a LIFO fashion, i.e. we go 1 step back to previous states.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains.Clear">
            <summary> 
              Removes all content. This does not undo any modification on the
              backtrackable objects (used when memory consumption too high
              and re-computation policy must be activated)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TrailOfFiniteDomains.TotalLength">
            <summary>
              sum of the numbers of elements stored at each level
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Member">
            <summary>
              Constraint on 1 integer variable imposing that its value be
              chosen among a given ValueSet
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.UnaryConstraint`1">
            <summary>
              Root class for unary constraints, i.e. constraints over 1 variable.
            </summary>
            <remarks>
              Main reason for this class is to have direct, typed access to the 
              variable that is constrained (avoids casts or new virtual methods
              added to root class for Discrete Variable)
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverConstraint">
            <summary>
              Root class for constraints.
              Provides minimal interface to allows browsing on the "constraint
              graph"; i.e. essentially we have access to the list of variables 
              that is constrained.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Indexed">
            <summary>
              Classes where each instance belongs to an "indexed collection".
              All instances of each collection are labelled by construction with 
              indexes that range from 0 to the cardinal of the collection minus 1. 
              This allows to associate extra information to each element of the
              collection using fast (array-based) mappings. 
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Indexed.Index">
            <summary>
              Gets the ID of the object. Within the collection this ID 
              uniquely denotes the object. Moreover, the ids range from 0 to size 
              of collection - 1, allowing to use it for fast array look-up.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverConstraint.Signature">
            <summary>
              Access to all discrete variables that are connected by the
              constraint.
            </summary>
            <remarks>
              The variable group has a readonly interface so this object can
              be referenced multiple times by whoever needs to.
            </remarks>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverConstraint.Cause">
            <summary>
              If the constraint generates a deduction, Cause will represent
              the natural cause of the modification. Used in most cases;  
              except when a refined variable group can be specified.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LessOrEqual">
            <summary>
              Constraint between two integer variables X and Y imposing that
              X be less than or equal to Y
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BinaryConstraint`2">
            <summary>
              Root class for binary constraints, i.e. constraints over 2 variables.
            </summary>
            <remarks>
              Main reason for this class is to have direct, typed access to the 
              2 variables that are constrained (avoids casts or new virtual methods
              added to root class for Discrete Variable)
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LessStrict">
            <summary>
              Constraint between two integer variables X and Y imposing that
              X be strictly less than Y 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Equality">
            <summary>
              Constraint between two integer variables X and Y imposing that
              X be equal to Y 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Difference">
            <summary>
              Constraint between two integer variables X and Y imposing that
              X be different from Y 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Disjunction">
            <summary>
              Constraint between two Boolean variables X and Y imposing that
              at least one among X and Y be true.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Implication">
            <summary>
              Constraint between two Boolean variables X and Y imposing that
              if X is true then so is Y.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Negation">
            <summary>
              Constraint between two Boolean variables X and Y imposing that
              Y is the negation of X.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Equivalence">
            <summary>
              Constraint between two Boolean variables X and Y imposing that
              X be true iff Y is true.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IntegerBooleanEquivalence">
            <summary>
              Constraint between an integer variable X and a boolean variable Y 
              imposing that X be 1 if Y is true; 0 otherwise.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ReifiedConjunction">
            <summary>
              Constraint between 3 Boolean variables X, Y and Z
              imposing that Z represent the conjunction X and Y
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TernaryConstraint`3">
            <summary>
              Root class for ternary constraints, i.e. constraints over 3 variables.
            </summary>
            <remarks>
              Main reason for this class is to have direct, typed access to the 
              3 variables that are constrained (avoids casts or new virtual methods
              added to root class for Discrete Variable)
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ReifiedDisjunction">
            <summary>
              Constraint between 3 Boolean variables X, Y and Z
              imposing that Z represent the disjunction X || Y
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ReifiedEquality">
            <summary>
              Constraint between two integer variables X and Y and a Boolean 
              variable B, imposing that B be true iff X is equal to Y.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ReifiedLessEqual">
            <summary>
              Constraint between two integer variables X and Y and a Boolean 
              variable B, imposing that B be true iff X is less than or equal to Y.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Addition">
            <summary>
              Constraint between 3 integer variables X, Y and Z imposing that 
              X + Y be equal to Z
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AdditionToConstant">
            <summary>
              Constraint between 2 integer variables X and Y imposing that 
              X + k be equal to Y, for some constant k.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Opposite">
            <summary>
              Constraint between 2 integer variables X and Y imposing that 
              X and Y be opposite, i.e. Y == -X.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ProductByConstant">
            <summary>
              Constraint between 2 integer variables X and Y and an integer constant
              K imposing that Y == K*X
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ProductByVariable">
            <summary>
              Constraint between 3 integer variables X, Y and Z imposing that 
              X * Y be equal to Z
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ProductByVariable.NarrowXorY(Microsoft.SolverFoundation.Solvers.IntegerVariable,Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Code common to narrowing of X or Y (works symmetrically)
            </summary>
            <param name="nar">the variable that is being narrowed</param>
            <param name="other">the other variable</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Square">
            <summary>
              Constraint between 2 integer variables X and Y and an integer constant
              K imposing that Y == X ^ 2
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AbsoluteValue">
            <summary>
              Constraint between 2 integer variables X and Y and an integer constant
              K imposing that Y == Abs(X)
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BasicConstraintUtilities">
            <summary>
              Utilities that are proper to the basic constraints in this file
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicConstraintUtilities.ImposeEqual(Microsoft.SolverFoundation.Solvers.BooleanVariable,Microsoft.SolverFoundation.Solvers.BooleanVariable,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Makes sure that if one Boolean Variable is instantiated
              the other will be fixed to the same value
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicConstraintUtilities.ImposeBoundsDifferent(Microsoft.SolverFoundation.Solvers.IntegerVariable,Microsoft.SolverFoundation.Solvers.IntegerVariable,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Makes sure that if one Integer Variable is instantiated
              to some value no bound of the other variable is equal to it
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableModification">
            <summary>
              A struct representing any change that can affect the state of a
              variable during the problem's lifetime. Serves essentially as
              parameter for signaling events related to variables.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.VariableModification.RootLevelDeduction">
            <summary>
              Decision used to indicate that a variable modification
              is asserted at the root level ("implied at level 0")
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableModification.Listener">
            <summary>
              Delegates that receive variable modifications
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConflictDiagnostic">
            <summary>
             Class capturing the result of a conflict analysis
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConflictDiagnostic.Status">
            <summary>
              false if the analysis was interrupted because of memory bounds
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConflictDiagnostic.Cause">
            <summary>
              Variables involved in the conflict
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ConflictDiagnostic.Interval">
            <summary>
              Range of values for the conflict variable
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ImplicationGraph">
            <summary>
              Representation of the deductions made by propagation and of the
              causality between them, inspired by what the implication graphs used
              by SAT solvers. Allows conflict analysis.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ImplicationGraph.SubscribeToVarIteratedOver(Microsoft.SolverFoundation.Solvers.ImplicationGraph.VarIteratedOver)">
            <summary>
              Code that is passed to this method will be called
              for every variable that is met during the conflict analysis 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ImplicationGraph.SubscribeToExplanation(Microsoft.SolverFoundation.Solvers.ImplicationGraph.ExplanationFound)">
            <summary>
              Code that is passed to this method will be called
              every time conflict analysis terminates and computes an explanation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ImplicationGraph.SubscribeToConstraintInvolvedInConflict(Microsoft.SolverFoundation.Solvers.ImplicationGraph.ConstraintInvolvedInConflict)">
            <summary>
              Code that is passed to this method will be called
              for every constraint that is met during the conflict analysis 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ImplicationGraph.AnalyseConflictUIP(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm)">
             <summary>
               Main conflict analysis method:
               Computes a unit implication point and updates the weights
               accordingly
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ImplicationGraph.AddVariableModification(Microsoft.SolverFoundation.Solvers.VariableModification)">
            <summary>
              Specifies that a new deduction has happened at the current level:
              variable x was reduced because of c
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ImplicationGraph._graph">
            <summary>
             Only the last level of the implication graph is actually
             constructed. This is done on demand (by recmputation)
             when the conflict is effectively detected
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ImplicationGraph.VarIteratedOver">
            <summary>
              delegates called when a var is iterated over
              by conflict analysis
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ImplicationGraph.ExplanationFound">
            <summary>
              delegates called at the end of conflict analysis;
              receives the explanation of conflict
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ImplicationGraph.ConstraintInvolvedInConflict">
            <summary>
              delegates called when constraint is part of conflict analysis
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Cause">
            <summary>
              Cause of a domain reduction, passed as an argument to any variable
              modification. Captures both a constraint and a variableGroup. The
              variable group may not in general be the whole set of variables
              constrained by the constraint as some constraints might specify
              a subset directly responsible for the deduction.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Cause.IsDecision">
            <summary>
              No cause because represents a decision
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Cause.IsRootLevelDecision">
            <summary>
              No cause because deduced but holds at level 0;
              for instance a refined optimization bound
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NaryConstraint`1">
             <summary>
               Root class for Nary constraints, i.e. constraints over an arbitrary
               number of variables (these variables have to be of homogeneous type)
             </summary>
             <remarks>
               Main reason for this class is to have direct, typed access to the 
               N variables that are constrained (avoids casts or new virtual methods
               added to root class for Discrete Variable)
             </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableGroup">
            <summary>
              Subset of variables. Used whenever we need to distinguish which
              particular variables are involved, for instance, in a deduction.
              In terms of "constraint graph" a VariableGroup will typically 
              represent a (hyper-)edge of the graph.
            </summary>
            <remarks>
              Acts like a readonly collection - purposely not modifiable; because
              meant to be multi-referenced
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableGroup.#ctor(Microsoft.SolverFoundation.Solvers.DiscreteVariable[])">
            <summary>
              Construction - beware: ownership of array is transferred;
              we don't copy
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableGroup.GetVariables">
            <summary>
              Enumerates all variables in the group
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableGroup.EmptyGroup">
            <summary>
              Pre-allocated Variable group representing the empty set
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.VariableGroup.Length">
            <summary>
              Number of variables in the variable group
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.VariableGroup.Item(System.Int32)">
            <summary>
              Direct access to the variable of given index
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StackOfLists`1">
             <summary>
               A specialized class of stack of lists with low-level representation.
               Conceptually equivalent to Stack(List(content)), which would use the 
               generic classes Stack and List; but optimized.
               Key data-structure for storage of lists of modifications ("trailing").
               Implementation is basically one big resizeable array storing all contents,
               together with a stack storing the indexes at which each list starts.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.#ctor">
            <summary>
              Default constructor; use unless you have a good reason
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.#ctor(System.Boolean)">
            <summary>
              Construction with parameters
            </summary>
            <param name="clean">
              Option specifying whether the StackOfList should perform all
              clean-ups when it is resized-down. In general it will set the
              contents to their default value but this can be skipped if the option
              is set to false. The clean-up loop is useless however it
              removes handles to any object that is not effectively stored anymore,
              allowing the GC to make a better job. The non-clean mode, which is
              perfectly ok, e.g., for value types that contain no reference, allows
              constant-time clearing and list-popping.
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.PushList">
            <summary>
              Push a new (empty) list on top of the stack of lists
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.PopList">
            <summary>
              Pops the stack of lists, removing the list on top of the stack
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.AddToTopList(`0)">
            <summary>
              Adds a content into the list that is on top of the stack
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.Clear">
            <summary>
              Remove all content
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.TrimExcess">
            <summary>
              Memory reduction function: call to reduce any 
              space reserved in excess by the data-structure
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.TopList">
            <summary>
              View on the vector that is on top of the stack.
              Use sparingly, e.g. for iteration
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.IsEmpty">
            <summary>
              True if the stack is empty, i.e. contains no list
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.TopIsEmpty">
             <summary>
               True if the list at the top of the stack is empty
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.ReallocateWithReservedSize(System.Int32)">
            <summary>
              Re-allocation; used for transparent array extension and,
              when explicitly required, for trimming
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.ReduceLength(System.Int32)">
            <summary>
              Reduces the length of the content list
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StackOfLists`1.ResetRange(System.Int32,System.Int32)">
            <summary>
              Resets the contents stored between the "from" index
              (included) to the "to" index (non-included) to their
              default value.
            </summary>
            <remarks>
              The parameter "clean", specified at construction-time, 
              defines what we do in this method
            </remarks>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StackOfLists`1._contents">
            <summary>
              Storage of all contents
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StackOfLists`1._length">
            <summary>
              Only contents at positions 0 to _length are considered;
              allows to have an extensible storage
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StackOfLists`1._levels">
            <summary>
              Stack keeping the separations between the lists, e.g. the top list
              consists in the contents stored between positions 
              _levels.Peek() and _length-1
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StackOfLists`1._clean">
            <summary>
              Flag checked when clean-up loop is needed;
              if false the loop is skipped
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StackOfLists`1.NbLevels">
             <summary>
               Number of lists that are pushed in the stack
             </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StackOfLists`1.TotalLength">
            <summary>
              Returns the cumulated size of the lists at all levels
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StackOfLists`1.List">
            <summary>
              "Virtual" vector giving a view on the list at the top of
              the stack. Provides limited functionality, e.g. read-only access
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PriorityQueue`1">
            
             <summary>
               Priority queue implemented on top of .NET generic queue.
               This implementation should be fast when the number of priorities is 
               kept reasonably small.
             
               Number of priorities is given at construction time, and priorities
               are from 0 to NumberOfPriorities-1.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
              Construction
            </summary>
            
            <param name="nbPriorities">(small) number of priorities</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.Clear">
            <summary>
              Remove all content in constant time 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.Dequeue">
            <summary>
              Removes and returns the element at beginning of the queue.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.Enqueue(`0,System.Int32)">
             <summary>
               Insert an element at given priority, at end of queue
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.Peek">
            <summary>
              Gets the first element of the queue, without removing it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.IsEmpty">
            <summary>
              Checks whether queue empty
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.FirstNonEmptyQueue">
            <returns>
              non-empty queue with lowest priority; or
              null if the priority queue is empty
            </returns>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.PriorityQueue`1.NumberOfPriorities">
            <summary>
              Number of priorities of the queue.
              This number is given at construction, it can be re-set but
              (for simplicity) only while the queue is empty
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.FiniteIntSet">
            
             <summary>
               Class of finite subsets of the integers. 
               The integer values that can be stored within this set has to be
               bounded between a lower and upper bounds, and these bounds should
               not be unreasonably large (underlying is an array representation).
             </summary>
             <remarks>
               Representation is mixed:
             
               - one vector ("_content" fields) containing the elements effectively
                 present in the set (these are stored from index 0 to 
                 _firstNonWrittenPosition-1)
             
               - one basic array ("_position" field) such that _position[i] == -1
                 if i is not contained in the array, and position[i] gives the
                 position at which i is stored in the _content vector otherwise.
             
               These two vectors are in fact stored as a unique array of Cells.
             </remarks>
             
             <remarks>
               Good in terms of worst-case time for each operation (everything
               constant-time) BUT not the most memory-efficient representation;
               consider bit-vectors as well?
             </remarks>
             
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.#ctor(System.Int32,System.Int32)">
             <summary>
               Construction of a set that can contain integer elements
               ranging over minvalue .. maxvalue. The set is initially empty.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.AddNotContainedElement(System.Int32)">
            <summary>
              Adds an element to the set.
              Element is assumed NOT already present
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Add(System.Int32)">
             <summary>
               Adds an element in the set 
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.RemoveContainedElement(System.Int32)">
            <summary>
              Removes an element from the set.
              Element is assumed present.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Remove(System.Int32)">
            <summary>
              Removes an element from the set.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Clear">
            <summary>
              Removes all elements from the set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Contains(System.Int32)">
            <summary>
              True if the element is contained in the set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FiniteIntSet.IsEmpty">
            <summary>
              True iff the set is empty
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Cardinal">
            <summary>
              Cardinal of the set, i.e. nb of elements
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.FiniteIntSet.MinValue">
            <summary>
              Lowest integer value whose storage in the set is allowed
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.FiniteIntSet.MaxValue">
            <summary>
              Highest integer value whose storage in the set is allowed
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.FiniteIntSet.Item(System.Int32)">
            <summary>
              get or set the i-th element
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Set`1">
            
             <summary>
               Basic class of sets of a homogeneous type
             </summary>
             <remarks>
               Implementation is a bit stupid, in that we store useless (null) value
               - only the key is needed. Some things, e.g. Enumeration, won't be
               particularly speedy.
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Set`1.#ctor">
            <summary>
              Construction of an empty set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Set`1.Add(`0)">
            <summary>
              Adds an element to the set; allowed even
              if the element is already present (will be stored only once)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Set`1.Remove(`0)">
            <summary>
              Removes an element from the set;
              Precondition: the element should be included
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Set`1.Clear">
            <summary>
              Removes all elements from the set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Set`1.Contains(`0)">
            <summary>
              Does the set contain the element?
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Set`1.Cardinality">
            <summary>
              returns the number of elements currently stored in the set
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverTerm">
            <summary>
              As term as manipulated by Disolver.
            </summary>
            <remarks> 
              The main goal of terms is to be used as "intermediate representations"
              of the problem on which preprocessing can be done and from which one
              or more representation(s) specialised for the algorithm(s) considered
              can be created, depending on the analysis of the problem.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverTerm.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.DisolverTerm[])">
            <summary>
              Construction of a Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverTerm.IsUserDefined">
             <summary>
               True if the term is NOT functionally-dependent on other Terms.
               Typically this means we have to choose a value for this Term
               (in contrast the value of other Terms is determined)
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverTerm.IsInstantiated">
            <summary>
              True if the variable is initially instantiated
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverTerm.GetValue">
            <summary>
              Gets the value of an instantiated term
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverTerm.SubTerms">
            <summary>
              Direct, internal access to the array of subterms
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverTerm.Key">
            <summary>
              accessor is to be called by user only (for internal initialization
              use protected _key field directly instead as call to key
              would add the term to user-named terms)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverTerm.InitialRange">
            <summary>
              Returns the interval of values for the term
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverTerm.InitialLowerBound">
            <summary>
              Get initial lower bound of the term, implictly seen as Integer 
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverTerm.InitialUpperBound">
            <summary>
              Get initial upper bound of the term, implictly seen as Integer 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm">
            <summary>
              A Boolean Term, as manipulated by Disolver.
              (the main thing is that they can be assigned an initial truth value)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.DisolverTerm[])">
            <summary>
              Construction of a Boolean Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm.SetInitialValue(System.Boolean)">
             <summary>
               Use when the value of the Term is set, say, by constant
               propagation before resolution.
             </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverBooleanConstant">
            <summary>
            terms for boolean constants
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverBooleanVariable">
            <summary>
             terms for boolean variables 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverNot">
            <summary>
              negation of a term
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverMember">
            <summary>
              Membership of a variable in a domain
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverAnd">
            <summary>
              Conjunction
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverOr">
            <summary>
              Disjunction
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverEqual">
            <summary>
              Equality
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverDifferent">
            <summary>
              Difference, aka "unequality"
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverLessEqual">
            <summary>
              ordering between two variables
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm">
            <summary>
              An integer-valued variable, as manipulated by Disolver.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,System.Int64,System.Int64,Microsoft.SolverFoundation.Solvers.DisolverTerm[])">
            <summary>
              Construction of an integer Term
            </summary>
            <param name="solver">solver to which the term is connected</param>
            <param name="l">initial lower bound</param>
            <param name="r">initial upper bound</param>
            <param name="subterms">list of subterms (possibly null)</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverIntegerConstant">
            <summary>
              Terms representing constants
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverIntegerVariable">
            <summary>
              Terms representing integer variables.
              Can have a more complex domain and be user-defined
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverAbs">
            <summary>
              Absolute value
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverSquare">
            <summary>
              Square i.e. sub-term multiplied by itself
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverBooleanAsInteger">
            <summary>
              Integer term that corresponds to an explicit conversion of 
              Boolean term into a 0/1 value
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverUnaryMinus">
            <summary>
              Opposite, i.e. -x
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverSum">
            <summary>
              Sum of an arbitrary number of subterms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverProduct">
            <summary>
              product, i.e. sub-terms are multiplied
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverMin">
            <summary>
              Minimum of an arbitrary number of terms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverMax">
            <summary>
              Maximum of an arbitrary number of terms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverIfThenElse">
            <summary>
              Conditional, i.e.   condition ? left : right
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverIndex">
            <summary>
              Index, or array indirection
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverPositiveTableTerm">
            <summary>
              Extensional relation, i.e. the term is true iff a tuple of vars
              forms one of the combinations explicitly listed in a table.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverMatrixIndex">
            <summary>
              Index in a matrix
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain">
            <summary>
              A domain, as manipulated by users when they state problems
              using Disolver
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain.Values">
            <summary>
            Enumerate all values in this domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain.ContainsValue(System.Object)">
            <summary> Check if the given value is an element of the domain.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain.SubCast(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
              Sometimes need to subcast from root class; use this:
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain.FirstValue">
            <summary> The first value in the restriction otherSet
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DisolverDiscreteDomain.LastValue">
            <summary> The last value in the restriction otherSet
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverSymbolSet">
            <summary>
              "enum", i.e. set of values that have a symbolic name.
              Internally these symbolic values are labelled from 0 to n-1
            </summary>
            <remarks>
              Naive implementation
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverSymbolSet.Symbol(System.Int32)">
            <summary>
              Conversion from int value to its symbol
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverSymbolSet.Value(System.String)">
            <summary>
              Conversion from symbol to its int value
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConvexDomain">
            <summary>
              Class of convex (i.e. interval) value sets for specifying the
              initial range of variables. Use by default preferably to more
              costly SparseSet
            </summary>
            <remarks>
              Naive implementation
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SparseDomain">
            <summary>
              class of sparse value sets containing values at arbitrary positions
              and used to specify the initial range of some variables.
            </summary>
            <remarks>
              Naive implementation
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SparseDomain.GetOrderedUniqueValueSet">
            <summary>
              returns the set of values contained in the set, 
              stored in a sorted (ascending) unique way.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Features">
            <summary>
              Class used to extract features of a given problem
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.#ctor(Microsoft.SolverFoundation.Solvers.Problem)">
            <summary>        
            Takes as parameter a problem and allocates sufficient memory for the 
            the number of features contained in FeatureNames
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.ExtractFeatures">
            <summary>
            Extract Features of the current Problem and store in feature vector
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.ComputeSimpleConstraintStatistics">
            <summary>
            Access/Compute simple statistics on Constraints
            * Store in feature array *
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.ComputeConstraintConnectivity">
            <summary>
            Computes the connectivity of all constraints
            (Not yet finished)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.AddHistToFeatures(System.Double[],System.String)">
            <summary>
            Helper function to add histograms to features
            </summary>
            <param name="arrHist"></param>
            <param name="sHist"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.ComputeVariableRelatedFeatures">
            <summary>
            Compute and set the number of ALL/Userdefined INT/BOOL vars in the current Problem 
            This also includes the computation of several ratios
            Remark: the computation of the basic value should be performed when constructing the problem
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.GetNumberOfFeatures">
            <summary>
            Get number of features 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Features.DisplayFeatures">
            <summary>
            Display collected features on Console
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DelegateAdaptor">
            <summary>
              adapts events of signature (IntegerVariable -> void)
              into events of signature (int -> void) where the int is
              the index of the variable in the global constraint.
              This index is specified at construction time
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AllDifferentLazy">
            <summary>
              Constraint on a list of variables, imposing that all
              variables be pairwise different. This version is extremely incremental,
              using watches. It scales very well and should be preferred for 
              large arrays
            </summary>
            <remarks>
              Version based on lazy-data-structures (watching).
              As incremental as it possibly gets, but space-consuming: 
              allocates arrays linear in the number of possible values.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.WhenBoundsModified(System.Int32)">
            <summary>
              When the lower bound of _args[varidx] is modified we check in
              constant time if a variable is instantiated to this value
              and if so we find the first value not taken by an instantiated var
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.WhenInstantiated(System.Int32)">
            <summary>
              Code called when the variable _args[varidx] is instantiated.
              We go through the variables that watch this value as their lower
              or upper bound.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.LowerBoundWatches(System.Int64)">
            <summary>
              Enumerates the lower-bound Watches attached to the value
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.UpperBoundWatches(System.Int64)">
            <summary>
              Enumerates the upper-bound Watches attached to the value
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.WhenRestored(System.Int32)">
            <summary>
              Called when the problem is restored - we undo any change
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.UpdateLowerWatch(System.Int32)">
            <summary>
              Removes the lower bound watch from the value it 
              is currently plugged to
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.UpdateUpperWatch(System.Int32)">
            <summary>
              Removes the upper bound watch from the value it 
              is currently plugged to
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.PlugLowerWatch(System.Int32)">
            <summary>
              Plugs the watch for the lower bound of the var of given 
              index to the slot corresponding to that var's current upper
              bound. The watch is assumed unplugged.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.PlugUpperBound(System.Int32)">
            <summary>
              Plugs the watch for the upper bound of the var of given
              index to the slot corresponding to that var's current upper 
              bound. The watch is assumed initially unplugged.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._minvalue">
            <summary>
              shift between values and arrays indexes (0-based)
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._forbidden">
            <summary>
              _forbidden[val-_minvalue] is non-null iff the value val is 
              forbidden and points to the cause, i.e. instantiated var that
              is instantiated to this value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._lowerBoundsWatched">
            <summary>
              at position [val-_minvalue], keeps the list of variables whose
              lower bound watches the value val
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._upperBoundsWatched">
            <summary>
              at position [val-_minvalue], keeps the list of variables whose
              upper bound watches the value val
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._valueCurrentlyWatchedLower">
            <summary>
              at position i keeps the 
              value currently watched as lower bound of _args[i]
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._valueCurrentlyWatchedUpper">
            <summary>
              at position i keeps the 
              value currently watched as upper bound of _args[i]
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._lbwatch">
            <summary>
              at position i keeps the 
              watch for the lower bound of _args[i]
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLazy._ubwatch">
            <summary>
              at position i keeps the 
              watch for the upper bound of _args[i]
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AllDifferentLazy.Watch">
            <summary>
              Watches are dealt with as linked data-structures. This allows
              similar behaviour to having arrays of resizable lists but with
              guarantee that no memory whatsoever is allocated when watches
              move from one place to another.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AllDifferentLight">
            <summary>
              Constraint on a list of variables, imposing that all
              variables be pairwise different.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLight.CheckLowerBound(Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Check whether the lower bound of the variable is forbidden;
              logarithmic time (called very often)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLight.CheckUpperBound(Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Check whether the upper bound of the variable is forbidden;
              logarithmic time (called very often)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLight.WhenInstantiated(System.Int32)">
            <summary>
              Propagation and work to do when a variable is instantiated.
              Costly (linear time iteration + linear time list insertions)
              but called relatively rarely - only when instantiations.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AllDifferentLight.WhenRestored(System.Int32)">
            <summary>
              When an instantiated variable has forced us to forbid a value
              and is uninstantiated we undo the effects
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLight._forbiddenValues">
            <summary>
              sorted-increasing-unique, list of forbidden values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLight._reasons">
            <summary>
              For each index i we record the variable
              that is instantiated to _forbiddenValues[i]
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.AllDifferentLight._instantiated">
            <summary>
              When a variable is identified by the algorithm as instantiated
              we record its value here at the corresponding index.
              For non-instantiated vars we store -infinity
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LargePseudoBooleanSum">
            <summary>
              Constraint between a list of Boolean variables and an Integer
              variable S, imposing that S represent the number of variables true in 
              the list.
            </summary>
            <remarks>
              An improved implementation would probably use watching
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LargeClause">
            <summary>
              Constraint on a list of Boolean variables, imposing that at
              least one of the Booleans be true
            </summary>
            <remarks>
              This is a copy-cut of the Pseudo-Boolean, simplified and specialized 
              for a minimum sum of one. Not yet a good specialized (SAT-like)
              implementation using watching, needless to say.
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ReifiedValueSet">
            <summary>
              Constraint that connects an array of Boolean variables to some
              values of a discrete variable. Allows to "watch" a number of values
              of X and register delegates called when it is known whether the
              variable takes this value.
            </summary>
            <remarks>
              This is essentially a shorthand for a sequence of N refied
              equalities: b[0] iff (x = value[0]), ... , b[N-1] iff (x = value[N-1]).
              But the cost is considerably amortized: Decomposing would require to
              wake-up N propagators; here we need can react to most changes in
              constant time
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ReifiedValueSet.#ctor(Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.IntegerVariable,System.Int64[],Microsoft.SolverFoundation.Solvers.BooleanVariable[])">
            <summary>
              Creates a constraint imposing that for each i in [0, N[ 
              b[i] is true iff x == values[i]
              (where values and b are of the same size N).
              The values should be sorted in strictly increasing order.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ReifiedValueSet.FindPosition(System.Int64)">
            <summary>
              Finds the position of a certain element in _values.
              Returns something negative if the element is not found.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ReifiedValueSet._firstNonDiscardedBool">
            <summary>
              Position p of the left-most Boolean variable such that:
              _values[p] sup equal to _x.LowerBound. Under-approximated
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.ReifiedValueSet._lastNonDiscardedBool">
            <summary>
              Position p of the right-most Boolean Variable such that:
              _values[p] lessEqual to _x.UpperBound. Over-approximated.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Index">
            <summary>
              Constraint between an array of integer variables tab[0] ... tab[n-1],
              an Integer variable Idx and an integer variable Res, imposing that
              tab[idx] = res.
            </summary>
            <remarks>
              Weaker pruning than using Boolean for var/value pairs, but
              better space scalability.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.Initialize">
            <summary>
              Called at beginning of first propagation loop
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.WhenArrayModified(System.Int32)">
            <summary>
              Called when array modified at position i
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.WhenResultModified">
            <summary>
              Code called when the result variable is modified
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.WhenIndexModified">
            <summary>
              Code called when the index is modified
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.WhenIndexInstantiated">
            <summary>
              Code called when the index is instantiated to a value I. 
              In this case the constraint behaves like an equality between 
              _tab[I] and Res, nothing more
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.CheckIndexBounds">
            <summary>
              makes sure the bounds of the Index variable
              are not disjoint from the result
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.MinimumLowerBound">
            <summary>
              Computes min {lb(_tab[i]) : i  is acceptable};
              also returns one of the acceptable i's with the 
              corresponding lower bound
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.MaximumUpperBound">
            <summary>
              Computes max {ub(_tab[i]) : i  is acceptable};
              also returns one of the acceptable i's with the 
              corresponding upper bound
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.IsWithinIndexRange(System.Int32)">
            <summary>
              true if the position i is within the current range of
              the Index variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Index.IsDisjointFromResult(System.Int64)">
            <summary>
              False if _tab[i] can potentially be equal to Res
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Index._watchMinBound">
            <summary>
              Watches the position of a variable with minimal lower bound
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Index._watchMaxBound">
            <summary>
              Watches the position of a variable with maximal upper bound
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SetMembership">
            <summary>
              Constraint between an Integer Variable Y and a list of 
              Integer variables [X1 .. Xn] imposing that Y be equal to (at least)
              one of the variables in the list. 
            
              Additionally, the constraint maintains a list of Booleans [B1 .. Bn];
              each Bi is true iff Y is equal to Xi.
              In some cases these Booleans can just be ignored, in some other
              cases they can be used to discard some equalities.
            </summary>
            <remarks>
              We are using watching to locate the support of the minimum 
              and the maximum values of Y
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SetMembership.MinimumLowerBound">
            <summary>
              Returns the value of the minimal lower bound, 
              together with the position of one of the vars that
              has this low bound
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SetMembership.MaximumUpperBound">
            <summary>
              Returns the value of the maximal upper bound, 
              together with the position of one of the vars that
              has this upper bound
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SetMembership._watchMinBound">
            <summary>
              Watches the position of a variable with minimal lower bound
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SetMembership._watchMaxBound">
            <summary>
              Watches the position of a variable with maximal upper bound
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PositiveTable">
            <summary>
              Constraint between N integer variables imposing that the tuple of
              values assigned to these variables be equal to one of the lines of 
              a table. The relation is in other words directly expressed  in
              intension, as a list of allowed tuples.
            </summary>
            <remarks>
              This is a general version aimed at working in any condition, even
              if the variables have no sparse representation and the domains are
              unreasonable. (essentially this is AC4)
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PositiveTable.RemoveLine(System.Int32)">
            <summary>
              Computes the effects of the removal of a line (this decreases
              the number of supports of some var/value pairs and this this
              counter reaches 0 may provoke their removal).
            </summary>
            <param name="line">index of the line</param>
            <returns>false iff failure was detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PositiveTable.RemoveLineBis(System.Int32,System.Int32)">
            <summary>
              Computes the effects of the removal of a line (this decreases
              the number of supports of some var/value pairs and this this
              counter reaches 0 may provoke their removal).
            </summary>
            <param name="line">index of the line</param>
            <param name="columnToSkip">
              index of a column that can just be ignored. 
              Set to -1 if no colum should be ignored
            </param>
            <returns>false iff failure was detected</returns>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.PositiveTable._table">
            <summary>
              For each line and each column we directly keep the counter
              and the boolean variable associated to the 
              corresponding variable/value pair.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.PositiveTable._validLines">
            <summary>
              for each line l of the table _validLines.Contains(l) is true
              iff the line is valid (false if some variable contradicts it)
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PositiveTable.Info">
            <summary>
              struct representing info attached to each var/value pair.
              The count is the number of supports for each variable/value pair. 
              When this reaches 0 that signals that the value should be removed
              from the variable The Boolean variable is the one representing 
              the truth value of the pair.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NoGood.RangeForbidden(System.Int32)">
            <summary>
              True if the current range of the var of index idx
              is entirely forbidden, i.e. included in forbidden interval
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GlobalConstraintUtilities">
            <summary>
              Utilities shared by some of the global constraints
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GlobalConstraintUtilities.Join``2(``0[],``1[])">
            <summary>
              Union of two arrays of (subtypes of) Discrete Variables
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Heuristic">
            <summary>
              Root class for heuristics. A heuristics is an object that parametrizes
              a tree-search solver by indicating which decisions to make.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Heuristic.Decide">
             <summary>
               Picks a well-chosen decision that should be done by a tree search
               algorithm. The decision might be to tighten a value (e.g. by
               imposing a new lower bound) or something else, e.g. to restart or
               to stop because a solution is found.
               
               If the decision is to tighen a variable then note that (1) the 
               variable should not already be instantiated; (2) the decision
               should indeed reduce its domain; (3) the decision cannot be an
               instantiation to an arbitrary value, i.e. it has to preserve the
               convexity of any convex domain (ImposeLowerBound/ImposeUpperBound).
               This allows refutation to work robustly.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Heuristic.NextDecision">
            <summary>
              Actual implementation of the decision method
              depending on the concrete type of the heuristic
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableValueHeuristic">
            <summary>
              Heuristics that chooses variables based on a variable selector and 
              that instantiates it to a variable. When the variable is chosen 
              Calls are made to a value selector until the chosen variable is 
              assigned to a satisfactory value and only then do we ask for 
              another variable.
            </summary>
            <remarks>
              In addition to the randomization that some variable or value
              heuristics may have, we add a weak source of randomness in the order
              in which we branch left or right when considering a value. For
              some heuristics this will nevertheless produce entirely deterministic
              effects.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableValueHeuristic.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Int32,Microsoft.SolverFoundation.Solvers.VariableSelector,Microsoft.SolverFoundation.Solvers.ValueSelector)">
            <summary>
              Construction with explicit random seed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableValueHeuristic.NextDecision">
            <summary>
              Decides the next decision by delegating the variable
              choice and the value choice to the dedicated objects.
            </summary>
            <remarks>
              A difficulty is that when the value heuristic makes a choice we may 
              make two decisions: one saying that the variable is greater/equal 
              to the value; then one the other way around. A failure
              may be detected between the two decisions. The same variable may
              be branched twice or more: 
            
              The reason why we do that is that this allows to rely on refutation
              (we just return bound modifications to the tree search), while
              allowing the value ordering to return arbitrary values within the
              domain. Search will be complete independently of whether we are 
              using a sparse representation for the variables.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableValueHeuristic.ChoseVariable">
            <summary>
              Chose a new variable a make a decision on it. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableValueHeuristic.ChoseBoundDecision(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Int64)">
            <summary>
              Given a variable and a value v that is within its bounds;
              return a decision to narrow one bound of x towards v.
            </summary>
            <remarks>
              We take care of not taking a decision that would not prune 
              anything, i.e. if the value is one of the bounds we narrow
              the other bound. Direction is otherwise random
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DichotomicBranchingHeuristic">
            <summary>
              Heuristic that choses variables by calling a Variable selector
              and that splits the domain variable into two
            </summary>
            <remarks>
              The decision to branch left or right is taken at random
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DichotomicBranchingHeuristic.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Int32,Microsoft.SolverFoundation.Solvers.VariableSelector)">
            <summary>
              Construction with explicit random seed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DichotomicBranchingHeuristic.NextDecision">
            <summary>
              Decides the next decision by delegating the variable
              choice and the value choice to the dedicated objects.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RestartHeuristic">
            <summary>
              Heuristic Adaptor that runs a heuristic but that will restart it
              every so often (often in the beginning, then increasingly rarely).
              As soon as a first solution is found we don't interrupt the heuristic
              anymore so that we guarantee an exact count of solutions.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableSelector">
            <summary>
              Variable Ordering meant to be used jointly with a Value ordering
              heuristic. Can be stateful, will be backtracked.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VariableSelector.DecideNextVariable">
            <summary>
              Returns a variable that is not instantiated and should
              be branched-on. Null value indicates that all variables
              are instantiated.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ValueSelector">
            <summary>
              Value Ordering meant to be used jointly with a Variable ordering
              heuristic. Must be stateless.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ValueSelector.DecideValue(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
              Given a variable, returns a value for it that is
              within its domain and should be chosen for branching
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LexVariableSelector">
            <summary>
              A variable ordering heuristic in which we branch on user-defined 
              variables in the order in which they are declared. 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RandomVariableSelector">
            <summary>
              A variable ordering heuristic in which we systematically pick
              variables uniformly at random among the non-instantiated
              user-defined ones.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RoundRobinVariableSelector">
            <summary>
              A variable ordering heuristic in which we returns non-instantiated
              variables in a cyclic way
            </summary>
            <remarks>
              In current version only user-defined variables are branched on
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector">
            <summary>
              Root class for all variable ordering heuristics based on a
              numerical score. The returned variable is, at every decision, the
              one with the lowest numerical score. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Boolean)">
            <summary>
              Construction
            </summary>
            <param name="algo">The search algorithm</param>
            <param name="onlyUserDefinedVars">
              set to true if the heuristic should ignore 
              variables that are not user-defined
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.DecideNextVariable">
            <summary>
              Picks one of the non-instantiated variables
              whose domain has the smallest cardinality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.ChangeScore(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Double)">
            <summary>
              Should be called by concrete class whenever the score
              associated with a variable is dynamically changing
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.Score(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
              Gets the current score of the variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.WhenVariableRestored(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
              Reacts to the restoration of any variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.IgnoreVariable(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
              True if the variable should never be returned by
              the heuristic
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.CheckMinimality(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
             <summary>
               Checks that the selected variable is one of the 
               non-instantiated vars with minimal score
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HeapBasedVariableSelector.CheckHeapContent">
            <summary>
              Checks that the heap contains all non-instantiated vars
              at the right position
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.MinDomainVariableSelector">
            <summary>
              A variable ordering heuristic in which we branch on one of the
              non-instantiated user-defined ariables whose domain has the minimal
              cardinality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MinDomainVariableSelector.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Int32)">
            <summary>
              Construction
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MinDomainVariableSelector.RandomPerturbation">
            <summary>
              Creates a random pertubation between 0.0 and 1.0, excluded.
              This will add some randomness to the choice of variables
              with identical domain sizes.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector">
            <summary>
              A variable ordering heuristic in which we branch on one of the
              non-instantiated user-defined ariables whose domain has the minimal
              cardinality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Int32)">
            <summary>
              Construction
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.bumpVarScore(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
            Bump the score of a dicrete Variable
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.decayVarScore">
            <summary>
            Decay all Discrete Variables by a constant (varDecay)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.AnalyseConflict(Microsoft.SolverFoundation.Solvers.VariableGroup)">
            <summary>
              Undoes the latest changes when backtracking
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.DecideNextVariable">
            <summary>
              Picks one of the non-instantiated variables
              whose domain has the smallest cardinality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VsidsVariableSelector.Unplug">
            <summary>
              Called when a first solution is found.
              Freezes the weights in the heap, and disconnects
              the implication graph. This is because conflict
              analysis would require solution analysis after
              1st solution found
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector">
            <summary>
              A variable ordering heuristic in which we branch on one of the
              non-instantiated user-defined ariables whose domain has the minimal
              cardinality
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector.#ctor(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm,System.Int32)">
            <summary>
              Construction
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector._domainSize">
            <summary>
              to each var we associate an expression whose value
              if the range of the variable
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector._isUninstantiated">
            <summary>
              to each var we associate an expression which is 1 iff 
              the range of variable is > 1
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector._score">
            <summary>
              (complex!) score attached to every variable
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector._weight">
            <summary>
              to each constraint we associate a weight, which the
              heuristic increments on conflict
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.DomWdegVariableSelector._checkedWeight">
            <summary>
              to each constraint we associate a lazy expression which
              is equal to the weight except when the constraint is
              inactive (less than 2 uninstantiated vars) in which
              case the expression evaluates to 0
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LexValueSelector">
            <summary>
              A value ordering that always returns the lowest
              available value, i.e. the values will be enumerated
              in increasing order
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InvLexValueSelector">
            <summary>
              A value ordering that always returns the highest
              available value, i.e. the values will be enumerated
              in decreasing order
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RandomValueSelector">
            <summary>
              A value ordering that always returns a value chosen
              uniformly at random between the two bounds 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimpleImpactVariableSelector">
            <summary>
            
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleImpactVariableSelector._SetupIncrementalCompSearchSpace">
            <summary>
            Setup incremental function that computes the search volume
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleImpactVariableSelector._GetSearchVolume">
            <summary>
            Get the current search volume
            </summary>
            <returns> double </returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LastConflictLexVariableSelector">
            <summary>
              A variable ordering heuristic in which we branch on variables 
              that appear in the most recent conflict first, and if there
              is no conflict we branch according to LEX
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LastConflictLexVariableSelector.ProcessConflict(Microsoft.SolverFoundation.Solvers.VariableGroup)">
            <summary>
              Adds the variables that are contained in the conflict to the queue
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LastConflictLexVariableSelector.Unplug">
            <summary>
              Called when a first solution is found.
              Disconnects the implication graph. This is because conflict
              analysis would require solution analysis after
              1st solution found
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IndexedCollection`1">
             <summary>
               A collection of indexed elements that are used jointly.
               The elements contained in this collection will automatically be
               labelled with unique IDs from 0 to cardinality-1. This allows to
               associate extra information to each element of the collection
               using fast (array-based) mappings. 
             </summary>
             <remarks>
               A typical use is to create first the Elements stored in this
               collection then to create all dependent data-structures. It is
               possible to do things in the opposite order but this will cause
               many calls to resize the data-structure - once data-structures are
               created add elements sparingly.
             </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IIndexedCollection">
            <summary>
              Interface exporting methods of class IndexedCollection to non-generic
              class Indexed. (tedious, but needed to allow the Indexed objects and
              the LookupDatastructures to subscribe themselves at construction-time
              auto-magically, 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IIndexedCollection.Subscribe(Microsoft.SolverFoundation.Solvers.Indexed)">
            <summary>
              Subscribe a new indexed to collection; 
              returns the ID that the index must take
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IIndexedCollection.Subscribe(Microsoft.SolverFoundation.Solvers.ILookupDatastructure)">
            <summary>
              Called when a new dependent data-structure is created.
              By calling this the data-structure will be informed of any
              change in the indexedCollection
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Microsoft#SolverFoundation#Solvers#IIndexedCollection#Subscribe(Microsoft.SolverFoundation.Solvers.Indexed)">
             <summary>
               notifies the collection that a new element that is attached
               to it has been created.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Enumerate">
            <summary>
              Returns the set of elements
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Contains(`0)">
            <summary>
              True if the element is part of the collection.
              Convenient for integrity checks
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Microsoft#SolverFoundation#Solvers#IIndexedCollection#Subscribe(Microsoft.SolverFoundation.Solvers.ILookupDatastructure)">
            <summary>
              Called when a new dependent data-structure is created.
              By calling this the data-structure will be informed of any
              change in the indexedCollection
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.DispatchSizeChange">
            <summary>
              Called when an element is added to the collection.
              If some data-structures are created that depend on the
              collection we have to modify them so that they resize
              if needed.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Cardinality">
            <summary>
              Number of elements (used in particular to number new instances)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IndexedCollection`1.Item(System.Int32)">
            <summary>
              Used to enumerate by index. Use preferably to foreach
              whenever the actual indices matter.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LookupMap`2">
            <summary>
              Mapping that associates information of a certain type (Value) to the
              elements of an indexedCollection. Use similar to Dictionary but
              implementation uses fast (constant-time) index-based look-up.
            </summary>
            <remarks>
              Trying hard to implement semantics strictly equivalent to Dictionary
              even for value types (which I find best implemented with extra boolean
              flag - default is not necessarily invalid value and having trouble
              with generic equality.)
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ILookupDatastructure">
            <summary>
              Data-structures that are implemented using indexing benefit from fast
              (look-up based) way to associate extra info to the elements of an
              indexedCollection. Then if we modify the indexed collection we should
              propagate this info to the data-structure. For that purpose any
              such data-structure will inherit from LookupDatastructure and 
              implement a Resize method.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILookupDatastructure.Resize(System.Int32)">
            <summary>
              Called when the initial collection is modified (typically some
              elements are added), so that the data-structure re-allocates
              its internal look-up tables if needed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ILookupDatastructure.#ctor(Microsoft.SolverFoundation.Solvers.IIndexedCollection)">
            <summary>
              Called when a new dependent data-structure is created.
              By calling this the data-structure will be informed of any
              change in the indexedCollection
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LookupMap`2.#ctor(Microsoft.SolverFoundation.Solvers.IndexedCollection{`0})">
            <summary>
              Creates a Map that allows to associate extra info of type Value
              to any member of the indexed collection.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LookupMap`2.Resize(System.Int32)">
            <summary>
              Called if new elements are added to the original
              IndexedCollection while this datastructure is in use.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LookupMap`2.Item(`0)">
            <summary>
              Gets or sets the value associated to a key.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SubSet`1">
            <summary>
              Subset of an indexed collection
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.#ctor(Microsoft.SolverFoundation.Solvers.IndexedCollection{`0})">
            <summary>
              Creates a subset of the IndexedCollection;
              initially empty
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Add(`0)">
            <summary>
              Adds an element to the subset
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Remove(`0)">
            <summary>
              Removes an element for the set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Clear">
            <summary>
              Removes all emlements from the set
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Contains(`0)">
            <summary>
              Returns true iff a value exists for the key
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Enumerate">
            <summary>
              Enumerates the keys for which a value has been defined
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SubSet`1.Resize(System.Int32)">
            <summary>
              Called if new elements are added to the original
              IndexedCollection while this datastructure is in use.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SubSet`1.Cardinal">
            <summary>
              Number of elements currently in the subset
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SubSet`1.Item(System.Int32)">
            <summary>
              Get the i-th element of the set
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BinaryHeap`1">
             <summary>
               A min-heap designed for Indexed objects, and allowing to insert
               elements accompanied with a numerical (real) score. The heap will
               be constantly re-ordered so that the top is the element with lowest
               score. 
             </summary>
             <remarks>
               A key, non-standard functionality (and the one that justifies the
               requirement that contents be Indexed) is that this implementation
               allows to change the score assigned to a contained object. It is
               also possible to remove inserted objects, whatever their position.
               All operations take logarithmic time
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Remove(`0)">
            <summary>
              Removes an element contained in the heap
            </summary>
            <remarks>
              This is done by clobbering the element on top with
              the right-most leaf and reordering along the branch.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Pop">
            <summary>
              Removes the element with minimum score and returns it 
            </summary>
            <remarks>
              This is done by clobbering the element on top with
              the right-most leaf and reordering-down. 
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Insert(`0,System.Double)">
            <summary>
              Inserts a non-contained element with indicated score
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.ChangeScore(`0,System.Double)">
            <summary>
              Change the score of an element contained in the heap. 
              This will cause re-ordering
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Contains(`0)">
            <summary>
              returns true if the element is in the heap
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Score(`0)">
            <summary>
              Returns the score attached to an included element
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Top">
            <summary>
              Access the element with lowest score, without removint it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.ReorderUp(System.Int32)">
            <summary>
              Reordering operation, upward: from a node of binary tree
              if order w.r.t parent not ok we swap and repeat the
              operation for the parent
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.ReorderDown(System.Int32)">
            <summary>
              Reordering operation, downward: from a node of binary tree
              if order w.r.t parent not ok we swap and repeat the
              operation for the parent
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Resize(System.Int32)">
            <summary>
              Called if new elements are added to the original
              IndexedCollection while this datastructure is in use.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BinaryHeap`1._positions">
            <summary>
              For each inserted element we keep index where
              inserted (0 if NOT inserted)
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BinaryHeap`1._array">
            <summary>
              The heap binary tree, implemented as array.
              root is at position 1, so that children of index i are found
              at indexes 2*i and 2*i + 1.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BinaryHeap`1._firstFreePosition">
            <summary>
               Simulates extendible array
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Empty">
            <summary>
              True if the heap contains no element
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BinaryHeap`1.Count">
            <summary>
              Number of elements inserted in the heap
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyEvaluator">
            <summary>
              Main class for lazy evaluation. This is used when we need numerical
              functions (typically sums) of a large number of inputs, and that need
              to be called very often. Instead of recomputing the function everytime
              we just propagate the things that were modified, allowing to obtain the
              updated result in sub-linear time. This is particularly good when the
              expression includes a large sum (updates are in constant time); for
              other constructs large like min/max the update takes logarithmic time.
            </summary>
            <remarks>
              We use a factory design for the generation of lazy expressions, which 
              is more natural. Another advantage is that we should (but have not yet)
              cache terms that are created twice, allowing a more efficient
              representation of the expression.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.#ctor">
            <summary>
              New scheduler; 
              Schedulable events must then be registered to it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Recompute">
            <summary>
              Recomputes the value of all lazy functions registered to the
              evaluator.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Atom(System.Double)">
            <summary>
              Returns a lazy expression that has the specified initial value.
              This value can be modified by accessing its Value property.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Constant(System.Double)">
            <summary>
              Returns a lazy expression that has the specified initial value.
              The expression is not meant to be modified
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Sum(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the sum
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Sum(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the sum
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Minus(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the difference
              between two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Minus(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the opposite
              of a lazy expression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Product(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the product
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Product(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the product
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Division(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the quotient
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Division(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the quotient
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Log(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the (natural,
              base E) logarithm of a lazy expression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Exp(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the (natural,
              base E) exponent of a lazy expression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Square(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the square
              of a lazy expression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Sqrt(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the square root
              of a lazy expression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Inverse(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the inverse
              of a lazy expression x (i.e. 1/x)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Min(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the max
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Max(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the max
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Max(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Returns a lazy expression representing the max of a list of lazy
              expressions (the expression will be balanced for optimal evaluation)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Min(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Returns a lazy expression representing the min of a list of lazy
              expressions (the expression will be balanced for optimal evaluation)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Sum(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Returns a lazy expression representing the sum of a list
              of lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Average(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Returns a lazy expression representing the average of a list
              of lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.IsEmpty">
            <summary>
              True if queue empty, i.e. nothing is scheduled.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Register(Microsoft.SolverFoundation.Solvers.LazyExpression)">
             <summary>
               Signals to the scheduler that a new function depends upon it.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Reschedule(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              Signals to the scheduler that part of a function is modified 
              and will require re-computation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyEvaluator.ConstructBalancedExpression(Microsoft.SolverFoundation.Solvers.LazyEvaluator.CommutativeAssociativeOperation,System.Collections.Generic.List{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Creates an expression that is binary balanced. Allows 
              lazy re-evaluation to take place in log time when the 
              function is well-chosen.
            </summary>
            <param name="op">the binary operator</param>
            <param name="l">the argument list</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyEvaluator.CommutativeAssociativeOperation">
            <summary>
              A commutative and associative binary operation
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyEvaluator.Info">
            <summary>
              When we enqueue a Lazy function we also record the value
              it has before it was modified; so the queue contains pairs
              function / old value.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyExpression">
            <summary>
              A numerical (real-valued) expression whose value can be re-evaluated
              in a lazy (i.e. incremental) way on demand by calling the lazy
              evaluator it connects to.
              Delegates can also subscribe to the exspression in order to be
              notified every time its value changes.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,System.Double,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Construction of a Lazy Expression
            </summary>
            <param name="s">evaluator the expression depends on</param>
            <param name="initialValue">initial value</param>
            <param name="args">sub-expressions of the expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.Subscribe(Microsoft.SolverFoundation.Solvers.LazyExpression.Listener)">
             <summary>
               Signals to the expression that a delegate should be called
               whenever its value is modified.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.DispatchChange(System.Double)">
            <summary>
              Notifies all listeners that have subscribed to the expression
              that its value is modified.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.GetEvaluator">
            <summary>
              get the evaluator to which the expression is registered
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.ComputeMaxDepth(Microsoft.SolverFoundation.Solvers.LazyEvaluator,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Initialization method (also checks a few pre-conditions)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Addition(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the sum
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Addition(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the sum
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Addition(System.Double,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the sum
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Subtraction(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the difference
              between two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Subtraction(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the difference
              between a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_UnaryNegation(Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the opposite
              of a lazy expression (i.e. -x)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Multiply(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the product
              of two lazy expressions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Multiply(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the product
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Multiply(System.Double,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the product
              of a lazy expression and a constant
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Division(Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              returns a lazy expression representing the division
              of a lazy expression by another LazyExpression
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExpression.op_Division(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              returns a lazy expression representing the division
              of a lazy expression by another LazyExpression
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LazyExpression.Value">
            <summary>
              Get the value of the expression. 
              Derived classes can also set this value, in which case the change
              is signaled to the evaluator.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LazyExpression.Depth">
            <summary>
              Depth of the expression (atoms have depth 0, an expression's depth
              is otherwise one unit more than its deepest child
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LazyExpression.IsScheduled">
            <summary>
              True if the function is scheduled for re-evaluation
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyExpression.Listener">
            <summary>
              Delegates for the methods that need to be called when the
              value of a lazy expression is changed.
            </summary>
            <param name="arg">expression that has changed</param>
            <param name="change">
              difference between the current value of the expression
              and its value when the last re-evaluation took place.
            </param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyValue">
            <summary>
             A real value to which delegates can be registered in order to be
             called when the value is modified. The value is attached to a 
             lazy evaluator; running (method Recompute) the evaluator will cause any
             delegate subscribed to the value to be called.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyValue.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,System.Double)">
            <summary>
              Construction of a lazy value
            </summary>
            <param name="s">evaluator to which the value is connected</param>
            <param name="initialValue">initial value</param>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LazyValue.Value">
            <summary>
              Get / set the value of the object. Setting the value
              will inform the lazy evaluator that it has to inform any 
              subscribed delegate of the change
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyListExpression">
            <summary>
              Lazy expressions that depend on arbitrarily many sub expressions.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyListExpression.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,System.Double,System.Collections.Generic.List{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Construction
            </summary>
            <param name="args">sub expressions</param>
            <param name="initialValue">initial value</param>
            <param name="eval">evaluator to which expression is connected</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazySum">
            <summary>
              Sum of several lazy expressions, maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazySum.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,System.Collections.Generic.List{Microsoft.SolverFoundation.Solvers.LazyExpression})">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="args">list of sub-expressions</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazySum.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyProduct">
            <summary>
              Product of two lazy expressions; maintained incrementally
            </summary>
            <remarks>
              We do not provide a version with n arguments; n > 2, mainly because
              this can grow very big. Typically if a product over n terms needs 
              be estimated, its log will be used, in which case we end-up using an
              n-ary incremental sum.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyProduct.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg1">first sub epxression</param>
            <param name="arg2">second sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyProduct.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyMinus">
            <summary>
              Product of two lazy expressions; maintained incrementally
            </summary>
            <remarks>
              We do not provide a version with n arguments; n > 2, mainly because
              this can grow very big. Typically if a product over n terms needs 
              be estimated, its log will be used, in which case we end-up using an
              n-ary incremental sum.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMinus.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg1">first sub epxression</param>
            <param name="arg2">second sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMinus.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyDivision">
            <summary>
              Division between two lazy expressions; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyDivision.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg1">first sub epxression</param>
            <param name="arg2">second sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyDivision.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyProductByConstant">
            <summary>
              Product of a lazy expression by a constant. Maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyProductByConstant.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">first sub epxression</param>
            <param name="cst">coefficient</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyProductByConstant.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyDivisionByConstant">
            <summary>
              Quotient of a lazy expression by a constant. Maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyDivisionByConstant.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">first sub epxression</param>
            <param name="cst">coefficient</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyDivisionByConstant.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyLog">
            <summary>
              Natural logarithm (base E) of a lazy expression,
              maintained incrementally.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyLog.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyLog.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyExp">
            <summary>
              Exponent (in base E) of a lazy expression; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExp.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub term</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyExp.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyInverse">
            <summary>
              Inverse (1/x) of a lazy expression x ; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyInverse.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub term</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyInverse.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazySquare">
            <summary>
              Square of a lazy expression; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazySquare.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub term</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazySquare.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyRoot">
            <summary>
              Squared root of a lazy expression; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyRoot.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub term</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyRoot.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyOpposite">
            <summary>
              Opposite of a lazy expression; maintained incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyOpposite.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg">sub term</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyOpposite.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in the subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyMin">
            <summary>
              Min of two lazy expressions; computed incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMin.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg1">first sub epxression</param>
            <param name="arg2">second sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMin.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LazyMax">
            <summary>
              Max of two lazy expressions; computed incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMax.#ctor(Microsoft.SolverFoundation.Solvers.LazyEvaluator,Microsoft.SolverFoundation.Solvers.LazyExpression,Microsoft.SolverFoundation.Solvers.LazyExpression)">
            <summary>
              Construction 
            </summary>
            <param name="eval">evaluator to which expression is connected</param>
            <param name="arg1">first sub epxression</param>
            <param name="arg2">second sub expression</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LazyMax.WhenInputModified(Microsoft.SolverFoundation.Solvers.LazyExpression,System.Double)">
            <summary>
              method called when a change occurs in one subterm.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimpleAnalyser">
            <summary>
              A simple type of analyser for Disolver Terms.
              Does top-down syntax-driven analyses
            </summary>
            <remarks>
              Propagates terms that are true because constraints are stated
              as Boolean expressions "forced" to true
              Also, collects the terms that would potentially benefit from a sparse
              (bit-vector) representation. These are the terms that are touched by
              a non-convex constraint (i.e. difference, table).
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleAnalyser.Apply(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm})">
            <summary>
              Analyses the constraints of the problem, setting some Boolean
              Terms to true.
            </summary>
            <param name="trueterms">
              The constraints of the problem; 
              i.e. the terms that are forced to true
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleAnalyser.Run">
            <summary>
              Performs the top-down analysis
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleAnalyser.ProcessAnd(Microsoft.SolverFoundation.Solvers.DisolverAnd)">
            <summary>
              For conjunctions we propagate truth downwards
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleAnalyser.ProcessOr(Microsoft.SolverFoundation.Solvers.DisolverOr)">
            <summary>
              For disjunction we propagate falsity downwards
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimpleAnalyser.ProcessNot(Microsoft.SolverFoundation.Solvers.DisolverNot)">
             <summary>
               For negation we propagate downwards the truth value, reverted.
             </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompilerToProblem">
            <summary>
              An algorithm that creates a Core.Problem from the
              syntactical description of the terms
            </summary>
             
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.Apply(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.CspSearchStrategy,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm},System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm})">
            <summary>
               Main static function to use for compilation
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.InitializeSwitch">
            <summary>
              Create the dictionary associating actions 
              to each type of term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileBooleanVariables(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm})">
            <summary>
              Associates a BooleanVariable to every Boolean Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileConstraints(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm})">
            <summary>
              Compiles constraints for each term.
              These constraints will connect the variables representing
              the term and the variables representing its subterms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileIntegerVariables(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm})">
            <summary>
              Associates an IntegerVariable to every Integer Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileVariableValuePairs">
            <summary>
              Does the final compiling steps needed for the 
              variable/value pairs created and cached during the 
              compilation process.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileBooleanSumGreaterEqual(Microsoft.SolverFoundation.Solvers.BooleanVariable[],System.Int32,Microsoft.SolverFoundation.Solvers.BooleanVariable)">
            <summary>
              Compiles a pseudo-Boolean constraint imposing that result be
              true IFF the number of Boolean vars that are true is larger
              than the number.
              Warning: ownership of the array is transferred.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CompileBooleanSumEquals(Microsoft.SolverFoundation.Solvers.BooleanVariable[],System.Int32,Microsoft.SolverFoundation.Solvers.BooleanVariable)">
            <summary>
              Compiles a pseudo-Boolean constraint imposing that result be
              true IFF the number of Boolean vars that are true equals the number.
              Warning: ownership of the array is transferred.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.CreateDisjunction(System.Collections.Generic.List{Microsoft.SolverFoundation.Solvers.BooleanVariable})">
            <summary>
              Creates a BooleanVariable that represents the disjunction
              of a list of Boolean terms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.GetEquality(Microsoft.SolverFoundation.Solvers.IntegerVariable,System.Int64)">
            <summary>
              Gets a Boolean variable representing between a variable and a
              constant. This is optimized (cached and values for a variable
              are groupped) and should be used and abused whenever there is
              need for a leightweight form of watching.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompilerToProblem.GetEquality(Microsoft.SolverFoundation.Solvers.IntegerVariable,Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Gets a Boolean variable representing the equality
              between two variables.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompilerToProblem._variableValuePairs">
            <summary>
              whenever a term x = i is created we cache it. This allows
              two optimizations: (1) obviously sharing a variable
              representing the same logical expression; (2) we can
              optimize the compilation of these equalities. 
              This way we feel free to use and abuse them within the
              compilation process.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Problem">
            <summary>
              A Problem, as manipulated internally by backtrack search algorithms.
            </summary>
            <remarks>
              Every problem is meant to be used by a tree-search algorithm and
              cannot be shared. We've been considering to merge the two classes. 
              Why not; however: chronologically in the resolution process the
              problem is created first, only when completed are we in a position
              to really construct the tree search - so a unique class would require
              several steps: construction; addition of problem elements like
              variables and constraints; then a call to CreateAlgorithm(strategy).
              Also: one advantage of decoupling is that potentially we can use
              a treesearch algorithm on one problem THEN (sequentially, not in
              parallel) discard it and use a new treesearch
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.CompilerToProblem,System.Boolean)">
             <summary>
               Construction, given a model (Disolver.Problem).
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateBooleanVariable(Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm)">
            <summary>
              Adds a new Boolean variable to the problem and returns it.
            </summary>
            <param name="src">model variable from which we derive</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetBooleanTrue">
            <summary>
              Gets the pre-allocated boolean variable 
              for constant true
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetBooleanFalse">
            <summary>
              Gets the pre-allocated boolean variable 
              for constant false
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateInternalBooleanVariable">
            <summary>
              Construction (for internal use) of a Boolean variable that 
              does not correspond to a term in the initial problem.
              Its initial state is unassigned.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateInternalBooleanVariableArray(System.Int32)">
            <summary>
              Construction (for internal use) of an array of Boolean variables
              that do not correspond to a term in the initial problem.
              Their initial state is unassigned.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateIntegerVariable(Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm)">
             <summary>
               Adds a new Integer variable to the problem and returns it.
             </summary>
             <param name="src">model variable from which we derive</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateInternalIntegerVariable(System.Int64,System.Int64)">
            <summary>
              Construction (for internal use) of an integer variable that 
              does not correspond to a term in the initial problem
            </summary>
            <param name="l">initial lower bound</param>
            <param name="r">initial upper bound</param>
            <returns></returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.CreateInternalIntegerVariable">
            <summary>
              Construction (for internal use) of an integer variable that 
              does not correspond to a term in the initial problem.
              Its range will be fixed to default.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetIntegerConstant(System.Int64)">
            <summary>
              Gets the Integer variable representing s constant.
              (cached: we create one variable per constant)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Associate(Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm,Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Informs the problem that the image if an integer term
              is a certain integer variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Associate(Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm,Microsoft.SolverFoundation.Solvers.BooleanVariable)">
            <summary>
              Informs the problem that the image if a Boolean term
              is a certain Boolean variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.AddConstraint(Microsoft.SolverFoundation.Solvers.DisolverConstraint)">
             <summary>
               Add a new constraint to the problem
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Save">
            <summary>
              Save the problem, so that any modification to it can be
              undone (in a LIFO fashion) by a call to Restore.
            </summary>
            <remarks>
              The discipline we impose for event handling and scheduling
              here is the following: the scheduler must systematically
              be empty when we save, it must be empty when we restore.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Restore">
            <summary>
              Restore the problem, i.e. go back to the state it was in
              before the last Save operation.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Simplify">
            <summary>
              Performs simplifcations (propagation) to the problem.
            </summary>
            <returns>
              False if inconsistency detected
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.InitialSimplifications">
             <summary>
               Performs initial simplifications (propagation) to the problem.
             </summary>
             <returns>
               False if inconsistency detected
             </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToConflicts(Microsoft.SolverFoundation.Solvers.Procedure{Microsoft.SolverFoundation.Solvers.Cause})">
             <summary>
               The listener will be immediately called when there is a conflict
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToProblemSaved(Microsoft.SolverFoundation.Solvers.ParameterlessProcedure)">
            <summary>
              The listener will be immediately called when the problem is saved
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToProblemRestored(Microsoft.SolverFoundation.Solvers.ParameterlessProcedure)">
            <summary>
              The listener will be immediately called when the problem is restored
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToVariableRestored(Microsoft.SolverFoundation.Solvers.Procedure{Microsoft.SolverFoundation.Solvers.DiscreteVariable})">
            <summary>
            The listener will be immediately called when any variable is restored
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToVariableUninstantiated(Microsoft.SolverFoundation.Solvers.Procedure{Microsoft.SolverFoundation.Solvers.DiscreteVariable})">
            <summary>
            The listener will be called when an instantiated variable is restored
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToVariablePropagated(Microsoft.SolverFoundation.Solvers.Procedure{Microsoft.SolverFoundation.Solvers.DiscreteVariable})">
            <summary>
              The listener will be called every time propagation is finished, 
              for each variable that has been modified
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToVariableModification(Microsoft.SolverFoundation.Solvers.VariableModification.Listener)">
            <summary>
              The listener will be called immediately whenever any variable is
              modified by the propagation process.
            </summary>
            <remarks>
              Use sparingly as this would be called very often; use for 
              explanations that require very fine-grained trace of solver
              deductions.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToSolutionFound(Microsoft.SolverFoundation.Solvers.ParameterlessProcedure)">
            <summary>
              The listener will be called whenever a solution is completed
              (useful essentially for assertions)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SubscribeToInitialPropagation(Microsoft.SolverFoundation.Solvers.BasicEvent.Listener)">
            <summary>
              The listener will be called during the propagation loop
              that is started before the first search node. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SignalFailure(Microsoft.SolverFoundation.Solvers.DiscreteVariable,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Called whenever a variable becomes inconsistent;
              used essentially to keep track of causes.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SignalBooleanVariableInstantiation(Microsoft.SolverFoundation.Solvers.BooleanVariable,Microsoft.SolverFoundation.Solvers.Cause)">
             <summary>
               Called by a Boolean Variable to notify the problem
               that it has just been instantiated - this causes
               a save of the var and a dispatch to all listeners
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Save(Microsoft.SolverFoundation.Solvers.IntegerVariable)">
            <summary>
              Called by integer variable to notify the problem
              that its domain is about to be narrowed. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.DispatchVariableModification(Microsoft.SolverFoundation.Solvers.IntegerVariable,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Called by integer variable to inform anyone
              interested that the variable has been modified
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.RestoreBooleanVariables">
            <summary>
              Unistantiates all Boolean variables instantiated at
              current level
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.RestoreIntegerVariables">
            <summary>
              Undoes all modifications made to the Boolean
              variables at the current level.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetImplicationGraph">
            <summary>
              Get the implication graph associated to the problem
            </summary>
            <remarks>
              The implication graph is only constructed for heuristics
              that explictly need it. This is determined at construction
              of the problem and there is a switch to update in 
              CompilerToProblem for nay new Heuristic that needs it.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.IsUserDefined(Microsoft.SolverFoundation.Solvers.DiscreteVariable)">
            <summary>
              True iff the variable is user-defined
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetImage(Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm)">
            <summary>
              Get the Boolean Variable representing an original 
              Boolean Term in this problem
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetImage(Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm)">
            <summary>
              Get the Integer Variable representing an original 
              Integer Term in this problem
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.GetSolution">
            <summary>
              Creates a dictionary from terms to ints
              representing a solution
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.EndCompilation">
            <summary>
              Called by compiler when compilation finished so that
              handle is freed and compiler can be GC-ed.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.AddFalsity">
            <summary>
              Adds a constraint that will cause inconsistency
              when the first propagation is started. Use to signal
              inconsistency during e.g. pre-processing or construction
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.ComputeStatistics(System.IO.TextWriter,Microsoft.SolverFoundation.Solvers.TreeSearchStatistics@)">
            <summary>
              Computes statistics on the problem in a given output
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.Shave">
            <summary>
              naive implementation of a leightweight form
              of singleton-arc consistency
            </summary>
            <returns>false iff inconsistency found</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Problem.SampleVariable(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Int64,System.Int64)">
            <summary>
            
              If we impose that variable x range within [lb, ub] and propagate,
              do we obtain a contradiction?
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Depth">
            <summary>
              Number of saves done on the problem, 
              used by backtrackable datastructures
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.UseExplanations">
            <summary>
              True if the problem requires to use explanations
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Scheduler">
            <summary>
              Access to the scheduler in which all events (e.g. variable
              state modifications) related to the problem will be stored
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.IntTrail">
            <summary>
              A trail to which any backtrackable int used in this problem
              should be connected to
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Longtrail">
            <summary>
              A trail to which any backtrackable long used in this problem
              should be connected to
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.IntegerTrail">
            <summary>
              A trail to which any backtrackable Integer used in this problem
              should be connected to
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.IntSetTrail">
            <summary>
              A trail to which any backtrackable int set used in this problem
              should be connected to
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.DomainTrail">
            <summary>
              A trail to which any backtrackable domain used in this problem
              should be connected to
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.UserDefinedVariables">
            <summary>
              Gets the set of discrete variables (Boolean and integer)
              defined explicitly by the user when she stated the problem.
              The variables will be returned in the order they were declared.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.DiscreteVariables">
            <summary>
              Gets the set of all discrete variables, user-defined
              or generated internally (Boolean and integer)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Constraints">
            <summary>
              Get set of all constraints in the problem
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Source">
            <summary>
              Gets the model (class Solver) from which this Problem
              was constructed
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.ConstraintCountByType">
            <summary>
              Returns a dictionary keeping the number of occurrences of
              each type of constraint
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Compiler">
            <summary>
              handle to the compiler of the problem; available only
              during the compilation process; null afterwards.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Problem.Inconsistent">
            <summary>
              True if the problem has been proved inconsistent before
              any propagation or between propagations - e.g. preprocessing
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Problem.IntegerVariableArchive">
            <summary>
              Data that are stored when the bounds of an integer variable
              are modified
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Scheduler">
            <summary>
              Scheduler, responsible for propagating Disolver events.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.#ctor(Microsoft.SolverFoundation.Solvers.ParameterlessProcedure)">
            <summary>
              New scheduler; 
              Schedulable events must then be registered to it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.#ctor">
            <summary>
              New scheduler; 
              Schedulable events must then be registered to it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.Activate">
            <summary>
              Activates the scheduler, i.e. activates all scheduled events.
            </summary>
            <remarks>
              Post-condition is that the queue be systematically emptied
              when we return.
            </remarks>
            <returns>false iff failure detected at any step</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.UnScheduleAll">
            <summary>
              Unschedule all events
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.IsEmpty">
            <summary>
              True if queue empty in the sense nothing scheduled.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.RegisterSchedulableEvent(Microsoft.SolverFoundation.Solvers.AbstractEvent)">
             <summary>
               Called at creation time by abstract events to make sure the
               scheduler is aware of their creation
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.Reschedule(Microsoft.SolverFoundation.Solvers.AbstractEvent)">
             <summary>
               Enqueue the event in the scheduler. The caller is 
               responsible for checking that the event is not already scheduled
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.FastAllocatedIntervalList">
             <summary>
               ValuesRemovedEvents need a lot of creation of temporary
               int vectors. To avoid newing (and garbage-collecting) them 
               repeatedly we share a pre-allocated one in scheduler. 
               The discipline should be to use it (non concurrently) and
               Clear it as soon as exiting when block is left.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Scheduler.Unschedule(Microsoft.SolverFoundation.Solvers.AbstractEvent)">
            <summary>
              Unschedules an event
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Scheduler.NbEventsActivated">
            <summary>
              Returns the number of events activated during the lifetime of 
              the scheduler.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AbstractEvent">
             <summary>
               Event that is registered to a scheduler so that it can be rescheduled,
               which means that the scheduler will activate it later.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.#ctor(Microsoft.SolverFoundation.Solvers.Scheduler)">
            <summary>
              Construction. All Schedulable events must be attached to
              one scheduler. Initially the event is not scheduled.
            </summary>
            <param name="scheduler">
              Scheduler to which event will be associated
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.Activate">
             <summary>
               Code to execute when the event is activated;
               Main method defined by derived classes  
             </summary>
             <returns>false iff failure</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.RescheduleIfNeeded">
             <summary>
               Reschedule the event; i.e. it will be activated later by the
               scheduler. This operation has no effect if the event is already
               scheduled.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.RescheduleIfNeededBool">
             <summary>
               Reschedule the event; i.e. it will be activated later by the
               scheduler. This operation has no effect if the event is already
               scheduled.
             </summary>
             <remarks>HACK</remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.UnscheduleDueToFailure">
            <summary>
              Called by the scheduler when a failure arises while the 
              event is still in the queue. This may require to clean-up some
              stuff in the state of the event
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AbstractEvent.IsScheduled">
            <summary>
              True iff the event is already currently scheduled.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BasicEvent">
             <summary>
               Events that are scheduled when something happens to a variable.
               Listeners can subscribe to this event so that when the event
               is activated by the scheduler, the listener is called.
               By "Basic we mean that no extra information is dispatched to the
               listeners, just the event.
             </summary>
             <remarks>
               No information attached. This way we decouple the event from any
               particular detail (i.e. useable for events related to bools, ints
               reals, whatever).
             </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicEvent.#ctor(Microsoft.SolverFoundation.Solvers.Scheduler)">
            <summary>
              Construction
            </summary>
            <param name="s">the scheduler to which the event is connected</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicEvent.Subscribe(Microsoft.SolverFoundation.Solvers.BasicEvent.Listener)">
            <summary>
              Subscribes a listener to the event.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicEvent.Activate">
             <summary>
               Method called when scheduler activates the event.
               What it does is to dispatch the call to all subscribed listeners.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BasicEvent.EnumerateListeners">
            <summary>
              Goes through all listeners subscribed to the event
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BasicEvent.Listener">
            <summary>
              delegates that can subcribe to the event
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.AnnotatedListener`1">
            <summary>
              Listeners that are annotated with an extra bit of information
              that is systematically passed to delegates that subscribe to it
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AnnotatedListener`1.Generate(`0,Microsoft.SolverFoundation.Solvers.AnnotatedListener{`0}.Listener)">
            <summary>
              Generates a listener that, when called, will pass
              parameter c to the annotated listener l
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics">
            <summary>
              Statistics on the work done by a tree-search algorithm
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.TotalNbEvents">
            <summary>
              Number of events generated during whole search
              (one event corresponds to several delegate calls)
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.TotalNbNodes">
            <summary>
              Number of nodes explored in the search tree
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbNodesFirstSolution">
            <summary>
              Number of nodes explored until reaching 1st solution
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbFails">
            <summary>
              Number of failures, i.e. leafs of the search tree
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbRestarts">
            <summary>
              Number of restarts, i.e. times a tree was thrown away
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.TimeToFirstSolution">
            <summary>
              Time in Milliseconds to the first solution
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.TimeToLastSolution">
            <summary>
              Time in Milliseconds to the last solution
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbConstraints">
            <summary>
              Number of constraints in the compiled representation of the problem
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbBooleanVariables">
            <summary>
              Total number of Boolean variables 
              in the compiled representation of the problem
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbIntegerVariables">
            <summary>
              Total number of integer variables 
              in the compiled representation of the problem
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbUserDefinedBooleanVariables">
            <summary>
              Number of user-defined Boolean variables 
              in the compiled representation of the problem
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchStatistics.NbUserDefinedIntegerVariables">
            <summary>
              Number of user-defined integer variables 
              in the compiled representation of the problem
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IntegerSolver">
            <summary>
              Main class for creating and solving problems using Disolver.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.#ctor(System.Func{System.Boolean})">
             <summary>
               Construction
             </summary>
             <param name="abort">call back for search interruption</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.#ctor">
            <summary>
              Default constructor.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.#ctor(Microsoft.SolverFoundation.Solvers.ConstraintSystem,System.Func{System.Boolean})">
            <summary>
              Construction by copy of an initial solver
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.AddTerm(Microsoft.SolverFoundation.Solvers.DisolverTerm)">
             <summary>
                Call implicitly any time a Term is created 
                - do not call anywhere else.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.AddBooleanTerm(Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm)">
            <summary>
              Call implicitly any time a Boolean Term is created
              - do not call anywhere else.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.AddIntegerTerm(Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm)">
             <summary>
               Call implicitly any time a Integer Term is created
               - do not call anywhere else.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Constant(System.Int64)">
            <summary>
              Creation of a term representing an integer constant
            </summary>
            <param name="k">constant</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateVariable(Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
              Creates a variable with the given domain and 
              an auto-generated key
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateVariable(System.String)">
            <summary>
              creates a variable with the default range and
              a key of type string
            </summary>
            <remarks>
              This method is essentially for backward compatibility;
              we have old versions 
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateVariable(Microsoft.SolverFoundation.Solvers.CspDomain,System.Object)">
            <summary>
              Create an integer variable ranging over the
              indicated domain. 
            </summary>
            <param name="domain">initial domain</param>
            <param name="key">key by which the variable is designated</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateBoolean">
            <summary>
              Creates a Boolean variable with an auto-generated key
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateBoolean(System.Object)">
             <summary>
               Creates a Boolean variable
             </summary>
             <param name="key">key by which the variable is designated</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.RecordKey(System.Object,Microsoft.SolverFoundation.Solvers.DisolverTerm)">
            <summary>
              method aimed at being used exclusively by DisolverTerms;
              whenever a term receives a key (at creation time or by direct use
              of the Key property), this ensures that necessary updates are done.
              the "_named" fields should not be taken care of anywhere else.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateVariableVector(Microsoft.SolverFoundation.Solvers.CspDomain,System.String,System.Int32)">
            <summary>
              Creates an array of variables with homogeneous domains
            </summary>
            <param name="dom">domain, common to all variables</param>
            <param name="name">
              name of the array; each position will be given a 
              name of the form "name[0]", etc.
            </param>
            <param name="nb">size of the array</param>
            <returns></returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateVariableArray(Microsoft.SolverFoundation.Solvers.CspDomain,System.String,System.Int32,System.Int32)">
            <summary>
              Creates a bi-dimensional array of variables of homogeneous domains
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateBooleanVector(System.String,System.Int32)">
            <summary>
              Creates an array of Boolean variables
            </summary>
            <param name="name">
              name of the array; each position will be given a 
              name of the form "name[0]", etc.
            </param>
            <param name="nb">size of the array</param>
            <returns></returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateIntegerSet(System.Int32[])">
             <summary>
               Creates a domain described in extension by its
               set of values
             </summary>
             <param name="values">list of values in the domain</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateIntegerInterval(System.Int32,System.Int32)">
             <summary>
               Creates a domain described in extension by its
               bounds (the domain contains all values between these bounds)
             </summary>
             <param name="first">lower bound</param>
             <param name="last">upper bound</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CreateSymbolSet(System.String[])">
            <summary>
              Creates a domain whose values are symbols
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.TryGetVariableFromKey(System.Object,Microsoft.SolverFoundation.Solvers.CspTerm@)">
            <summary>
              get the term that has the corresponding key
            </summary>
            <param name="key">identifier of the term</param>
            <param name="term">resulting term</param>
            <returns>true iff the key is found</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Not(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Negation: term that is true if subterm is false
            </summary>
            <param name="input">subterm</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Or(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Disjunction: term that is true iff one of the subterms is
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Implies(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Logical implication (A implies B)
            </summary>
            <param name="antecedent">left-hand side of the implication</param>
            <param name="consequent">right-hand side of the implication</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.And(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary> 
              Conjunction: term that is true iff all the subterms are
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Equal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
             <summary>
               Term that is true if all subterms are equal
             </summary>
             <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Unequal(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Disequality: Term that is true iff subterms are all different
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.LessEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in non-strictly increasing
              fashion (each one less equal to follower in subterm list)
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Less(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in strictly increasing
              fashion (each one less strict to follower in subterm list)
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.GreaterEqual(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in non-strictly decreasing
              fashion (each one greater equal to follower in subterm list)
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Greater(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in strictly decreasing
              fashion (each one greater strict to follower in subterm list)
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Less(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in strictly increasing
              fashion (each one less strict to follower in subterm list)
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.LessEqual(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in non-strictly increasing
              fashion (each one less equal to follower in subterm list)
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Greater(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in strictly decreasing
              fashion (each one greater strict to follower in subterm list)
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.GreaterEqual(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term that is true if subterms are ordered in non-strictly decreasing
              fashion (each one greater equal to follower in subterm list)
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Equal(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Equality: Term that is true iff subterms are all equal
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Unequal(System.Int64,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Disequality: Term that is true iff subterms are all different
            </summary>
            <param name="constant">first subterm</param>
            <param name="inputs">list of other subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Min(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term representing the minimum of a list of subterms
            </summary>
            <param name="args">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Max(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Term representing the maximum of a list of subterms
            </summary>
            <param name="args">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Member(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspDomain)">
            <summary>
              Term that is true iff a variable belongs to a
              certain domain of values
            </summary>
            <param name="x">the variable</param>
            <param name="d">the set of values</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.IfThenElse(Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Term representing the construct "cond ? a : b" of the
              C language. 
            </summary>
            <param name="condition">Boolean Term for the condition</param>
            <param name="ifValue">value returned if condition true</param>
            <param name="elseValue">value returned if condition false</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ExactlyMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Boolean Term that has a list of Boolean subterms and that is true
              iff the exact indicated number of them are true
            </summary>
            <param name="m">number of subterms that should be true</param>
            <param name="inputs">list of Boolean subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.AtMostMofN(System.Int32,Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Boolean Term that has a list of Boolean subterms and that is true
              iff at most the indicated number of them are true
            </summary>
            <param name="m">maximum number of true subterms</param>
            <param name="inputs">list of Boolean subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Abs(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Term representing the absolute value of a term
            </summary>
            <param name="input">unique subterm</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Neg(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Opposite (beware the confusing name!!!): 
              Term representing the opposite of an integer term x, 
              i.e.  -x
            </summary>
            <param name="input">unique subterm</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Power(Microsoft.SolverFoundation.Solvers.CspTerm,System.Int32)">
            <summary>
              Term representing the result of raising the input
              term to the given power
            </summary>
            <param name="x">unique subterm</param>
            <param name="power">power, i.e. exponent</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Sum(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Addition: term representing the sum of its subterms
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.SumProduct(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Given two vectors of subterms of identical size, the created 
              term represents the sum of the pairwise products of these
              terms, i.e. inputs1[0]*inputs2[0] + inputs1[1]*inputs2[1] + ...
            </summary>
            <param name="inputs1">first vector of subterms</param>
            <param name="inputs2">second vector of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.FilteredSum(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Given a vector of Boolean terms and a vector of integer terms
              of identical size, creates a term representing the sum of 
              the integer terms for every position where the corresponding
              Boolean term is true. This is equivalent to a SumProduct 
              where the Boolean is considered as a 0/1 value, i.e.
              conditions[0]*inputs[0] + conditions[1]*inputs[1] + ...
            </summary>
            <param name="conditions">list of conditions</param>
            <param name="inputs">list of integer terms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Product(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Product: term representing the multiplication of all subterms
            </summary>
            <param name="inputs">list of subterms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Given an array of terms T and a term I used for index, 
              creates a term representing T[i], i.e. the value of the term will
              be the value of the subterm contained at the position given by the
              value of the index term.
            </summary>
            <param name="inputs">array</param>
            <param name="index">term whose value will give the index</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Index(Microsoft.SolverFoundation.Solvers.CspTerm[][],Microsoft.SolverFoundation.Solvers.CspTerm,Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Given a matrix of terms T and 2 terms I and J used for index, 
              creates a term representing T[i][j], i.e. the value of the term 
              will be the value of the subterm contained at the position given 
              by the pair of values of the index terms.
            </summary>
            <param name="inputs">matrix</param>
            <param name="row">first index</param>
            <param name="column">second index</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Index(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              The only form of indexing we export is with
              one index, 0-based
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.TableInteger(Microsoft.SolverFoundation.Solvers.CspTerm[],System.Int32[][])">
            <summary>
              Creates a Term that is true if the tuple of values for
              colVars can be found in the array of integer tuples
              given in extension as second argument
            </summary>
            <param name="colVars">tuple of terms</param>
            <param name="inputs">
              list of integer tuples, each of which specifies an
              allowed combination for the tuple of Terms
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.TableTerm(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspTerm[][])">
            <summary>
              Table containing elements that can be arbitrary complex terms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.TableDomain(Microsoft.SolverFoundation.Solvers.CspTerm[],Microsoft.SolverFoundation.Solvers.CspDomain[][])">
            <summary>
              Table containing elements that can be arbitrary complex sets of values
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.AddConstraints(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Adds constraint to the problem; each of these constraints is
              a Boolean Term, adding it has a constraint will force it to be
              true in any solution
            </summary>
            <param name="constraints">list of Boolean Terms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.TryAddMinimizationGoals(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Adds minimization goals. The solver will try to optimize these
              goals in lexicographic order, i.e. the first objective is
              minimized, then for equal values of this first objective, a 
              minimal value of the second objective is seeked, etc.
            </summary>
            <param name="goals">list of integer terms</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.EnumerateAndImprove">
            <summary>
            Enumerate the solutions of the problem; 
            if the problem has minimization goals then every time a solution
            is found we restrict the search to strictly improved solutions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.EnumerateInterimSolutions">
            <summary>
            Enumerate the solutions of the problem in an any-time 
            fashion: Solutions are returned as they are found, before global 
            optimality is reached.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.EnumerateSolutions">
            <summary>
            Proves optimality and enumerates all globally optimal solutions
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Search(Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm)">
            <summary>
            Enumeration of the solutions of a treeSearchAlgorithm 
            </summary>
            <remarks>
            Factors code in several solution enumeration methods
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.IsSameSolution(System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,System.Object},System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,System.Object})">
            <summary>Are the two solutions the same? </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.FixObjectives(System.Collections.Generic.Dictionary{Microsoft.SolverFoundation.Solvers.CspTerm,System.Object})">
            <summary>
            Constrains the objectives to be equal to a given
            (usually, optimal) solution
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.CheckAbortion">
            <summary>
              Checks if an abortion condition has been met and
              if so throws an exception
            </summary>
            <remarks>
              other solution is method returning bool but then caller
              is responsible for setting abortion flag and interrputing
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.UnionDomain(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm})">
            <summary>
              Computes the union of the intervals of values for all
              the elements in the enumeration
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.UnionDomain(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.DisolverTerm}})">
            <summary>
              Computes the union of the intervals of values for all
              the elements in the enumeration
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToBooleanTerm(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Down-casting of a Boolean Term.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToBooleanTermArray(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Down-casting of an array of Boolean Terms.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToIntegerTerm(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Down-casting of an integer Term.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToIntegerTermArray(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Down-casting of an array of Integer terms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToDisolverTerm(Microsoft.SolverFoundation.Solvers.CspTerm)">
            <summary>
              Down-casting of a Disolver Term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ToDisolverTermArray(Microsoft.SolverFoundation.Solvers.CspTerm[])">
             <summary>
               Down-casting of an array of Disolver Terms (used in cases
               where they can be a mix of Boolean/integer terms)
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.ReversedTermArray(Microsoft.SolverFoundation.Solvers.CspTerm[])">
            <summary>
              Down-casting, but reversing the order
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerSolver.Compile">
            <summary>
              Creates a fresh internal representation of the problem as
              used by backtrack search algorithms
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._watch">
            <summary>
              Time for resolution
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._verbose">
            <summary>
              If set to true, Disolver will regularly display info
            </summary>
            <remarks>
              Should use a stream in which to inject the comments instead
            </remarks>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._useshaving">
            <summary>
              If set to true, Disolver will use a preprocessing simplifying
              the problem by "singleton-arc-consistency"
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._treeSearchStatistics">
            <summary>
              Copy of the statistics produced by the last tree search
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._parameters">
            <summary>
              parameters of CspSolverBase root class
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._hasAborted">
            <summary>
              set to true when aborting 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._termMap">
            <summary>
            Term map that maps model terms to IntegerSolver terms. Created only when a clone ctor is called
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.IntegerSolver._baseModel">
            <summary>
            Stores the base model from which this IntegerSolver instance is cloned
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.False">
            <summary>
              Term representing the Boolean constant false   
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.True">
            <summary>
             Term representing the Boolean constant true   
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.DefaultInterval">
            <summary>
              Get the domain that variables take by default
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.AllTerms">
            <summary>
              enumerates all terms created by this solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.Variables">
            <summary>
              returns all variables of the problem
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.Constraints">
            <summary>
              returns all constraints of the problem
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.MinimizationGoals">
            <summary>
              returns all enumeration goals of the problem
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.HasMinimizationGoals">
            <summary>
              True of we are doing optimization, i.e. the 
              solver has at least one optimization goal
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.IsOptimizing">
            <summary>Does the problem have optimization goals? </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.ElapsedMilliSec">
            <summary>
              Gives time since current search was run
              (in general called during the search)
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.Verbose">
            <summary>
              Option saying whether the solver should display
              regular activity messages. Set or get.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.UseShaving">
            <summary>
              option saying whether shaving should be used
              as pre-process
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.HasAborted">
            <summary>
              True if solver has timed out
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.Statistics">
            <summary>
              Gets the statistics of the latest called tree-search.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.UseRestarts">
            <summary>
              Option telling the solver whether it should 
              diversify its search by restarting every now and then
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerSolver.Strategy">
             <summary>
               Search strategy of the solver - kept as string
               for simplicity
             </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverDecision">
            <summary>
              Struct representing the decisions that can be taken 
              during the search.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.AssignDiscreteVariable(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Int64)">
            <summary>
              Creates a decision that specifies to assign a discrete variable
              to a certain value. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.ImposeLowerBound(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Int64)">
             <summary>
               Creates a decision that specifies to tighten the lower bound of
               an integer variable.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.ImposeUpperBound(Microsoft.SolverFoundation.Solvers.DiscreteVariable,System.Int64)">
            <summary>
              Creates a decison that specifies to tighten the upper bound
              of an integer variable.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.SolutionFound">
            <summary>
              Creates a decision that specifies that search be stopped
              because a solution is found.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.Restart">
            <summary>
              Creates a decision that specifies to restart the search
              for diversification purposes.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DisolverDecision.ContextSwitch">
            <summary>
              creates a decision that specifies to undo all decisions
              because we'll switch to another heuristic
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DisolverDecision.Type">
            <summary>
              Flag giving the type of decision
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SearchStrategyFlag">
            <summary>
              Types of basic search strategies that can be used to parametrise
              the tree-search solver
            </summary>
            <remarks>
              So far there is little choice but we make it possible to have
              later strategies that would not be variable/value ordering heuristics
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VariableEnumerationStrategy">
            <summary>
              Types of Variable enumeration strategies
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ValueEnumerationStrategy">
            <summary>
              Types of Value enumeration strategies
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CspSearchStrategy">
            <summary>
              The description of the parameters used by the solver when constructing
              its strategy
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CspSearchStrategy.#ctor(Microsoft.SolverFoundation.Solvers.VariableEnumerationStrategy,Microsoft.SolverFoundation.Solvers.ValueEnumerationStrategy,System.Boolean)">
            <summary>
              Construction of a search strategy based on a variable/value
              ordering
            </summary>
            <param name="var">type of variable ordering</param>
            <param name="val">type of value ordering</param>
            <param name="restarts">true if restarts should be used</param>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm">
            <summary>
              Solver used for enumerating the solutions of a problem. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.CspSearchStrategy,Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm[],Microsoft.SolverFoundation.Solvers.ParameterlessProcedure)">
            <summary>
              Construction of a solver for optimization
              with list of minimization goals.
            </summary>
            <param name="s">FiniteSolver from which created</param>
            <param name="strat">the search strategy</param>
            <param name="goalsToMinimize">list of goals - can be null</param>
            <param name="stop">Predicate to call to interrupt execution</param>
            <param name="p">the problem</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.#ctor(Microsoft.SolverFoundation.Solvers.IntegerSolver,Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.CspSearchStrategy,Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm[],Microsoft.SolverFoundation.Solvers.ParameterlessProcedure,System.IO.TextWriter)">
            <summary>
              Construction of a Solver for optimization
              with list of minimization goals.
            </summary>
            <remarks>
              Should also have a means to parametrize the heuristics
            </remarks>
            <param name="s">FiniteSolver from which created</param>
            <param name="strat">the search strategy</param>
            <param name="goalsToMinimize">list of goals - can be null</param>
            <param name="stop">Predicate to call to interrupt execution</param>
            <param name="output">Stream in which to display info</param>
            <param name="p">the problem</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.GetHeuristic(Microsoft.SolverFoundation.Solvers.CspSearchStrategy)">
            <summary>
              Construction of the heuristic
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.GetValueSelector(Microsoft.SolverFoundation.Solvers.ValueEnumerationStrategy,System.Int32)">
            <summary>
              Construction of ValueSelector from 
              ValueEnumerationStrategy
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.GetVariableSelector(Microsoft.SolverFoundation.Solvers.VariableEnumerationStrategy,System.Int32)">
            <summary>
              Construction of Variable selector from 
              VariableEnumerationStrategy
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.FindFirstSolution">
            <summary>
              Method used to start the search. Starting from a fresh
              solver, goes to the first solution, if one exists.
            </summary>
            <returns>true iff a first solution is found</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.FindNextSolution">
            <summary>
              Method used to continue the search. Starting from a solver
              that is positioned on a solution, goes to another solution,
              if one exists.
            </summary>
            <returns>true if a next solution exists</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.ExtendToSolution">
            <summary>
              Starting from consistent (possibly empty) partial solution,
              extend it until full solution (return true)
              or inconsistency reached (return false)
            </summary>
            <returns>
              true iff solution found; 
              false iff dead-end (inconsistent leaf) reached
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.ImprovedSolution">
            <summary>
            Checks whether a newly found solution is strictly
            better than the best one found so far. Strictly 
            better means following a lexicographical order:
            objective 0 should be better or equal; if equal
            then objective 1 should be better or equal...
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Backtrack">
            <summary>
              starting from an inconsistent branch,
              undoes all assignments until a "lexicographically"
              higher one that does not look inconsistent is found
              (return true) or levels empty (return false)
            </summary>
            <returns>
              true if we managed to restore a consistent point
              false if not and we have exhausted the stack
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.TryChoice(Microsoft.SolverFoundation.Solvers.DisolverDecision)">
            <summary>
              Tries to make and propagate a choice;
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Perform(Microsoft.SolverFoundation.Solvers.DisolverDecision,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Performs a bound decision and propagates it
              (also taking into account the best-known bounds if we
              are optimising)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.RefuteLastLevel">
            <summary>
              Imposes the negation of a decision and propagate it.
              The decision must be a bound constraint.
            </summary>
            <returns>true iff the refutation succeeded</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Inverse(Microsoft.SolverFoundation.Solvers.DisolverDecision)">
            <summary>
            Get the inverse of a decision, i.e. branches the other way around
            (restricted to lower/upper bound constraints)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Undo">
            <summary>
              Undoes the last decision
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.UndoAll">
            <summary>
              Undo all decisions because of a restart
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.RefineBounds">
            <summary>
              When doing optimization, updates the optimality constraints
              imposing to find solutions of quality better for one
              of the objectives.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.ReviseGoal(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Performs the propagation of the lexicographical constraint on
            (multiple) objectives specifically for objective number i.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.InitialPropagations">
            <summary>
              Performs the propagations required when starting
              to solve the problem.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.IsRootLevel">
            <summary>
              True if we are at level 0 i.e. no decision has been made
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.LastDecision">
            <summary>
              Gets the last decision 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Recompute">
            <summary>
              Undoes the propagations done at the last level
              and replays them entirely.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.PrintStats">
            <summary>
              Prints some extra info on the output stream of the solver;
              typically called in end of search.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Track">
            <summary>
              Displays every 2 seconds a line of information 
              on the activity of the solver
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm._stack">
            <summary>
              Stack of decisions; one per level
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm._ranges">
            <summary>
              Keeps track of the range of each decision variables 
              before it's branch on
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm._refutations">
            <summary>
              Stack of additional "decisions" coming from the refutation
              of previous branches
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Verbose">
            <summary>
              True if a trace should be output
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Minimizing">
            <summary>
              Are we doing minimization (or just finding arbitrary solutions)?
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Problem">
            <summary>
              Gets internal representation of the problem as handled
              by the solver.
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TreeSearchAlgorithm.Statistics">
            <summary>
              Gets statistics on the work done by the algorithm
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ParameterlessFunction`1">
            <summary>
              A function without parameter returning arbitrary (non-void) type
            </summary>
            <remarks>
              This is the only delegate type that requires to be exported
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ParameterlessProcedure">
            <summary>
              A function with no parameter and returning void
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Procedure`1">
            <summary>
              A function with one parameter and returning void
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.UnaryFunction`2">
            <summary>
              A function whose input is one parameter of a generic type 
              and that returns a result from another generic type.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Predicate">
            <summary>
              Delegate declaration for
              any function without parameter that returns a boolean.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.UnaryPredicate`1">
             <summary>
               A unary function from generic type to bool
             </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanVariableState">
            <summary>
              A Boolean variable can be true or false, but also unassigned
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Utils">
            <summary>
              Declaration of a number of utilities
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Utils.NonInitialized">
            <summary>
              Unlikely constant value, used when int not initialized
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Utils.DefaultMinValue">
            <summary>
              Default minimum value of an integer variable.
              Any value below this will be ignored
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Utils.DefaultMaxValue">
            <summary>
              Default maximum value of an integer variable
              Any value beyond this will be ignored
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Max``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
              Maximum in a enumeration (slow)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Min``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
              Maximum in a enumeration (slow)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Swap``1(``0@,``0@)">
            <summary>
              Swap two elements of the same type
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.RandomPermutation``1(``0[],System.Random)">
            <summary>
              Permutates the elements of an array
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.AlwaysTrue">
            <summary>
              A method that returns always true.
              Yes - this is sometimes (moderatly) useful.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.AlwaysFalse">
             <summary>
               A method that returns always false.
               Yes - this is sometimes (moderatly) useful.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.TrueForAll``1(System.Collections.Generic.IEnumerable{``0},Microsoft.SolverFoundation.Solvers.UnaryPredicate{``0})">
            <summary>
              Generic method checking whether all elements
              in a collection satisfy a certain condition.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Apply``2(System.Collections.Generic.IEnumerable{``0},Microsoft.SolverFoundation.Solvers.UnaryFunction{``0,``1})">
            <summary>
              Applies a function to all the elements in a collection
              and returns the results.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.CeilOfDiv(System.Int64,System.Int64)">
            <summary>
              Computes Ceil(i/j).
              The result is checked and guaranteed to be over-approximated
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.CorrectCeilOfDiv(System.Int64,System.Int64,System.Int64@)">
            <summary>
              Given two ints i and j and a result which approximates
              Ceil(i/j) fix correct the result until it's a correct 
              over-approximation 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.FloorOfDiv(System.Int64,System.Int64)">
            <summary>
              Computes Floor(i/j).
              The result is checked and guaranteed to be under-approximated
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.CorrectFloorOfDiv(System.Int64,System.Int64,System.Int64@)">
            <summary>
              Given two ints i and j and a result which approximates
              Floor(i/j) fix correct the result until it's a correct 
              under-approximation 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Singleton``1(``0)">
            <summary>
              From and element e, returns the set {e}
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Pair``1(``0,``0)">
            <summary>
              From two elements x, y; returns the pair {x, y}
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.IsOrderedUnique``1(``0[])">
            <summary>
              True iff the array contains values in
              strictly ascending order
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.GetOrderedUnique``1(System.Collections.Generic.IEnumerable{``0})">
             <summary>
               extract from a (possibly unordered/redundant) collection the
               ordered, non-redundant list of its values
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.Intersects(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.Interval},Microsoft.SolverFoundation.Solvers.Interval)">
            <summary>
              true iff the set of values in the collection intersects the
              set of values in the interval
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.PositionFirstGreaterEqual(System.Int64[],System.Int64)">
            <summary>
              Within a sorted-increasing array of integers,
              locates the position of the first element
              that is greater or equal to a specified value.
              If no such position exists returns array length.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.PositionFirstGreaterEqual(System.Collections.Generic.List{System.Int64},System.Int64)">
            <summary>
              Within a sorted-increasing list of integers,
              locates the position of the first element
              that is greater or equal to a specified value.
              If no such position exists returns array length.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Utils.ProductDoesNotOverflow(System.Int64,System.Int64)">
            <summary>
              Validation method; false if the product of two integers
              overflows
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Pair`2">
            <summary>
              Useful way to pair objects of any type,
              for instance Pair between int and bool.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Tracker">
            <summary>
              Maintains the average of the values recorded 
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TypeMatching`1">
            <summary>
              Class used to implement simple pattern matching based
              on the type of the input. Using it we can specify which
              transformation (a delegate of signature T -> output)
              is applied to objects of each and every type
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeMatching`1.#ctor(System.Func{System.Object,`0})">
            <param name="defaultAction">
              default handler, called if the switch is applied 
              to an object for which there is no dedicated handler
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeMatching`1.#ctor(`0)">
            <param name="defaultOutput">v
              default value, returned if the switch is applied 
              to an object for which there is no dedicated handler
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeMatching`1.#ctor(System.Exception)">
            <param name="exceptionWhenNoMatch">
              exception that will be thrown if the switch is applied
              to an object for which there is dedicated handler
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeMatching`1.Match``1(System.Func{``0,`0})">
            <summary>
              Specifies what action is applied to translate a term of the
              given concrete type T. The action has to be a delegate of
              taking an argument of type T and returning the correct type
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeMatching`1.Apply(System.Object)">
            <summary>
              Applies the switch to an object 
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TypeMatching`1._switch">
            <summary>
              Dictionary storing the actions associated
              with each type
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TypeMatching`1._default">
            <summary>
              action to apply by default, i.e. if the type 
              switch is applied to a type for which there is no match
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TypeMatching`1.Item(System.Object)">
            <summary>
              Syntactical sugar for Apply;
              applies the switch to the object
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeSwitch.#ctor(System.Action{System.Object})">
            <param name="defaultAction">
              default handler, called if the switch is applied 
              to an object for which there is no dedicated handler
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeSwitch.#ctor(System.Exception)">
            <param name="exceptionWhenNoMatch">
              exception that will be thrown if the switch is applied
              to an object for which there is dedicated handler
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeSwitch.Match``1(System.Action{``0})">
            <summary>
              Specifies what action is applied to translate a term of the
              given concrete type T. The action has to be a delegate of
              taking an argument of type T and returning the correct type
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TypeSwitch.Apply(System.Object)">
            <summary>
              Applies the switch. 
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TypeSwitch._switch">
            <summary>
              Dictionary storing the actions associated
              with each type
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TypeSwitch._default">
            <summary>
              action to apply by default, i.e. if the type 
              switch is applied to a type for which there is no match
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Interval">
             <summary>
               A basic interval class.
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Interval.op_Multiply(Microsoft.SolverFoundation.Solvers.Interval,Microsoft.SolverFoundation.Solvers.Interval)">
            <summary>
              Safe interval enclosure. SLOW
              meant to be used for initializations.
              The approach is to systematically be within ranges where
              we can multiply values without overflowing.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.DiscreteVariable">
            <summary>
              Root class for Disolver Variables on discrete domains
            </summary>
            <remarks>
              We distinguish between several classes of discrete variables including
              Boolean and integer ones. This is because specialised representations
              and event-handling can be used for different types of variables.
              Most access to discrete variables is done in a typed way (e.g. using
              generic constraints that know exactly the actual type of their 
              arguments) because we are very (overly?) picky about some very
              frequently called methods getting their chance to be inlined, so we
              avoid many virtual calls. It is nonetheless possible to manipulate
              discrete variables directly via the root class through some abstract
              methods. In this case Booleans values are seen as integers 0 and 1
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem,System.Int64)">
            <summary>
              Constructor
            </summary>
            <param name="p">Problem in which variable lives</param>
            <param name="initialDomainSize">
              Domain size of the variable at construction time; 
              used to determine whether the variable is in its original state
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.IsAllowed(System.Int64)">
            <summary>
              True if the integer value is in the variable's current domain
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.GetLowerBound">
            <summary>
              Gets the lower bound of the variable, as an integer 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.GetUpperBound">
            <summary>
              Gets the lower bound of the variable, as an integer 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.TryGetIntegerValue(System.Int64@)">
            <summary>
              returns true of the var is instantiated and, if so,
              assigns its value to the out parameter
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.EnumerateConstraints">
            <summary>
              Goes through all the constraints connected to the variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.ScheduleInitialEvents">
            <summary>
              Schedules all events that need to be scheduled
              when starting the solver
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.ImposeIntegerLowerBound(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a value greater or 
              equal to a new lower bound.  
            </summary>
            <param name="lb">the new lower bound</param>
            <param name="c">
              The explanation (optional); omit when the lower bound
              is not propagated but is instead a decision
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.ImposeIntegerUpperBound(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a value lower or 
              equal to a new upper bound
            </summary>
            <param name="ub">the new upper bound</param>
            <param name="c">
              The explanation (optional); omit when the upper bound
              is not propagated but is instead a decision
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.ImposeIntegerValue(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take an integer value
            </summary>
            <param name="val">the new value</param>
            <param name="c">
              The explanation (optional); omit when the upper bound
              is not propagated but is instead a decision
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.IsInInitialState">
            <summary>
              True if the state of the variable is as it was 
              when it was constructed
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DiscreteVariable.ImposeEmptyDomain(Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Called to indicate that the variable is causing
              a conflict
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DiscreteVariable.DomainSize">
            <summary>
              Number of values currently allowed in the variable's domain
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.DiscreteVariable.AsSingleton">
            <summary>
              Gets a variable group that contains only the variable.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BooleanVariable">
            <summary>
              Class of Boolean variables.
              Can be involved both in purely Boolean constraints (propagated in a 
              special way) and in "classical" CP constraints (reified).
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.BooleanVariableState)">
            <summary>
              Construction (for internal use) of a Boolean variable that 
              does not correspond to a term in the initial problem
            </summary>
            <param name="p">Problem in which the variable is created</param>
            <param name="s">initial state</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.DisolverBooleanTerm)">
            <summary>
              Construction
            </summary>
            <param name="p">Problem in which the variable is created</param>
            <param name="src">Term from which the var originates</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem)">
            <summary>
              Construction (for internal use) of a Boolean variable that 
              does not correspond to a term in the initial problem and which
              is initially unassigned
            </summary>
            <param name="p">Problem in which the variable is created</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.SubscribeToFalse(Microsoft.SolverFoundation.Solvers.BasicEvent.Listener)">
            <summary>
              Adds l to the list of listeners activated when
              the variable becomes false.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.SubscribeToTrue(Microsoft.SolverFoundation.Solvers.BasicEvent.Listener)">
            <summary>
              Adds l to the list of listeners activated when
              the variable becomes true.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.ImposeValueFalse(Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take value false
            </summary>
            <returns>false if a contradiction was detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.ImposeValueTrue(Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take value true
            </summary>
            <returns>false if a contradiction was detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.ImposeValue(System.Boolean,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a particular Boolean value
            </summary>
            <returns>false if a contradiction was detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.Uninstantiate">
            <summary>
              Called by the problem to notify the variable that 
              it return to an unassigned state
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.GetValue">
            <summary>
              Get the truth value 
              (precondition: the variable must be instantiated)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BooleanVariable.ToString">
             <summary>
               For debugging
             </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BooleanVariable.Status">
            <summary>
              Access to the Status of the variable
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IntegerVariable">
            <summary>
              Integer (Finite-domain) variables.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem,System.Int64,System.Int64)">
            <summary>
              Construction (for internal use) of an integer variable that 
              does not correspond to a term in the initial problem
            </summary>
            <param name="p">Problem in which variable is created</param>
            <param name="l">initial lower bound</param>
            <param name="r">initial upper bound</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.#ctor(Microsoft.SolverFoundation.Solvers.Problem,Microsoft.SolverFoundation.Solvers.DisolverIntegerTerm)">
            <summary>
              Construction from an Integer Term
            </summary>
            <param name="p">Problem in which the variable is created</param>
            <param name="src">Term from which var originates</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.SubscribeToAnyModification(Microsoft.SolverFoundation.Solvers.BasicEvent.Listener)">
             <summary>
               Subscribes a delegate that will be called every time 
               the variable is modified 
               (except when the modification is a restoration, i.e. backtracking)
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.SubscribeToRestored(Microsoft.SolverFoundation.Solvers.Procedure{Microsoft.SolverFoundation.Solvers.IntegerVariable})">
            <summary>
              Subscribes a delegate that will be called after any restoration
              of the state of the variable, i.e. on backtrack
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ImposeLowerBound(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a value greater or 
              equal to a new lower bound.  
            </summary>
            <param name="newlb">new lower bound</param>
            <param name="c">
              the cause of the call; can be null if not a consequence 
            </param>
            <returns>false if contradiction detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ImposeUpperBound(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a value less or equal 
              to a new upper bound
            </summary>
            <param name="newub">new upper bound</param>
            <param name="c">
              the cause of the call; can be null if not a consequence 
            </param>
            <returns>false if contradiction detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ImposeRange(System.Int64,System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a particular value
            </summary>
            <param name="newlb">new lower bound</param>
            <param name="newub">new upper bound</param>
            <param name="c">
              the cause of the call; can be null if not a consequence 
            </param>
            <returns>false iff contradiction detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ImposeValue(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              Constrains the variable to take a particular value
            </summary>
            <param name="newval">the new value</param>
            <param name="c">
              the cause of the call; can be null if not a consequence 
            </param>
            <returns>false iff contradiction detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ImposeBoundsDifferentFrom(System.Int64,Microsoft.SolverFoundation.Solvers.Cause)">
            <summary>
              If one bound of the variables happens to equal the removed Value
              the it will be tighten. Note that this method has no guarantee
              that the value will be permanently removed
            </summary>
            <param name="removedValue">the removed value</param>
            <param name="c">
              the cause of the call; can be null if not a consequence 
            </param>
            <returns>false iff contradiction detected</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.IsInstantiated">
             <summary>
               True if the two bounds of the variable are equal 
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.GetValue">
            <summary>
              Gets the value of an instantiated variable
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.RestoreState(System.Int64,System.Int64,System.Int32)">
            <summary>
              Called by the problem on backtrack, to notify the variable
              that it should return to a previous state. Note that the 
              (bit-vector) domain, if any, is maintained independently, as
              a BacktrackabkleFiniteSet
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.CreateIfNull(Microsoft.SolverFoundation.Solvers.BasicEvent@)">
            <summary>
              Implementation of the "create at first access" philosophy
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ScheduleInitialEvents">
            <summary>
              Schedules all events to which listeners should react
              at the beginning of the problem resolution
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IntegerVariable.ToString">
            <summary>
              This is to help visualizing in debugger, nothing more
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerVariable.LowerBound">
            <summary>
              Access to current lower bound
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerVariable.UpperBound">
            <summary>
              Access to current upper bound
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IntegerVariable.DepthOfLastSave">
            <summary>
              Depth at which the variable was last saved
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver">
            <summary>Finds a local minimum/maximum for an unconstrained nonlinear function.
            </summary>
            <remarks>
            Uses the L-BFGS algorithm, a limited memory Quasi-Newton method.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonModel">
            <summary>
            Class for modeling non-linear model for CQN solver
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel">
            <summary>
            Base class for unconstrained nonlinear models.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.PreChange">
            <summary>Invoke this function before modfying the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.ValidateVid(System.Int32)">
            <summary>
            Validate a vid, throwing ArgumentException if not valid.
            </summary>
            <param name="vid">A vid.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetVariableListIndex(System.Int32)">
            <summary>
            This mapped between variable vid to internal model and solver variable index
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>Creates a new instance.
            </summary>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown 
            </summary>
            <param name="key"></param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key
            </summary>
            <param name="key">the key value </param>
            <param name="vid">the variable index </param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown
            </summary>
            <param name="vid">the variable index</param>
            <returns>the variable key</returns>
            <remarks>key might be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.AddRow(System.Object,System.Int32@)">
            <summary> If the model already includes a row referenced by key, this sets vid to the row’s index and returns false. 
            Otherwise, if the model already includes a user variable referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new row associated with key to the model, assigns the next available index to the new row, sets vid to this index, 
            and returns true.
            CompactQuasiNewtonSolver can have just one row. By convention this row will always have 0 as an index.
            </summary>
            <param name="key">a key for the row</param>
            <param name="vid">a row variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.IsRow(System.Int32)">
            <summary>
            validate if it is a row index 
            </summary>
            <param name="vid">row index</param>
            <returns>true if a row otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#IRowVariableModel#SetIgnoreBounds(System.Int32,System.Boolean)">
            <summary>
            Adjusts whether the bounds of a vid should be respected or ignored during solving. 
            By default, bounds are respected.
            </summary>
            <param name="vid">a variable index</param>
            <param name="fIgnore">whether to ignore the bounds</param>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#IRowVariableModel#GetIgnoreBounds(System.Int32)">
            <summary>
            Get the flag whether is bound is ignored
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if bounds are ignored, otherwise false</returns>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust upper and lower bounds for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The lower bound.</param>
            <param name="numHi">The upper bound.</param>
            <remarks>Not supported by unconstrained solvers.  Logically, a vid may have an upper bound of Infinity and/or a lower 
            bound of -Infinity. Specifying other non-finite values should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            and ArgumentException is thrown.  
            </remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the lower bound for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The lower bound.</param>
            <remarks>Not supported by unconstrained solvers.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the upper bound for a vid. 
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numHi">The upper bound.</param>
            <remarks>Not supported by unconstrained solvers.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Return the bounds for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The current lower bound.</param>
            <param name="numHi">The current upper bound.</param>
            <remarks>Not supported by unconstrained solvers.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            </summary>
            <remarks>
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            By convention variables get indexes from 1 ... VariableCount in the order they were added.
            </remarks>
            <param name="key">Variable key.</param>
            <param name="vid">Variable index.</param>
            <returns>True if added successfully, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used when retrieving results.
            </summary>
            <param name="vid">A variable index.</param>
            <returns>The variable value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.CopyVariableValuesTo(System.Double[],System.Double)">
            <summary>Copy variable values to an array.
            </summary>
            <param name="x">An array of Double.</param>
            <param name="defaultValue">The default value to be substituted for non-finite values.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.CopyVariableValuesFrom(System.Double[])">
            <summary>Copy variable values from an array.
            </summary>
            <param name="x">An array of Double.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            The default value for a vid is Indeterminate. 
            </summary>
            <param name="vid">a variable index</param>
            <param name="value">The value for the variable.</param> 
            <remarks>This class can be used to represent not just a model, 
            but also a current state for the model’s variables. 
            The state associates with each vid a current value represented as a Rational. 
            This state will be used as a starting point when solving. Setting a value for a row is ignored by the solver.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.SetGoalValue(Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the goal value.
            </summary>
            <param name="value">The value for the goal.</param> 
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#IRowVariableModel#SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable 
            </summary>
            <param name="vid">a variable index </param>
            <param name="fInteger">whether to be an integer variable</param>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#IRowVariableModel#GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#INonlinearModel#GetActiveVariables(System.Int32)">
            <summary>Specify variables that participate in the row. 
            </summary>
            <param name="rowVid">the row index</param>
            <returns>Enumeration of active varibles on rowVid</returns>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index</exception>
            <remarks>In the case of a model which has explicit linear terms (implements ILinearModel),
            there is no need to specify the linear terms with this call.</remarks>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#INonlinearModel#IsActiveVariable(System.Int32,System.Int32)">
            <summary>Is a specific variable active in a specific row
            </summary>
            <param name="rowVid">the row index</param>
            <param name="varVid">the variable index</param>
            <returns>true if variable is active, otherwise false</returns>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index</exception>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#INonlinearModel#SetActiveVariables(System.Int32,System.Boolean)">
            <summary>Set all variables in a row to be active/inactive
            </summary>
            <param name="rowVid">the row index</param>
            <param name="active">if true, all variables become active, 
            if false all variables become inactive</param>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index</exception>
            <exception cref="T:System.NotSupportedException">All variables should be active</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#INonlinearModel#SetActiveVariable(System.Int32,System.Int32,System.Boolean)">
            <summary>Set a specific variable in a row to be active/inactive
            </summary>
            <param name="rowVid">the row index</param>
            <param name="varVid">the variable index</param>
            <param name="active">if true, the variable becomes active, 
            if false it becomes inactive</param>
            <remarks>Not supported by unconstrained solvers</remarks>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index, 
            or varVid is not a legal variable index</exception>
            <exception cref="T:System.ArgumentException">rowVid is not a legal row index</exception>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark a row as a goal.
            </summary>
            <param name="vid">A row id.</param>
            <param name="pri">The priority of a goal.</param>
            <param name="minimize">Whether to minimize the goal row.</param>
            <returns>An IGoal representing the goal.</returns>
            <remarks>This solver supports only one goal.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row 
            </summary>
            <param name="vid">a row id</param>
            <returns>true if this a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.IGoal@)">
            <summary>
            Check if a row id is a goal. If true, return the goal entry 
            </summary>
            <param name="vid">a row id</param>
            <param name="goal">return the goal entry</param>
            <returns>true if a goal row. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row
            </summary>
            <param name="vid">a row id</param>
            <returns>true if the goal is removed. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.ClearGoals">
            <summary>
            Clear all the goals 
            </summary>
            <remarks>Not needed for unconstrained solvers</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal
            </summary>
            <param name="vid">a variable index</param>
            <returns>A goal entry. Null if not a goal row</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.AddRowAsGoal(System.Object,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Adds a row as a goal.
            Unconstrained models can have just one row. By convention this row will always have 0 as an index.
            </summary>
            <param name="key">a key for the row</param>
            <param name="pri">the priority of a goal</param>
            <param name="minimize">whether to minimize the goal row</param>
            <param name="vid">a row variable index of the goal row if successful, or -1 if not</param>
            <returns>the new goal if added successfully, otherwise null</returns>
            <remarks>If the model already includes a row referenced by key, and the row is not a goal, this make the row a goal. </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.RowValue">
            <summary>
            Sets the value of the only row of the model 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.VariableKeyCount">
            <summary>
            return count for keys (not including null) for variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Indices">
            <summary> return the variable index collection, inclusive of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Keys">
            <summary> Return the variable and row key collection.
            Indices are guaranteed to >= 0 and &lt; KeyCount.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.KeyCount">
            <summary> the number of keys, inclusive of rows and variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.RowIndices">
            <summary> return the row index collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.RowKeys">
            <summary> return the row key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.RowCount">
            <summary> the number of rows in the model 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.VariableIndices">
            <summary>
            Gets an IEnumerable containing the variable indexes.
            </summary>
            <remarks>
            The result is guaranteed to be the integer values from 1 to VariableCount.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.VariableKeys">
            <summary>
            Gets an IEnumerable containing the variable keys.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.VariableCount">
            <summary>
            Gets the number of variables in the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Microsoft#SolverFoundation#Services#IRowVariableModel#IntegerIndexCount">
            <summary> return the number of integer variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.FunctionEvaluator">
            <summary>
            Function value callback.
            * INonlinearModel: the model.
            * int: the row (goal or constraint) index.
            * ValuesByIndex: the variable values.
            * bool: is first evaluator call with those variable values.
            * double: the row value (returned by the callback).
            </summary>
            <remarks>This callback must be set before solving the model</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GradientEvaluator">
            <summary>
            Gradient callback.
            * INonlinearModel: the model.
            * int: the row (goal or constraint) index.
            * ValuesByIndex: the variable values.
            * bool: is first evaluator call with those variable values.
            * ValuesByIndex: the gradient values (set by the user).
            </summary>
            <remarks>All entries which related to variables declared as an active by SetActiveVariables method, 
            needs to be filled in ValuesByIndex of gradients</remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.Goals">
            <summary>
            Return the goal collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.GoalCount">
            <summary>
            The number of goals in this model
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.UnconstrainedNonlinearModel.TheGoal">
            <summary>
            The only goal of the model
            </summary>
            <returns>The goal if exists, if not return null</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonModel.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>
            Creates CompactQuasiNewtonModel.
            </summary>
            <param name="comparer">Key comparer</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonModel.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to set, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonModel.GetProperty(System.String,System.Int32)">
            <summary>Get a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to get, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <returns>The value.</returns>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.#ctor">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>Creates a new instance.
            </summary>
            <param name="comparer">A key comparer</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.SolveCore(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams)">
            <summary>Solve the model using the specified parameters.
            </summary>
            <param name="solverParams">The solver parameters.</param>
            <returns>Returns the solution quality.</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.ValidateInSolveState(System.String)">
            <summary>
            If not in solving state and property is one that solver supports, throw
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.ToString">
            <summary>Returns a string representation of the solver.
            </summary>
            <returns>Returns a string representation of the solver.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.AnalyzeError(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType)">
            <summary>
            Map from detailed internal enum to CompactQuasiNewtonSolutionQuality.
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary>
            Solve the model using the given parameter instance.
            </summary>
            <param name="parameters">Should be an instance of CompactQuasiNewtonSolverParams.</param>
            <returns>The solution after solving.</returns>
            <exception cref="T:System.ArgumentNullException">Parameters should not be null.</exception>
            <exception cref="T:System.ArgumentException">parameters should be of CompactQuasiNewtonSolverParams type.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">Both FunctionEvaluator and GradientEvaluator must be specified before calling solve.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GradientAndValueAtPointCallback(System.Double[],System.Double[])">
            <summary>
            This hooks up calls from the solver core to the callbacks on the user function.
            </summary>
            <param name="values">Current values of variables at the point.</param>
            <param name="gradients">Gradient to fill.</param>
            <returns>Function value at the point.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.Shutdown">
            <summary> Shutdown the solver instance
            </summary>
            <remarks>Solver needs to dispose any unmanaged memory used upon this call.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a solver-related property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GetProperty(System.String,System.Int32)">
            <summary>Get the value of a property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <returns>The property value as a System.Object.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.Microsoft#SolverFoundation#Services#INonlinearSolution#GetValue(System.Int32)">
            <summary>Return the value of a variable.
            </summary>
            <param name="vid">A variable id.</param>
            <returns>The variable value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GetSolutionValue(System.Int32)">
            <summary>Get the objective value of a goal.
            </summary>
            <param name="goalIndex">goal id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get information about a solved goal.
            </summary>
            <param name="goalIndex"> 0 &lt;= goal index &lt; SolvedGoalCount </param>
            <param name="key">The goal row key</param>
            <param name="vid">The goal row vid</param>
            <param name="minimize">Whether the goal is to minimize</param>
            <param name="optimal">Whether the goal is optimal</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A SolutionMapping instance.</param>
            <returns>Report for model solved by CompactQuasiNewtonSolver</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.ToleranceDifference">
            <summary>Gets the difference between the solution tolerance and the tolerance
            requested by the caller.
            </summary>
            <remarks>
            The solver tolerance is set using CompactQuasiNewtonSolverParams.
            If a call to Solve() returns CompactQuasiNewtonSolutionQuality.LocalOptimum
            then this value will be zero or less.  If a local optimum is found even
            though the stopping criterion is not met, the final tolerance is considered
            to be zero and the ToleranceDifference will be the negated version of
            the requested tolerance.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.IterationCount">
            <summary> The number of iterations that have been performed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.EvaluationCallCount">
            <summary> The number of function evaluation calls.
            Each call is for both funtion and gradient evaluation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.SolutionQuality">
            <summary> The detailed quality of solution from Compact Quasi Newton solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.NonlinearCapabilities">
            <summary>
            The capabilities for this solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.GradientCapability">
            <summary>
            Gradient related capability
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.HessianCapability">
            <summary>
            Hessian related capability
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.Microsoft#SolverFoundation#Services#INonlinearSolution#SolvedGoalCount">
            <summary> Number of goals being solved.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.Result">
            <summary>
            indicates the type of result (e.g., LocalOptimal) 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.CqnValueByIndex">
            <summary>
            Helps with the specific mapping for vid->solver index of CQN solver 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolver.CqnValueByIndex.#ctor">
            <summary>
            Creates CqnValueByIndex instance
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState">
            <summary>
            Contains information about the state of the solver
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState._function">
            <summary>
            The function being optimized
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState._dimensions">
            <summary>
            The dimensionality of the function
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.#ctor(System.Func{System.Double[],System.Double[],System.Double},Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams,System.Boolean,System.Int32,System.Double[])">
            <summary>
            Creating a state
            </summary>
            <param name="function"></param>
            <param name="solverParams"></param>
            <param name="minimize"></param>
            <param name="dimensions"></param>
            <param name="startingPoint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.UpdateDir">
            <summary>
            called fron the solver for first iteration 
            and from state as part of shifting 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.MapDirByInverseHessian">
            <summary>
            two loop recursion (7.4)
            ro is 1/ro
            alpha is -alpha
            dir start as q (first loop) and then become r (second loop)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Shift">
            <summary>
            update the state for next move (add s and y) and discard old vectors
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Swap``1(``0@,``0@)">
            <summary>
            swaps a and b
            </summary>
            <typeparam name="T"></typeparam>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.LineSearch">
            <summary>
            An implementation of the line search for the Wolfe conditions, from Nocedal and Wright
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Zoom(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.PointInterpolationData,Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.PointInterpolationData,System.Double,System.Double,System.Double)">
            <summary>
            "zoom" procedure (algirithm 3.6)
            </summary>
            <param name="aLo"></param>
            <param name="aHi"></param>
            <param name="dirDeriv"></param>
            <param name="c1"></param>
            <param name="c2"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.CubicInterp(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.PointInterpolationData,Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.PointInterpolationData)">
            <summary>
            Cubic interpolation routine from Nocedal and Wright (3.59) (used for LineSearch).
            </summary>
            <param name="p0">first point, with alpha, value and derivative</param>
            <param name="p1">second point, with alpha, value and derivative</param>
            <returns>local minimum of interpolating cubic polynomial</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.CallFunction(System.Double[],System.Double[])">
            <summary>
            call the function and inverse the result and gradient if this is
            maximization problem. All calls should be through that pipe
            </summary>
            <param name="pointVector"></param>
            <param name="gradientVector"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.IsGradientAlmostZero">
            <summary>
            checks if the gradient is in the vicinity of zero
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Iter">
            <summary>
            The number of iterations so far
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Value">
            <summary>
            The current function value
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.ModifiedValue">
            <summary>
            The current function value modified, so if it is 
            maximize problem will return the negative of that
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.LastValue">
            <summary>
            The function value at the last point
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.Point">
            <summary>
            The current point being explored
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.EvaluationCount">
            <summary>
            Count of evaluation calls
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState.PointInterpolationData">
            <summary>
            data for interpolation
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams">
            <summary>Parameters for the CompactQuasiNewtonSolver.
            </summary>
            <remarks>
            The solver terminates when the geometrically-weighted average improvement falls below the Tolerance.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.#ctor(System.Func{System.Boolean})">
            <summary>Create a new instance.
            </summary>
            <param name="fnQueryAbort">An abort delegate that is called during the solution process.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.#ctor">
            <summary>Create a new instance with default arguments.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.#ctor(System.Double,System.Int32,System.Int32,System.Func{System.Boolean})">
            <summary>Create a new instance.
            </summary>
            <param name="tolerance">The solution tolerance.</param>
            <param name="iterationsToRemember"></param>
            <param name="maxIterations">The maximum number of iterations.</param>
            <param name="fnQueryAbort">An abort delegate that is called during the solution process.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.#ctor(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams)">
            <summary>Copy constructor.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary>Create a new instance from a Directive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.ShouldAbort">
            <summary>Checks whether the solver should abort by examining the Abort property and
            the abort delegate.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.FillInSolverParams(Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Fill in CompactQuasiNewtonSolverParams based on the given directive.
            </summary>
            <param name="dir">The directive instance that contains all the parameter settings</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.Tolerance">
            <summary>The solver terminates when the geometrically-weighted average improvement 
            falls below the Tolerance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.IterationsToRemember">
            <summary>
            Number of previous iterations to remember for estimate of Hessian (m), (default is 17).
            </summary>
            <remarks>
            Higher values lead to better approximations to Newton's method, 
            but use more memory, and requires more time to compute direction.  
            The optimal setting of IterationsToRemember is problem specific,
            depending on such factors as how expensive is function evaluation
            compared to choosing the direction, how easily approximable is the 
            function's Hessian, etc.  A range of 15 to 20 is usually reasonable 
            but if necessary even a value of 2 is better than gradient descent.
            </remarks>    
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.IterationLimit">
            <summary>The maximum number of solver iterations.
            </summary>
            <remarks>
            If the iteration limit is exceeded, the solver will return CompactQuasiNewtonSolutionQuality.Error.
            The default Int32.MaxValue.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.Abort">
            <summary>Setting this property to true will cause the solver to abort.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.QueryAbort">
            <summary>
            Get/set the callback function that decides when to abort the search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverParams.Solving">
            <summary>
            Callback called during solve
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality">
            <summary>Represents the solution quality.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.LocalOptima">
            <summary>An optimal local minimum was found.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.UserCalculationError">
            <summary>A failure likely due to error in information provided by the caller.
            </summary>
            <remarks>
            The failure relates to one of the following: a step was taken in 
            a non-descent direction; the steplength was too short, the "y" and "s"
            vectors are orthogonal.  These conditions usually happen when the user-provided
            objective or gradient are incorrect or ill-conditioned, or when the termination criteria 
            is too strict.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.LinearObjective">
            <summary>The difference between sequential gradients is zero.
            </summary>
            <remarks>
            This condition should occur only with linear objective functions.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.Unbounded">
            <summary>The solution exceeded the range of System.Double.
            This condition usually means that the function is unbounded.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.MaxIterationExceeded">
            <summary>The maximum number of iterations was exceeded.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolutionQuality.Interrupted">
            <summary>The solver was aborted by the caller.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.NonDescentDirection">
            <summary>Chosen step is in non-descent direction, usually caused by mistake in users delegate.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.InsufficientSteplength">
            <summary>Step length is too short.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.YIsOrthogonalToS">
            <summary>y vector and s vector are orthogonal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.GradientDeltaIsZero">
            <summary>No delta for gradient. Can be linear function for example.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.NumericLimitExceeded">
            <summary>When we exceeded the limits of double. Most likely that the function is unbounded.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.MaxIterationExceeded">
            <summary>When we exceeded the limit of number of iterations.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonErrorType.Interrupted">
            <summary>Stopped by the user. 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolveState">
            <summary>
            Indicates the operation about to be performed by the CQN solver.
            </summary>
            <remarks>All states changed right before the action.</remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolveState.PreInit">
            <summary>
            Before solve has been started.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolveState.Init">
            <summary>
            Start. 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolveState.DirectionCalculation">
            <summary>
            Calculating new direction.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolveState.LineSearch">
            <summary>
            Get the right step size in the calculated direction.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TerminationCriterion">
            <summary>An object which is used to decide whether to stop optimization.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TerminationCriterion.#ctor(System.Double)">
            <summary>Create a new instance.
            </summary>
            <param name="tolerance">The tolerance.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TerminationCriterion.CriterionMet(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState)">
            <summary>Determines whether to stop optimization.
            </summary>
            <returns>Returns true if and only if the criterion is met, i.e. optimization should halt.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion">
            <summary>
            Terminates when the geometrically-weighted average improvement falls below the tolerance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion"/> class.
            </summary>
            <param name="tol">The tolerance parameter</param>
            <param name="lambda">The geometric weighting factor.  
            Higher means more heavily weighted toward older values.
            Currenty is not an input from the user
            </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion"/> class.
            </summary>
            <param name="tol">The tolerance parameter</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion"/> class.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MeanImprovementCriterion.CriterionMet(Microsoft.SolverFoundation.Solvers.CompactQuasiNewtonSolverState)">
            <summary>
            Determines whether to stop optimization
            criterion(n) = z * unNorm(n)
            unNorm(n) = delta(n) + lambda*unNorm(n-1)
            </summary>
            <param name="state">the state of the optimizer</param>
            <returns>
            true iff criterion is met, i.e. optimization should halt
            </returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.TermEvaluator">
            <summary>
            A factory that generates terms (variables, functions of other terms),
            which can be Boolean or numerical (real-valued). 
            Allows to change the value of the variables and to maintain incrementally 
            the value of some numerical terms ("goals") and the violation of some
            Boolean terms ("constraints").
            </summary>
            <remarks>
            Note on NaN: when we evaluate the terms we accept NaNs: for instance
            if we have terms expressing X / Y and Y turns out to be zero. 
            This means that goals can potentially have a NaN value.
            Violations can also have a NaN value, for instance X / Y > 0 with Y = 0.
            </remarks>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator.MaxSize">
            <summary>
            When we have array terms such as Sums, this represents the limit
            for a simple array representation of the term. Beyond this we'll
            start constructing a balanced tree of expressions to guarantee
            a log-time bound of recomputation of commutative/associate operations.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.#ctor">
            <summary>
            A solver that can (try to) solve arbitrarily complex
            problems modelled in SFS
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.Initialize">
            <summary>
            (re)initializes the data-structures for evaluation. 
            Does nothing if the data-structures have already been 
            allocated and if nothing has changed since they have.
            </summary>
            <remarks>
            This is a heavy operation:
            (1) allocates temporary hashsets and sorted lists; 
            (2) initializes the dependency lists and evaluation queue.
            
            However the benefit from separating reinitialization from term 
            construction is that reinitialization can be re-done on demand 
            if terms are added, or removed. So the evaluator is flexible:
            both incremental and decremental.
            
            One thing that complicates a bit the initialization is the 
            (anticipated) support for compilation. If some terms are compiled 
            and some are interpreted this requires a flexible initialization
            that decides *a posteriori* of the term construction which ones
            finally have the right size for compilation, and possibly allocates
            other terms for the compiled code. Keeping the incremental/decremental
            semantics with this requires to produce a fresh compiled code whenever
            a term is added / removed.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.InitializeDependencies(Microsoft.SolverFoundation.Solvers.EvaluableTerm[])">
            <summary>
            (Re)-initializes the lists of dependents of each term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CollectTerms">
            <summary>
            Computes the set of all terms that are inputs of
            inputs... of constraints and goals
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.AddConstraint(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Specifies that a Boolean term is a constraint;
            The evaluator will maintain its violation incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.AddGoal(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Specifies that a numerical term is a goal;
            The evaluator will maintain its value incrementally
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.RemoveConstraint(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Removes a Boolean term from the set of constraints
            </summary>
            <returns>
            True if the constraint is successfully removed
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.RemoveGoal(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Removes a numerical term from the set of goals
            </summary>
            <returns>
            True if the goal is successfully removed
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.ClearGoals">
            <summary>
            Removes all goals
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateNumericalVariable(System.Double)">
             <summary>
             Creates a new variable ranging over doubles
             </summary>
             <param name="init">the initial value of the variable</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateNumericalVariable(System.Double,Microsoft.SolverFoundation.Solvers.LocalSearchDomain)">
             <summary>
             Creates a new variable with a specified domain
             </summary>
             <param name="init">the initial value of the variable</param>
             <param name="dom">the initial domain of the variable</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateConstant(System.Double)">
             <summary>
             Creates a new numerical constant, immutable
             </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateProduct(System.Double,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the product of a numerical term by a constant
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateProduct(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the product of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateQuotient(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the division of the first term by the second
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateProduct(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the product of a list of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateUnaryMinus(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the opposite (unary minus) of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateUnaryIdentity(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the identity of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateUnaryIdentity(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Creates the identity of a Boolean term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateAbs(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the Absolute value of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMinus(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the difference of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMinus(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,System.Double)">
            <summary>
            Creates the difference of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateSum(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,System.Double)">
            <summary>
            Creates the sum of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateSum(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the sum of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateSum(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the sum of a list of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateSum(System.Double[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the sum of a weighted list of terms, i.e.
            the sum of the terms coefs[i] * args[i], forall i
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateSum(System.Int32[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the sum of a weighted list of terms, i.e.
            the sum of the terms coefs[i] * args[i], forall i
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMin(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the Minimum of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMin(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the Minimum of a list of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMax(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the Maximum of two numerical terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateMax(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates the Maximum of a list of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateAllDifferent(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates a term that is true iff all the arguments take different values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateEqual(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates a term that is true iff the arguments are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateDifferent(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates a term that is true iff the arguments are different
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateLessStrict(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates a term that is true iff the arguments
            are in strictly increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateLessStrict(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates a term that is true iff the arguments
            are in strictly increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateLessEqual(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates a term that is true iff the arguments
            are in non-decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateLessEqual(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates a term that is true iff the arguments
            are in non-decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateLessEqual(System.Double,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,System.Double)">
            <summary>
            Term that is true if X is in the range [lower, upper]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateNot(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Creates the negation (opposite truth value) of a Boolean term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateAnd(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm,Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Creates the Boolean And of two Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateAnd(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm[])">
            <summary>
            Creates the Boolean And of a list of Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateOr(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm,Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Creates the Boolean Or of two Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateOr(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm[])">
            <summary>
            Creates the Boolean Or of a list of Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateIf(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates the a conditional term, equal to one case
            when the condition is true, else to the other
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateUnaryFunction(System.Func{System.Double,System.Double},Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Services.TermModelOperation)">
            <summary>
            Creates a term of the form F(x), where x is a numerical term
            and F is an arbitrary function from double to double 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateBinaryFunction(System.Func{System.Double,System.Double,System.Double},Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm,Microsoft.SolverFoundation.Services.TermModelOperation)">
            <summary>
            Creates a term of the form F(x), where x is a numerical term
            and F is an arbitrary function from double to double 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateNaryFunction(System.Func{System.Double[],System.Double},Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            Creates a term of the form F(x), where x is a numerical term
            and F is an arbitrary function from double to double 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateConversionToNumerical(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Creates a term that casts a Boolean term to a numerical with value 0 or 1
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateConversionToBoolean(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Creates a term that casts a numerical term with value 0 or 1 to its Boolean value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.InitDelegates">
            <summary>
            This should be called when constructing the Evaluator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateArrayTerm``1(System.Func{``0[],``0},System.Func{``0,``0,``0},``0[],System.Int32,System.Int32)">
            <summary>
            Create terms representing the application of a commutative, 
            associative operations, for instance Sums, to a (possible long)
            array of arguments. 
            </summary>
            <remarks>
            Guarantees a logarithmic bound on the recomputation of these operations.
            Below a certain limit, say 20 arguments, it is more memory- and time- 
            efficient to simply allocate a sum with 20 arguments, recomputed non-
            incrementally. 
            
            Beyond the limit we use a balanced tree of operations (say sums) to 
            guarantee the logarithmic bound, and allow to scale to very large 
            number of terms. 
            
            For instance if we have a sum of 2000 terms we divide it in about 20 
            chunks. Each chunk contains 100 arguments and is itself, recursively,
            decomposed into chunks of about 20 chunks. (The MaxSize is not
            necessarily 20, and should be tuned empirically)
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateWeightedSum(System.Int32[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[],System.Int32,System.Int32)">
            <summary>
            Specialized code to CreateArrayTerm for weighted sums
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.CreateWeightedSum(System.Double[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[],System.Int32,System.Int32)">
            <summary>
            Specialized code to CreateArrayTerm for weighted sums
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.SignalNewTerm(Microsoft.SolverFoundation.Solvers.EvaluableTerm)">
            <summary>
            This ritual should be called by every method that creates a term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.Reschedule(Microsoft.SolverFoundation.Solvers.EvaluableTerm)">
            <summary>
            Indicate that the expression should be re-evaluated
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.Recompute">
            <summary>
            Re-evaluates all terms
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.ReinitializeAll(Microsoft.SolverFoundation.Solvers.EvaluableTerm[])">
            <summary>
            (re)initializes all terms systematically, in a non-incremental way.
            Note that the array is first sorted by increasing depths
            </summary>
            <returns>
            True if the value of at least one term has changed
            </returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.ChangeValue(Microsoft.SolverFoundation.Solvers.EvaluableVariable,System.Double)">
            <summary>
            Reassign the variable 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.ComputeCauses(System.Random,System.Boolean)">
            <summary>
            Computes (a conservative estimate, i.e. superset) of the variables 
            that are involved in the violation of at least one constraint
            </summary>
            <param name="prng">A pseudo-random number generator</param>
            <param name="diverse">
            When set to true (which is best, except for checking the sanity
            of the returned set) random elements are added if the set does
            not reach a certain size, amortizing this operation and avoiding
            improving diversification
            </param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.UpdateAggregatedQuality(System.Double[]@,System.Double)">
            <summary>
            Get an array representation of the quality of the current evaluation:
            current violation at position 0, 
            then current value of the first minimization goal (if any) at position 1, 
            of the second minimization goal (if any) at position 2,
            etc. This representation means that lexicographically lower is better
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.EnumerateConstraints">
            <summary>
            All the constraints declared in this evaluator
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.TermEvaluator.EnumerateGoals">
            <summary>
            All the goals declared in this evaluator
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._initialized">
            <summary>
            True if all data-structures have been correctly initialized 
            for the problem. These data-structures must be undone / recomputed
            every time a term is added / removed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._reEvaluationQueue">
            <summary> 
            Modified terms that need to be considered in re-evaluation;
            Each is paired with its Value before modification. 
            The terms are ranked by depth in order to allow sound re-evaluation.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._allVariables">
            <summary>
            All the variables created in this evaluator
            </summary>
            <remarks>
            CODE REVIEW (lucasb): superfluous. Can be removed or used in DEBUG only
            Is only used for assertions
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._nbEnqueued">
            <summary>
            Number of elements in the queue
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._constraints">
            <summary>
            List of constraints
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._goals">
            <summary>
            List of objective functions 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._violation">
            <summary>
            Term that captures the sum of violations of all added constraints
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.TermEvaluator._eliminatedVariables">
            <summary>
            Variables eliminated in presolve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.PresolveLevel">
            <summary>Presolve level. -1 means automatic, 0 means no presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.EqualityTolerance">
            <summary>
            Tolerance on equality constraints.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.ConstantTrue">
            <summary>
            Term representing the Boolean True
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.ConstantFalse">
            <summary>
            Term representing the Boolean False
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.ConstantZero">
            <summary>
            Term representing the constant zero
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.ConstantOne">
            <summary>
            Term representing the constant one
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.CurrentViolation">
            <summary>
            Get the violation component of the current quality
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.ConstraintsCount">
            <summary>
            Number of constraints
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.TermEvaluator.GoalsCount">
            <summary>
            Number of goals
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableTerm">
            <summary>
            An entity whose value can be Boolean, integer, or real, 
            and that can be re-evaluated incrementally subject to changes
            in the values of other evaluables.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableTerm._mask100000etc">
            <summary>
            A constant whose bits are 1, 0, 0, 0, 0, 0...
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableTerm._mask011111etc">
            <summary>
            A constant whose bits and 0, 1, 1, 1, 1, 1...
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.#ctor(System.Int32)">
            <summary>
            Constructor called by derived classes;
            the depth is specified at constrution time
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.MarkEnqueued">
            <summary>        
            Indicate that the term is currently enqueued for re-evaluation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.MarkDequeued">
            <summary>
            Indicate that the term is not currently enqueued for re-evaluation
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.DequeueAll(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.EvaluableTerm})">
            <summary>
            MarkDequeued a whole set of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.Recompute(System.Boolean@)">
            <summary>
            Naive recomputation: Recompute the value of this
            from the value of all its inputs
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.Reinitialize(System.Boolean@)">
            <summary>
            (Re)intialization. Defaults to a  simple recomputation.
            Overload if the term needs more during its (re)initialization, 
            in particular to (re) allocate data-structures
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.IsStable">
            <summary>
            True if the term is currently correctly evaluated
            from its inputs.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.CollectSubTerms">
            <summary>
            Compute recursively the set of terms that are inputs of
            inputs... of this term. Includes the term itself.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.CollectSubTerms(System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.EvaluableTerm})">
            <summary>
            Computes the set of descendants from an initial list of terms: 
            includes the terms themselves, their inputs, their inputs'inputs, ...
            </summary>
            <remarks>
            Implementation is not recursive to avoid stack overflow 
            problems with very deep terms.
            
            Uses the IsEnqueued Tag to mark the visited nodes. 
            For this reason should be called ONLY when we are not 
            evaluating the terms, and when no term is enqueued.
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.Explore(System.Collections.Generic.List{Microsoft.SolverFoundation.Solvers.EvaluableTerm},System.Collections.Generic.Stack{Microsoft.SolverFoundation.Solvers.EvaluableTerm},Microsoft.SolverFoundation.Solvers.EvaluableTerm)">
            <summary>
            Marking used by Depth-first search algorithms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.RescheduleDependents(Microsoft.SolverFoundation.Solvers.TermEvaluator)">
            <summary>
            Reschedules all dependents of the term
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.InitializeDependentList(Microsoft.SolverFoundation.Solvers.EvaluableTerm[])">
            <summary>
            Initialize the list of dependents of the term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.EnumerateInputs">
            <summary>
            Enumerates all the terms that this one depends on
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableTerm.EnumerateMoveCandidates">
            <summary>
            Enumerate the inputs which, if re-assigned, 
            are likely to change the term's value. 
            </summary>
            <remarks>
            In particular for a Boolean Term the inputs returned are
            restricted to the ones whose re-assignment might change the
            term's polarity. For numerical terms using the default 
            enumeration of all inputs is typical.
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableTerm._state">
            <summary>
            Stores both the Enqueued tag (sign bit)
            and the depth of the term (other bits)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableTerm._dependents">
            <summary>
            List of evaluables that depend on this. 
            Null if there is no dependent
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.IsEnqueued">
            <summary>
            Flag that records whether 
            the term is currently enqueued for re-evaluation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.Depth">
            <summary>
            Depth: 0 for an evaluable without predecessor,
            otherwise 1 plus the depth of the highest predecessor
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.IsConstant">
            <summary>
            True if the term is immutable
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.Operation">
            <summary>
            Get the operation that labels this term.
            Returns an invalid TermModelOperation (-1) if the term is not an operation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.ValueAsDouble">
            <summary>
            Get the value of the term, interpreted as a real
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableTerm.StoredValue">
            <summary>
            Get the double value used internally by the 
            term (violation or numerical result)
            </summary>
            <remarks>
            This is used mostly for some assertions; for normal
            use do NOT use this method.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm">
            <summary>
            Evaluable term representing a Boolean expression but where
            the value of the term is in fact a violation indicator, which
            is positive if the expression is false and negative if it is true.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm.Violation">
            <summary>
            The current violation of the term
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm.Value">
            <summary>
            The Boolean value of the term
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm">
            <summary>
            Evaluable term with a numerical value. 
            This value is always a double for simplicity, although some
            terms might be constrained to discrete values
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm.Value">
            <summary>
            The current value of the term
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableUnaryBooleanTerm">
            <summary>
            Root class for Boolean terms that have a Boolean numerical input
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryBooleanTerm">
            <summary>
            Root class for Boolean terms that have two Boolean inputs
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNaryBooleanTerm">
            <summary>
            Root class for Boolean terms that have an array of Boolean inputs
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableUnaryNumericalTerm">
            <summary>
            Root class for numerical terms that have a single numerical input
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryNumericalTerm">
            <summary>
            Root class for numerical terms that have two numerical inputs
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNaryNumericalTerm">
            <summary>
            Root class for numerical terms that have an array of numerical inputs
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableVariable">
            <summary>
            Variable, whose value can be explicitly modified
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableVariable.#ctor(System.Double,Microsoft.SolverFoundation.Solvers.LocalSearchDomain)">
            <summary>
            Variable with an initial value and specific domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableVariable.#ctor(System.Double)">
            <summary>
            Variable with a default domain (full set of real values)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableVariable.Domain">
            <summary>
            A domain can optionally be attached to the variable
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableConstant">
            <summary>
            Constants, with an immutable real value
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableConversionBooleanToNumerical">
            <summary>
            Conversion Term: use when a Boolean term should be interpreted as an integer
            </summary>
            <remarks>
            Make sure to cache those terms: at most one should be constructed
            for any boolean term, and their construction should be rare
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableConversionNumericalToBoolean">
            <summary>
            Conversion Term: use when a numerical should be interpreted as a Boolean
            </summary>
            <remarks>
            Make sure to cache those terms: at most one should be constructed
            for any boolean term, and their construction should be rare
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNormalizationTerm">
            <summary>
            A term that takes as inputs a Boolean term and whose value is the numerical
            normalized violation in [0, 1]. 
            This is done by maintaining the maximum violation
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableNormalizationTerm.QuadraticIncreaseLimit">
            <summary>
            Normalization scales quadratically up to this limit, then 
            logarithmically. The function is anyway 'strictly increasing'
            (up to limitations due to floating point rounding).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableNormalizationTerm.Normalize(System.Double)">
            <summary>
            A slowly-increasing normalization function
            </summary>
            <remarks>
            The intention is to prevent some terms from having an enormous
            violation (say x should be equal to y, with large domains
            and current values 1e-6 and 1e+6: the violation is 2e+6)
            that can overwhelm the cumulated violation function 
            (if we have another equality constraint between two variables
            in [0, 1] the violation of this constraint will be negligible). 
            
            Note that internal violations use a symmetric negative
            scoring (truth degrees can vary, this allows the scoring to
            be well-behaved w.r.t. negation for instance). In this term
            we convert this back to a externally visible violation that is 
            intended to be summed. This violation should be non-negative, 
            with value 0 IFF the Boolean term represented is satisfied.
            </remarks>
            <param name="violation">
            A non-zero violation: 
            strictly negative if the Boolean term it represents is satisfied
            strictly positive if it is violated,
            NaN if the truth of the term could not even be correctly determined
            (which is treated as the highest possible violation)
            </param>
            <returns>
            A non-negative violation indicator, 
            treated as a regular, non-NaN, numerical value
            (NOT an internal violation):
            Strictly zero if the Boolean term it represents is satisfied,
            Strictly positive if the Boolean term is violated. 
            </returns>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableUnaryMinus">
            <summary>
            A term -X where X is a numerical term
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableUnaryIdentity">
            <summary>
            A term Identity of X where X is a numerical term
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryProduct">
            <summary>
            A product of the form X * Y, where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableProduct">
            <summary>
            A product of the form X1*X2*..., where X is a vector of numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableProductByConstant">
            <summary>
            A product of the form X * Y, where X and Y are numerical terms
            Specialized for the case where Y is Constant
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableQuotient">
            <summary>
            A quotient of the form X / Y, where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryPlus">
            <summary>
            A sum of the form X + Y, where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluablePlusWithConstant">
            <summary>
            A sum of the form X + Y, where X and Y are numerical terms
            Specialized for the case where Y is Constant
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableMinus">
            <summary>
            A difference of the form X - Y, where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableSum">
            <summary>
            A sum of terms
            </summary>
            <remarks>
            For sums one choice could be simply to have a unique
            version, EvaluableSumWithRealCoefs. The array of coefficients
            can be null if all coefficients are 1. 
            
            We specialise the code so that we can store arrays of ints
            as such, rather than systematically using doubles everywhere.
            So we have one class for simple sums with no coefs, one for
            double coefficients, one for integer coefficients.
            
            The only reason to do that is that these are straightforward, 
            if modest, optimizations to do, with little code added, or
            just a different organization of the code. If we can divide
            by two the storage of coefficients by using 32-bit integers
            rather than doubles, why not do it?
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableSimpleSum">
            <summary>
            A sum of the form sum_i X[i]
            where X is a vector of numerical terms.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableWeightedIntSum">
            <summary>
            A sum of the form sum_i COEF[i]*X[i] 
            where X is a vector of numerical terms, and the coefficients are integers
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableWeightedIntSum.#ctor(System.Int32[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            A sum of the form sum_i coef[i]*x[i]
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableWeightedRealSum">
            <summary>
            A sum of the form sum_i COEF[i]*X[i] 
            where X is a vector of numerical terms, and the coefficients are doubles
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluableWeightedRealSum.#ctor(System.Double[],Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm[])">
            <summary>
            A sum of the form sum_i coef[i]*x[i]
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableUnaryNumericalFunction">
            <summary>
            A term of the form F(X), where X is a numerical term and 
            F is a function from double to double
            </summary>
            <remarks>
            Intended for functions that require some amount of computation
            such as Exp, cosine. For those functions the overhead of an
            extra delegate call in addition to the virtual Recompute call
            is probably fine; and the gain in factoring all of them with
            one type of term is clear.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryNumericalFunction">
            <summary>
            A term of the form F(X), where X is a numerical term and 
            F is a binary (two-argument) real-valued function
            </summary>
            <remarks>
            Intended for functions that require some amount of computation
            such as Pow
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableAbs">
            <summary>
            A term Abs(X), where X is a numerical term
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryMin">
            <summary>
            A sum of the form Min(X, Y), where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryMax">
            <summary>
            A sum of the form Max(X, Y), where X and Y are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableMin">
            <summary>
            A product of the form Min(X1, X2...) where X is a vector of numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableMax">
            <summary>
            A product of the form Max(X1, X2...) where X is a vector of numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableIf">
            <summary>
            A product of the form If(Cond, caseTrue, caseFalse) 
            where Cond is a Boolean term, and caseTrue and caseFalse are numerical terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNaryNumericalFunction">
            <summary>
            A term of the form F(X), where X is a numerical term and 
            F is an n-ary real-valued function
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBooleanIdentity">
            <summary>
            A term Identity of X where X is a Boolean term
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNot">
            <summary>
            A term of the form not(X), where X is a Boolean term
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryAnd">
            <summary>
            A term of the form X and Y, where X and Y are Boolean terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryOr">
            <summary>
            A term of the form X or Y, where X and Y are Boolean terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableAnd">
            <summary>
            A term of the form And(X1, X2...), where the Xs are Boolean terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableOr">
            <summary>
            A term of the form Or(x1, X2...), where the Xs are Boolean terms
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableEqual">
            <summary>
            A term of the form X equals Y where X and Y are numerical terms
            </summary>
            
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableEqual.Tolerance">
            <summary>
            0 if the equality is strict;
            A positive (usually small) value indicates that two values
            that are different but within distance at most Tolerance
            are effectively considered equal
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableDifferent">
            <summary>
            A term of the form X notEqualTo Y where X and Y are numerical terms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryLessEqual">
            <summary>
            A term of the form X lessEqual Y where X and Y are numerical terms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBinaryLessStrict">
            <summary>
            A term of the form X lessStrict Y where X and Y are numerical terms
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableLessEqual">
            <summary>
            A term true if the values of the sequence X1, X2, X3... are non-decreasing
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableLessStrict">
            <summary>
            A term true if the values of the sequence X1, X2, X3... are strictly increasing
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableRangeConstraint">
            <summary>
            A Boolean term of them form X in [Lower, Upper]
            Where is is a numerical term, and Lower/Upper are constants
            </summary>
            <remarks>
            This is equivalent to LessEqual(Lower, X, Upper).
            The only reason for a specialized implementation is that we need 
            to be able to look-up the bounds of the constraints and it is even
            easier if we can modify them. This is because we can SetBounds of
            arbitrary numerical terms, and modify any of the Bounds arbitrarily.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.EvaluableRangeConstraint.Tolerance">
            <summary>
            0 if the equality is strict;
            A positive (usually small) value indicates that two values
            that are different but within distance at most Tolerance
            are effectively considered equal
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IEvaluationObserver">
            <summary>
            Term that is notified of any change in a term of lower depth
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IEvaluationObserver.ValueChange(Microsoft.SolverFoundation.Solvers.EvaluableTerm,System.Double,System.Double)">
            <summary>
            Signals to the observer that the value of the term has changed
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableNumericalObservable">
            <summary>
            A term whose value is always maintained equal to the value
            of another term T, and which informs an observer of the changes of value of T.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableBooleanObservable">
            <summary>
            A Boolean term whose violation is always maintained equal to the violation
            of another term T, and which informs an observer of changes of violation of T.
            </summary>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluableAllDifferent">
            <summary>
            A term of the form AllDifferent (X1 ... Xn) where all args are numerical
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableAllDifferent._inputs">
            <summary>
            The inputs of the alldiff are in fact the observers 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.EvaluableAllDifferent._count">
            <summary>
            A dictionary containing pairs (value taken by all inputs,
            number of inputs that have the corresponding value)
            </summary>
            <remarks>
            This can be improved: in the CSP local search a data-structure
            called LSValueMap is used which uses array indexing if the values
            are continous - this is common with AllDifferents - and a Dictionary
            otherwise.
            </remarks>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.EvaluationStatics">
            <summary>
            Static Utilities
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.Union``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Union of two IEnumerables
            </summary>
            <remarks>
            If using .NET framework 4 this is simply Enumerable.Union, which 
            takes care correctly of co/contra-variance.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.ExpensiveAssert(System.Func{System.Boolean})">
            <summary>
            Amortized expensive assertions, ran only probabilistically
            to amortize its cost
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.Permutate``1(``0[],System.Random)">
            <summary>
            Randomly permutates the elements in an array
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.SetEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the two sequences have the same elements
            (set semantics: multiple occurrences 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.SnapshotRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new array that contains the content of the array from 
            indexes first to last, inclusive
            </summary>
            <remarks>
            (1) Could not find a way to do that by more direct use of library calls?
            (2) I like extension methods - now they might polute the Intellisense for
            arrays in the whole project, so using good old static method here
            </remarks>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.IsInteger32(System.Double)">
            <summary>
            Can the double be stored as an 32-bit integer value?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.IsInteger64(System.Double)">
            <summary>
            Can the double be stored as an 64-bit integer value?
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.NextLong(System.Random)">
            <summary>
            Generation of 64-bit pseudo-random number.
            For consistency with Next(int) the number is non-negative
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.NextUnboundedDouble(System.Random)">
            <summary>
            Generation of a double pseudo-random nonnegative number
            not bounded to be in [0,1], .e.g any representable double.
            The number can be positive or negative. It is never
            an infinity, a NaN, MinValue or MaxValue
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.NextDouble(System.Random,System.Double,System.Double)">
            <summary>
            Selects a double uniformly at random within the bounds
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.EvaluationStatics.NextLong(System.Random,System.Int64,System.Int64)">
            <summary>
            Selects a random element within the left bound inclusive and 
            the right bound EXCLUSIVE
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchDomain">
            <summary>
            The Domain of variables used by local search.
            Contain real values. 
            Can be sampled in several ways, exhaustively enumerated when finite, etc.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.AttemptsCount">
            <summary>
            Max number of attempts when we pick a new value for a variable 
            that has THIS domain, and try to generate a value different from
            the variable's current value
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Booleans">
            <summary>
            The domain for Booleans
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.DefaultDomain">
            <summary>
            The default domain is the maximum real domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Sample(System.Random)">
            <summary>
            Extract an element from the domain, uniformly at random
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.PickNeighbour(System.Random,System.Double,System.Double)">
            <summary>
            Select at random a value from the domain that is 
            preferably at a limited distance from the current value. 
            </summary>
            <remarks>
            The distance contract is not guaranteed to be respected,
            only given as hint and respected if doing it is easy to do
            and is valuable. 
            </remarks>
            <param name="prng">
            A pseudo-random number generator
            </param>
            <param name="currentValue">
            An initial value from the domain
            </param>
            <param name="distance">
            Maximum distance allowed for the new point
            </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Contains(System.Double)">
            <summary>
            True if the value is included in the Domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Enumerate">
            <summary>
            Protected method used for enumeration
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Ceiling(System.Double)">
            <summary>
            Ceiling. Result is bound to be within MinValue, MaxValue 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Floor(System.Double)">
            <summary>
            Floor. Result is bound to be within MinValue, MaxValue
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.CastAsInteger(System.Double)">
            <summary>
            A cast operation that bounds the result 
            to be within MinValue, MaxValue
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Cardinality">
            <summary>
            Number of elements in the domain; 
            by convention long.MaxValue if the domain is continuous
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Width">
            <summary>
            Difference between the Lower and Upper bounds
            (in particular 0 if identical)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Lower">
            <summary>
            Smallest value in the domain
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.Upper">
            <summary>
            Highest value in the domain
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.IsFinite">
            <summary>
            True if the domain has finite cardinality
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.LocalSearchDomain.IsDiscrete">
            <summary>
            True if the domain contains only integer values
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchContinuousInterval">
            <summary>
            Continuous interval of values
            </summary>
            <remarks>
            Right now the only truly continuous domain that we handle is interval;
            unions of intervals would in general probably make sense
            </remarks>
            
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchIntegerInterval">
            <summary>
            Domain of integer values of the form left .. right
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.LocalSearchIntegerInterval.SmallDomainLimit">
            <summary>
            Under this limit the domains are considered small and 
            we essentially ignore any distance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LocalSearchIntegerInterval.NextInteger(System.Random,System.Int64,System.Int64)">
            <summary>
            both bounds are INCLUSIVE
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchFiniteRealSet">
            <summary>
            Domain containing a finite number of real values
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LocalSearchFiniteIntegerSet">
            <summary>
            Domain containing a finite number of integer values
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HybridLocalSearchProperties">
            <summary>
            Properties that can be retrieved on the local search solver
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchProperties.Step">
            <summary>
            The Step property indicates the current count of 
            steps that the search has performed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchProperties.Violation">
            <summary>
            Constraints violation. Zero stands for no violation (feasible solution), 
            and the smaller Violation is the more solution tends toward feasibility.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters">
            <summary>HybridLocalSearch parameters.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.#ctor">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary> Create a new instance from a Directive.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.Solving">
            <summary>
            Callback called during solve when the solver changes states and,
            in particular, when it finds a new interesting solution
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.QueryAbort">
            <summary>
            Get/set the callback function that decides when to abort the search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.RunUntilTimeout">
            <summary>
            Specifies that the Solve() method should never return. 
            Instead, the solver will run until interrupted (timeout or callback)
            and will regularly trigger events when improved solutions are found.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.TimeLimitMs">
            <summary>
            Timelimit in milliseconds. If negative, no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.PresolveLevel">
            <summary>Presolve level. (-1 is automatic, 0 is no presolve).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters.EqualityTolerance">
            <summary>
            Tolerance for values to be still considered equal.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel">
            <summary>The model for the HybridLocalSearchSolver.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.LargeSearchAcceptance">
            <summary>
            Precision at which Large Search stops searching: moves that improve any
            quality measure by less than this number are just ignored. This is to 
            ignore long chains of insignificant improvements (by steps of say 1e-10),
            which can otherwise happen
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.#ctor">
            <summary>
            A solver that uses simple, general-purpose local search strategies.
            Can be used for discrete and continuous, linear and non-linear,
            satisfaction and/or optimization models.
            This solver is incomplete: it does not guarantee optimality. 
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.PreChange">
            <summary>
            Should be called at the beginning of any method that modifies This 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Register(Microsoft.SolverFoundation.Solvers.EvaluableTerm)">
            <summary>
            Recods any newly created term.
            Should be called by ANY variable / operation creation method.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateNumericalVariable(Microsoft.SolverFoundation.Solvers.LocalSearchDomain)">
            <summary>
            Creates a variable with the specified domain 
            The initial value of the variable is chosen within the domain
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateRealVariable(System.Double,System.Double)">
            <summary>
            Creates a new variable that can be assigned any real value
            that is at least the lowerBound and at most the upperBound
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateIntegerVariable(System.Int64,System.Int64)">
            <summary>
            Creates a new variable that can be assigned any integer value
            that is at least the lowerBound and at most the upperBound
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateRealVariable(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Creates a new variable that can be assigned 
            a finite number of real values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateIntegerVariable(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Creates a new variable that can be assigned 
            a finite number of integer values
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateConstant(System.Double)">
            <summary>
            Creates a term whose value is real and immutable
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateConstant(System.Boolean)">
            <summary>
            Create a Boolean term whose value is constant
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetAllVariables">
            <summary>
            Get all the variables, Boolean and numerical
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreatePlus(System.Int32,System.Int32)">
            <summary>
            Creates the sum of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreatePlus(System.Int32[])">
            <summary>
            Creates the sum of a set of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateWeightedSum(System.Int32[],System.Int32[])">
            <summary>
            Creates the sum of a set of terms, weighted by coefficients
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateWeightedSum(System.Double[],System.Int32[])">
            <summary>
            Creates the sum of a set of terms, weighted by coefficients
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMinus(System.Int32,System.Int32)">
            <summary>
            Creates the difference of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMinus(System.Int32)">
            <summary>
            Creates the opposite (unary minus) of a term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateIdentity(System.Int32)">
            <summary>
            Creates the identity of a term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateAbs(System.Int32)">
            <summary>
            Creates the Absolute value of a term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateQuotient(System.Int32,System.Int32)">
            <summary>
            Creates the quotient (division) of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateTimes(System.Int32,System.Int32)">
            <summary>
            Creates the product of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateTimes(System.Int32[])">
            <summary>
            Creates the product of a set of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMin(System.Int32,System.Int32)">
            <summary>
            Creates the minimum of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMin(System.Int32[])">
            <summary>
            Creates the minimum of a set of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMax(System.Int32,System.Int32)">
            <summary>
            Creates the maximum of two terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateMax(System.Int32[])">
            <summary>
            Creates the maximum of a set of terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateAllDifferent(System.Int32[])">
            <summary>
            Creates a term that is true if the arguments are all different
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateUnequal(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the two arguments are different
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateEqual(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the two arguments are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateEqual(System.Int32[])">
            <summary>
            Creates a term that is true if the all the arguments are equal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLess(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the arguments are in strictly increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLess(System.Int32[])">
            <summary>
            Creates a term that is true if the arguments are in strictly increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateGreater(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the arguments are in strictly decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateGreater(System.Int32[])">
            <summary>
            Creates a term that is true if the arguments are in strictly decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLessEqual(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the arguments are in non-decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLessEqual(System.Int32[])">
            <summary>
            Creates a term that is true if the arguments are in non-decreasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateGreaterEqual(System.Int32,System.Int32)">
            <summary>
            Creates a term that is true if the arguments are in non-increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateGreaterEqual(System.Int32[])">
            <summary>
            Creates a term that is true if the arguments are in non-increasing order
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateAnd(System.Int32,System.Int32)">
            <summary>
            Creates a term that is represents the logical And of two Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateAnd(System.Int32[])">
            <summary>
            Creates a term that is represents the logical And of a set of Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateOr(System.Int32,System.Int32)">
            <summary>
            Creates a term that is represents the logical Or of two Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateOr(System.Int32[])">
            <summary>
            Creates a term that is represents the logical Or of a set of Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateNot(System.Int32)">
            <summary>
            Creates a term that is represents the logical Or of two Boolean terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateIf(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a term of the form arg1 ? arg2 : arg3
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateSin(System.Int32)">
            <summary>
            Creates the Sine of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateCos(System.Int32)">
            <summary>
            Creates the Cosine of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateTan(System.Int32)">
            <summary>
            Creates the Tangent of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateSinh(System.Int32)">
            <summary>
            Creates the hyperbolic Sine of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateCosh(System.Int32)">
            <summary>
            Creates the hyperbolic Cosine of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateTanh(System.Int32)">
            <summary>
            Creates the hyperbolic Tangent of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateArcSin(System.Int32)">
            <summary>
            Creates the ArcSin of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateArcCos(System.Int32)">
            <summary>
            Creates the ArcCos of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateArcTan(System.Int32)">
            <summary>
            Creates the ArcTan of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateCeiling(System.Int32)">
            <summary>
            Creates the Ceiling of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateFloor(System.Int32)">
            <summary>
            Creates the Floor of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateExp(System.Int32)">
            <summary>
            Creates a term representing E raised to the power x, where x is a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateSqrt(System.Int32)">
            <summary>
            Creates the square root of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLog10(System.Int32)">
            <summary>
            Creates the base 10 log of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateLog(System.Int32)">
            <summary>
            Creates the base E log of a numerical term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreatePower(System.Int32,System.Int32)">
            <summary>
            Creates a term representing x raised to the given power
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateUnaryFunction(System.Func{System.Double,System.Double},System.Int32)">
            <summary>
            Creates a term that is the application of an arbitrary, user-defined 
            function to another term
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateBinaryFunction(System.Func{System.Double,System.Double,System.Double},System.Int32,System.Int32)">
            <summary>
            Creates a term that is the application of an arbitrary, user-defined 
            function to two other terms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CreateNaryFunction(System.Func{System.Double[],System.Double},System.Int32[])">
            <summary>
            Creates a term that is the application of a user-defined function to two other terms.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddConstraint(System.Int32)">
            <summary>
            Specifies that a numerical term is a constraint
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RemoveConstraint(System.Int32)">
            <summary>
            Removes a Boolean term from the set of constraints
            </summary>
            <returns>
            True if the constraint is successfully removed
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.ExtractBooleanArg(System.Int32)">
            <summary>
            Gets (and validates) the argument with the given ID, seen as a Boolean
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.ExtractNumericalArg(System.Int32)">
            <summary>
            Gets (and validates) the argument with the given ID, seen as Numerical
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetConversionToBool(Microsoft.SolverFoundation.Solvers.EvaluableNumericalTerm)">
            <summary>
            Get the term that represents the Boolean value of a numerical term.
            Conversions terms are cached in a Dictionary
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetConversionToNum(Microsoft.SolverFoundation.Solvers.EvaluableBooleanTerm)">
            <summary>
            Get the term that represents the numerical value of a Boolean term
            Conversions terms are cached in a Dictionary
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._conversionsToNum">
            <summary>
            Caches the terms introduced to convert Boolean to numerical terms.
            Always use in pair with _conversionsToBool
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._conversionsToBool">
            <summary>
            Caches the terms introduced to convert numerical to Boolean terms.
            Always use in pair with _conversionsToNum
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._currentQuality">
            <summary>
            Quality of the current search state
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._bestQuality">
            <summary>
            Quality of the best solution found so far
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._bestSolution">
            <summary>
            Best solution found so far, 
            saves the Values of the _allVariables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._searchTimer">
            <summary>
            Timer started at beginning of the search
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._searchParameters">
            <summary>
            Parameters passed to the search algorithm
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._searchTerminationRequested">
            <summary>
            True if a termination has been requested
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._invalidModelAtConstruction">
            <summary>
            Flag that is set to true whenever an invalid construct is 
            found in the model
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.InitializeSearchData(Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters)">
            <summary>
            (Re)initializes all fields related to the search algorithm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.CheckIfBestSolution">
            <summary>
            Checks if the current solution is better than the best solution.
            If so updates the best solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SaveBestSolution">
            <summary>
            Save the current state as best solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SnapshotState(System.Double[])">
            <summary>
            Save the current of all variables into an array
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RestoreState(System.Double[])">
            <summary>
            Reinitialized all variables to the snapshot of a previous state
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RestoreBestSolution">
            <summary>
            Bring the current state back to the best found solution
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RequestTermination">
            <summary>
            Request the end of the search algorithm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RecomputeCurrentState">
            <summary>
            Recomputes the evaluation and updates the current quality.
            Returns the Comparison with the previous quality
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.DecreaseFocus">
            <summary>
            Increase the radius of the search algorithm
            (i.e. DEcrease the _focus variable)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IncreaseFocus">
            <summary>
            Decrease the radius of the search algorithm
            (i.e. INcrease the _radius variable)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Continue">
            <summary>
            Checks whether the search should go on 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Compare(System.Double[],System.Double[])">
            <summary>
            Compares the two arrays of the same length lexicographically,
            returns the first index where a difference occurs, and the difference:
            Negative difference means that the first argument is better (lower);
            Positive difference means that the second argument is better;
            0 if we cannot tell, in which case the index is negative.
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SafeMinus(System.Double,System.Double)">
            <summary>
            Compares two violations or objective functions to minimize:
            Negative means that the first argument is better (lower)
            Positive means that the second argument is better
            0 if we cannot tell.
            Deals with infinities and Nans. NaNs are treated worse than anything else.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._focus">
            <summary>
            Number from 0 to MaxFocus that determines how focussed the search 
            should be (higher: More focussed). 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Distance">
            <summary>
            Lists the possible diameters to consider when 
            doing 'radius search'. 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.MinFocus">
            <summary>
            Minimal value of the focus parameter of method PickNeighbour.
            Means that points at arbitrarily large distance from the current point
            will be considered
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.MaxFocus">
            <summary>
            Minimal value of the focus parameter of method PickNeighbour.
            Means that only points at a small distance from the current point 
            will be considered
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RadiusSearch(Microsoft.SolverFoundation.Solvers.HybridLocalSearchParameters)">
            <summary>
            Main search algorithm.
            </summary>
            <remarks>
            This algorithm is not aimed at being tuned by the user;
            instead the goal is to have as good a behaviour as possible
            by default, and to reach good local minima. 
            </remarks>
            <returns>The NonlinearResult of the search</returns>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetSearchResult(System.Boolean)">
            <summary>
            We return the best solution we know. Optimal if we can prove optimality, Interrupted just if don't have feasible solution
            </summary>
            <param name="localOptimaFound"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.ReachLocalMinimum">
            <summary>
            Perform a series of large- and small-neighborhood steps
            with increasing focus; until reaching a point from which
            no improvement can be found within a small radius. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SmallNeighborhoodSearch">
            <summary>
            A local improvement algorithm that makes repeated 
            small (one variable) moves. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.LargeNeighborhoodSearch">
            <summary>
            A local improvement algorithm that makes a small number of
            large moves (in the sense: all variables are changed, their new value
            is taken within the radius)
            </summary>
            <returns>
            True if an improvement is found
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.InitialState">
            <summary>
            Generates the starting point of the search
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Escape">
            <summary>
            Called when the search is stuck in a local minimum:
            could either restart fully or just perturbate partially the 
            current assignment
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.DecideVariable">
            <summary>
            Default method for selecting a variable: 
            if one constraint at least is violated we pich a conflict variable;
            otherwise we select a variable at random
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.PeekConflictingVariable">
            <summary>
            Select randomly a variable that contributes to at least 
            one violated constraint
            </summary>        
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._enumerator">
            <summary>
            An enumerator used by PeekConflictingVariable to return different
            variables every time it is called, based on a buffering of the
            ComputeCause method
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.PeekVariable">
            <summary>
            Select a variable uniformly at random
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._evaluator">
            <summary>
            The evaluator, that keeps all terms, and maintains their values/violations
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._allTerms">
            <summary>
            A list of all terms constructed in this problem
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._allVariables">
            <summary>
            All numerical variables created in this problem
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._prng">
            <summary>
            Pseudo-random number generator attached to this search
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._indexFromKey">
            <summary>
            Mapping from row/column keys to indexes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._keyFromIndex">
            <summary>
            Mapping from row/column indexes to their associated keys
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.goalList">
            <summary>
            Goals, or objectives to minimize or maximize
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._modelReadCount">
            <summary>
            Depth of iterators currently reading This
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsKeyAlreadyPresent(System.Object)">
            <summary>
            True if key NOT NULL and already present
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Associate(System.Int32,System.Object)">
            <summary>
            Associate the key to the index; 
            mapping is bi-directional
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32)">
            <summary>
            Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32)">
            <summary>
            Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds an operation row to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddFunction(System.Func{System.Double[],System.Double},System.Int32@,System.Int32[])">
            <summary>
            Add a user-defined function.
            </summary>
            <param name="fun">A user defined function.</param>
            <param name="vidOp">The vid for the function.</param>
            <param name="vids">The vids that represent the arguments.</param>
            <returns>True if a new vid was created for the function.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddOperation(Microsoft.SolverFoundation.Services.TermModelOperation,System.Int32@,System.Int32[])">
            <summary>
            Adds an operation row to the model.
            </summary>
            <remarks>
            This overload is supported for the following TermModelOperation values:
            And, Equal, Greater, GreaterEqual, Less, LessEqual, Max, Min, Or, Plus, Times, Unequal.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddVariable(System.Object,System.Int32@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean)">
            <summary>
            Adds a variable to the model, with bounds and integrality given at creation time.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddVariable(System.Object,System.Int32@,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            Adds a variable to the model, with a fixed set of possible values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddVariable(System.Int32@,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Common.Rational})">
            <summary>
            Adds a variable to the model, with a fixed set of possible values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddVariable(System.Int32@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,System.Boolean)">
            <summary>
            Adds a variable to the model, with bounds and integrality given at creation time.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddConstant(Microsoft.SolverFoundation.Common.Rational,System.Int32@)">
            <summary>
            Adds a constant to the model. Constants are considered rows.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsOperation(System.Int32)">
            <summary>
            Tests if a vid is an operation (not a variable or constant).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsConstant(System.Int32)">
            <summary>
            Tests if a vid is a constant (not a variable or operation).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetOperation(System.Int32)">
            <summary>
            Gets the operation associated with a vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetOperandCount(System.Int32)">
            <summary>
            Gets the number of operands associated with a vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetOperands(System.Int32)">
            <summary>
            Gets the operands associated with a vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetOperand(System.Int32,System.Int32)">
            <summary>
            Gets an operand associated with a vid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetIndexFromKey(System.Object)">
            <summary>
            Maps the variable index from the key. If not found, KeyNotFoundException will be thrown 
            </summary>
            <param name="key"></param>
            <returns>variable index </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.TryGetIndexFromKey(System.Object,System.Int32@)">
            <summary>
            Try to get the variable index based on the key
            </summary>
            <param name="key">the key value </param>
            <param name="vid">the variable index </param>
            <returns>true if the variable exists, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetKeyFromIndex(System.Int32)">
            <summary>
            Map from the variable index to the key. If not found, ArgumentException will be thrown
            </summary>
            <param name="vid">the variable index</param>
            <returns>the variable key</returns>
            <remarks>key might be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsRow(System.Int32)">
            <summary>
            Validate if it is a row index and not a variable index.
            </summary>
            <param name="vid">row index</param>
            <returns>True if a row otherwise false.</returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel._boundConstraints">
            <summary>
            Bookkeeping of any bound constraint associated to Boolean or Numerical terms. 
            Allows to RemoveConstraint when a new SetBounds is done on a term that already has bounds
            </summary>
            <remarks>
            For a Boolean term the bound constraint attached to it can be:
            - itself! if we have done imposed that term is true 
              (lower bound = 1)
            - a term expressing its negation: if we have imposed that the term is false 
              (upper bound = 0)
            
            For a numerical term the bound constraint attached to it is always
            an EvaluableRange constraint.
            
            NOTE: for a Boolean term X we could use the approach where we treat it as 
            a numerical term, create an EvaluableRange, and add this evaluableRange
            constraint. But this would amount to create a Boolean term (evaluableRange)
            that represents that another Boolean term (X) is true, and this would also
            introduce a conversion term. The more natural approach is to directly 
            add X (or its negation) as a constraint.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the lower bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="numLo">The lower bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust the upper bound of the vid. 
            </summary>
            <param name="vid">A vid.</param>
            <param name="numHi">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set the bounds for a vid.</summary>
            <remarks>
            Logically, a vid may have an upper bound of Infinity and/or a lower bound of -Infinity. 
            Specifying any other non-finite values for bounds should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            and ArgumentException is thrown.  
            </remarks>
            <param name="vid">A vid.</param>
            <param name="numLo">The lower bound.</param>
            <param name="numHi">The upper bound.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary> Return the bounds for the vid.
            </summary>
            <param name="vid">A vid.</param>
            <param name="numLo">The lower bound returned.</param>
            <param name="numHi">The upper bound returned.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            </summary>
            <param name="key"> Variable key </param>
            <param name="vid">variable index </param>
            <returns>true if added successfully, otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Microsoft#SolverFoundation#Services#IRowVariableModel#GetValue(System.Int32)">
            <summary>
            Get the value associated with the variable index. This is typically used to fetch solver result 
            </summary>
            <param name="vid">a variable index</param>
            <returns>the variable value</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SetValue(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Sets the default value for a vid.
            </summary>
            <remarks>
            The default value for a vid is Indeterminate. An IRowVariableModel can be used to represent not just a model, 
            but also a current state for the model’s (user and row) variables. 
            The state associates with each vid a current value represented as a Rational. 
            This state may be used as a starting point when solving, and may be updated by a solve attempt. 
            Some solvers may ignore this initial state for rows and even for variables.
            </remarks>
            <param name="vid">A vid.</param>
            <param name="num">The default value for the variable.</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SetIntegrality(System.Int32,System.Boolean)">
            <summary>
            Mark a variable as an integer variable 
            </summary>
            <param name="vid">a variable index </param>
            <param name="fInteger">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetIntegrality(System.Int32)">
            <summary>
            Check if a variable is an integer variable
            </summary>
            <param name="vid">a variable index</param>
            <returns>true if this variable is an integer variable. Otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddGoal(System.Int32,System.Int32,System.Boolean)">
            <summary>Mark a row as a goal.
            </summary>
            <param name="vid">A row id.</param>
            <param name="pri">The priority of the goal (smaller values are prioritized first).</param>
            <param name="minimize">Whether to minimize the goal row.</param>
            <returns>An IGoal object representing the goal.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsGoal(System.Int32)">
            <summary>
            Check if a row id is a goal row.
            </summary>
            <param name="vid">A row id.</param>
            <returns>True if this a goal row, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IsGoal(System.Int32,Microsoft.SolverFoundation.Services.IGoal@)">
            <summary>
            Check if a row id is a goal and retreive the associated IGoal. 
            </summary>
            <param name="vid">A row id.</param>
            <param name="goal">The IGoal corresponding to the vid.</param>
            <returns>True if this a goal row, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RemoveGoal(System.Int32)">
            <summary>
            Remove a goal row.
            </summary>
            <param name="vid">A row id.</param>
            <returns>True if the goal was removed, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.ClearGoals">
            <summary>
            Clear all the goals .
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GetGoalFromIndex(System.Int32)">
            <summary>
            Return a goal entry if the row id is a goal
            </summary>
            <param name="vid">A variable id.</param>
            <returns>A goal entry. Null if the vid does not correspond to a goal.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.AddGoal(System.Int32)">
            <summary>
            Specifies that a numerical term is a goal to minimize.
            Priorities are determined by the order in which the goals are added
            (first goals have higher priorities)
            </summary>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.PrepareGoals">
            <summary>
            (re-)computes the set of goals and adds them to the evaluator
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RandomSeed">
            <summary>
            Set the random seed that (re)initializes the random 
            number sequence generation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Step">
            <summary>
            Current Step Number of the search when it is running
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Violation">
            <summary>
            Violation of the current state
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.BestViolation">
            <summary>
            Violation of the best solution found so far
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Quality">
            <summary>
            Snapshot the current quality
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.SmallSearchIntensity">
            <summary>
            Magic number that determines the number of steps of the
            small neighourhood search algorithm
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.LargeSearchIntensity">
            <summary>
            Magic number that determines the number of steps of the
            small neighourhood search algorithm
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.ConstraintsCount">
            <summary>
            Number of constraints
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GoalsCount">
            <summary>
            Number of goals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.KeyComparer">
            <summary>
            Used for row or variable key comparison 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Indices">
            <summary> return the variable index collection, inclusive of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Keys">
            <summary> Return the variable and row key collection.
            Indices are guaranteed to >= 0 and &lt; KeyCount.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.KeyCount">
            <summary> the number of keys, inclusive of rows and variables.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RowIndices">
            <summary> Return the row index collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RowKeys">
            <summary> Return the row key collection. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.RowCount">
            <summary> The number of rows in the model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.VariableIndices">
            <summary>
            return the variable index collection
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.VariableKeys">
            <summary>
            return the variable key collection 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.VariableCount">
            <summary>
            return the variable count 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.IntegerIndexCount">
            <summary> return the number of integer variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goals">
            <summary>
            Return the goal collection of this model. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.GoalCount">
            <summary>
            The number of goals in this model.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal">
            <summary>
            information attached to every goal
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal.Key">
            <summary> the goal variable key  </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal.Index">
            <summary> The variable index (vid) of this goal's row </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal.Priority">
            <summary> the goal priority. The lower the value, the higher the priority </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal.Minimize">
            <summary> whether the goal is to minimize the objective row </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchModel.Goal.Enabled">
            <summary> whether the goal is enabled </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver">
            <summary>
            A solver that uses simple, general-purpose local search strategies.
            </summary>
            <remarks>
            Can be used for discrete and continuous, linear and non-linear,
            satisfaction and/or optimization models.
            This solver is incomplete: it does not guarantee global optimality. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary> 
            Solve the model using the given parameter instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.Shutdown">
            <summary> Shutdown the solver instance
            </summary>
            <remarks>Solver needs to dispose any unmanaged memory used upon this call.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.GetValue(System.Int32)">
            <summary>
            Return the value for the variable (or optionally row) with the specified vid. 
            </summary>
            <param name="vid">A variable id.</param>
            <returns>The value of the variable as a double.</returns>
            <remarks>
            This method can always be called with variable vids. Some solvers support row vids as well.
            The value may be finite, infinite, or indeterminate depending on the solution status.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.GetSolutionValue(System.Int32)">
            <summary>
            Get the objective value of a goal.
            </summary>
            <param name="goalIndex">A goal id.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get the information for a solved goal.
            </summary>
            <param name="igoal">The goal index: 0 &lt;= goal index &lt; SolvedGoalCount.</param>
            <param name="key">The goal row key.</param>
            <param name="vid">The goal row vid.</param>
            <param name="fMinimize">Whether the goal is minimization goal.</param>
            <param name="fOptimal">Whether the goal is optimal.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a solver-related property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <param name="value">The property value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.GetProperty(System.String,System.Int32)">
            <summary>Get the value of a property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <returns>The property value as a System.Object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report
            </summary>
            <param name="context">The SolverContext.</param>
            <param name="solution">The Solution.</param>
            <param name="solutionMapping">A SolutionMapping instance.</param>
            <returns>Report for model solved by CompactQuasiNewtonSolver</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.SupportedOperations">
            <summary>
            Gets the operations supported by the solver.
            </summary>
            <returns>All the TermModelOperations supported by the solver.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.SolvedGoalCount">
            <summary>Number of goals being solved.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HybridLocalSearchSolver.Result">
            <summary>
            NonlinearResult.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexSolver">
            <summary>
            Implements a branch and bound search for optimizing mixed integer problems.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.Init(System.Boolean,Microsoft.SolverFoundation.Solvers.SimplexSolverParams[])">
            <summary> Fill our data structures from the given problem
            </summary>
            <param name="fSolveMip"> If this is a MILP problem </param>
            <param name="parameters"> the array of params for thread(s) </param>
            <returns> false iff the model is found to be infeasible, typically by PreSolve </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ReInit(System.Boolean,Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Reinitialize the internal data structures.
            </summary>
            <param name="fSolveMip"></param>
            <param name="thread"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.InitModel(System.Collections.Generic.IEqualityComparer{System.Object},System.Int32,System.Int32,System.Int32)">
            <summary>Initialize the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.GetProperty(System.String,System.Int32)">
            <summary>Get the value of a property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <returns>The property value as a System.Object.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set the value of a property.
            </summary>
            <remarks>Currently there is no support for setting propery during solve.</remarks>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <param name="value">The property value.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ValidateInSolveState(System.String)">
            <summary>
            If not in solving state and property is one that solver supports, throw
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.RegisterSolution(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Services.LinearResult,System.Boolean)">
            <summary>
            Called to register a possible solution. This method determines whether the proposed
            solution is an improvement on previously registered solutions. If so, it keeps the
            new solution and returns true. If not, it keeps the previous solution and returns true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.RegisterSolution(Microsoft.SolverFoundation.Services.LinearResult,System.Boolean)">
            <summary>
            Called to register a possible solution. This method determines whether the proposed
            solution is an improvement on previously registered solutions. If so, it keeps the
            new solution and returns true. If not, it keeps the previous solution and returns true.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.RegisterMipSolutionResult(Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Called when the search for more solutions terminates. 
            </summary>
            <remarks>The call to ValidateSolution is needed to make sure that the
            registered solution is accepted. A solution is optimal only when we have
            exhausted the search tree. 
            It is possible that the thread that calls RegisterMipSolutionResult and the thread 
            that calls RegisterSolution are different. But it is OK since we do not overwrite
            _mipResult to a lower quality.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary>
            Get the information of a solved goal
            </summary>
            <param name="igoal">a goal index</param>
            <param name="key">the goal row key</param>
            <param name="vid">the goal row vid</param>
            <param name="fMinimize">whether the goal is minimization</param>
            <param name="fOptimal">whether the goal is optimal</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.GetSolutionValue(System.Int32)">
            <summary>
            get the objective value of a goal 
            </summary>
            <param name="goalIndex">goal id</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._mod">
            <summary> The simplified model that we work on. This reflects
                      pre-solve and scaling, but otherwise does not change
                      during a solve.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._rgthd">
            <summary> The threads corresponding to the array of SolverParams
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._cultureInfo">
            <summary>
             locale state of the main thread
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._cultureUIInfo">
            <summary>
             locale state of the main thread
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._fRelax">
            <summary> internal flag
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolver._solvingState">
            <summary>
            the current solving state of the solver
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.#ctor">
            <summary> Construct a SimplexSolver with defaults.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.#ctor(Microsoft.SolverFoundation.Services.ISolverEnvironment)">
            <summary> Construct a SimplexSolver with given solver environment.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary> Construct a SimplexSolver with specified comparison mechanism for keys
            </summary>
            <param name="cmp"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.Shutdown">
            <summary> Shutdown the solver
            </summary>
            <remarks>SimplexSolver is managed. So no memory needs to be explicitly disposed.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report
            
            </summary>
            <param name="context"></param>
            <param name="solution"></param>
            <param name="solutionMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary> 
            Run the solver with one SolverParam.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.Solve(Microsoft.SolverFoundation.Solvers.SimplexSolverParams[])">
            <summary> 
            Run the solver with one thread per SolverParam.
            </summary>
            <param name="parameters"> The parameters to apply to the threads </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.GetReport(Microsoft.SolverFoundation.Services.LinearSolverReportType)">
            <summary> Get sensitivity report.
            </summary>
            <param name="reportType">Simplex report type.</param>
            <returns>A linear solver report.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ToString">
            <summary>Returns a string representation of the solver.
            </summary>
            <returns>Returns a string representation of the solver.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.SolveRelaxation(Microsoft.SolverFoundation.Solvers.SimplexSolverParams[])">
            <summary> Solve a relaxation problem within MILP or similar context.
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.IsComplete(Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Checks whether the solver ran until it got a final result, i.e., it
            was not interrupted during the solve process.
            </summary>
            <param name="result">The result.</param>
            <returns>True if the solver ran to completion; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ComputeColumnDelta(Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32,Microsoft.SolverFoundation.Solvers.SimplexFactoredBasis,Microsoft.SolverFoundation.Solvers.VectorDouble)">
            <summary>
            Solve Bd = a, where "a" is the col'th column of mat.
            </summary>
            <param name="mat"></param>
            <param name="col"></param>
            <param name="bas"></param>
            <param name="vecDelta">The result. </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ComputeColumnDelta(Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32,Microsoft.SolverFoundation.Solvers.SimplexFactoredBasis,Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary>
            Solve Bd = a, where "a" is the col'th column of mat.
            </summary>
            <param name="mat"></param>
            <param name="col"></param>
            <param name="bas"></param>
            <param name="vecDelta">The result.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ComputeProductNonBasic(Microsoft.SolverFoundation.Solvers.SimplexBasis,Microsoft.SolverFoundation.Solvers.CoefMatrix,Microsoft.SolverFoundation.Solvers.VectorDouble,System.Double[])">
            <summary>
            This computes the product vec^T * mat restricted to columns of mat that non-basic and not fixed.
            The result is placed in rgnumProd. The caller is responsible for zeroing rgnumProd.
            Usually this is done incrementally to avoid O(n) operations.
            </summary>
            <param name="bas"></param>
            <param name="mat"></param>
            <param name="vec"></param>
            <param name="rgnumProd"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ComputeProductNonBasicFromExact(Microsoft.SolverFoundation.Solvers.SimplexBasis,Microsoft.SolverFoundation.Solvers.CoefMatrix,Microsoft.SolverFoundation.Solvers.VectorDouble,System.Double[])">
            <summary>
            This computes the product vec^T * mat restricted to columns of mat that non-basic and not fixed.
            The result is placed in rgnumProd. The caller is responsible for zeroing rgnumProd.
            Usually this is done incrementally to avoid O(n) operations.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.ComputeProductNonBasic(Microsoft.SolverFoundation.Solvers.SimplexBasis,Microsoft.SolverFoundation.Solvers.CoefMatrix,Microsoft.SolverFoundation.Solvers.VectorDouble,Microsoft.SolverFoundation.Solvers.VectorDouble)">
            <summary>
            This computes the product vec^T * mat restricted to columns of mat that non-basic and not fixed.
            The result is placed in vecDst.  VecDst will be cleared at start.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.InitializeLogging">
            <summary>
            Initializes the logging framework.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.AddListener(System.Diagnostics.TraceListener,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Add tracing listener 
            </summary>
            <param name="listener">a listener</param>
            <param name="ids">interested events</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolver.RemoveListener(System.Diagnostics.TraceListener)">
            <summary>
            Remove tracing listener
            </summary>
            <param name="listener">a listener</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.MipBestBound">
            <summary> Return the lower bound of a MIP model run
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.SolutionQuality">
            <summary>
            indicates the quality level of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.LpResult">
            <summary>
            Indicates the result of solving the LP relaxation, which is essentially the model with its integrality conditions ignored.
            </summary>
            <remarks>
            In the case of a model with no goals, LinearResult will be reported as Optimal.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.MipResult">
            <summary>
            Indicates the result of considering the integrality conditions
            </summary>
            <remarks>
            In the case of a model with no goals, LinearResult will be reported as Optimal.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.Result">
            <summary>
            indicates the result of the solve attempt
            </summary>
            <remarks>
            In the case of a model with no goals, LinearResult will be reported as Optimal.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.SolvedGoalCount">
            <summary>
            goal count
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.InnerIndexCount">
            <summary>
            The InnerIndexCount property returns the number of user and row variables used 
            internally when solving the linear model. This may be less than ILinearModel.KeyCount since variables may be eliminated by presolve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.InnerIntegerIndexCount">
            <summary>
            The InnerIntegerIndexCount property returns the number of integer user 
            and row variables used internally when solving the linear model. 
            This may be less than ILinearModel.IntegerIndexCount since variables may be eliminated by presolve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.InnerSlackCount">
            <summary>
            The InnerSlackCount property returns the number of row variables used internally when 
            solving the linear model. This may be less than the ILinearModel.RowCount, since row variables may be eliminated by presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.InnerRowCount">
            <summary>
            The InnerRowCount property returns the number of rows used internally when solving the linear model. 
            This may be less than ILinearModel.RowCount since rows may be eliminated by presolve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCount">
            <summary>
            The pivot count properties indicate the number of simplex pivots performed. Generally these include both major and minor pivots.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountDegenerate">
            <summary>
            The pivot count of degenerated pivots
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountExact">
            <summary>
            the pivot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountExactPhaseOne">
            <summary>
            the phase I pivot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountExactPhaseTwo">
            <summary>
            the phase II pivot count of exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountDouble">
            <summary>
            the pivot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountDoublePhaseOne">
            <summary>
            the phase I pivot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.PivotCountDoublePhaseTwo">
            <summary>
            the phase II pivot count of double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.FactorCount">
            <summary>
            The factor count properties indicate the number of basis matrix LU factorizations performed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.FactorCountExact">
            <summary>
            The factor count of exact arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.FactorCountDouble">
            <summary>
            The factor count of double arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.BranchCount">
            <summary>
            The BranchCount property indicates the number of branches performed when applying the branch and bound algorithm to a MILP. 
            If the model has no integer variables, this will be zero.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.Gap">
            <summary>
            Used by MIP to indicate the difference between an integer solution to a relaxed solution
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.UseExact">
            <summary>
            indicate whether the solve attempt was instructed to use exact arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.UseDouble">
            <summary>
            indicate whether the solve attempt was instructed to use double arithmetic
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.AlgorithmUsed">
            <summary>
            indicates which algorithm was used to by the solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.CostingUsedExact">
            <summary>
            Costing used for exact arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.CostingUsedDouble">
            <summary>
            costing used for double arithmetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolver.SolutionThread">
            <summary> Return the simplex thread that solves the user model. By "solve", we mean
            the last thread that finds a definite answer to the model and registered its 
            solution to the solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexTask._diveManager">
            <summary>
            The dive manager is used to perform limited depth-first search even when the 
            general search strategy is different (e.g., best-bound or best-estimate). 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.DoBranchAndBound(Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Solves the mixed-integer problem using branch and bound.
            </summary>
            <param name="resLp">The result of the relaxation.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.InitOnceBranchAndBound">
            <summary>
            Initializes the data structures used in branch and bound.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.InitBranchAndBound">
            <summary>
            Initializes the data structures used in branch and bound.
            </summary>
            <remarks>
            This method is called by PseudoCosts when doing strong branching.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.HasGoal">
            <summary>
            Checks whether the model has an objective.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.GetGoalCount">
            <summary>
            Gets how many objectives are in the model.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.BranchAndBound(Microsoft.SolverFoundation.Solvers.OptimalGoalValues@)">
            <summary>
            Performs one step of the branch and bound algorithm and calls itself recursively.
            </summary>
            <param name="integerOptimalGoalValues">The currently best integer solution.</param>
            <returns>
            Returns true if we solve to completion.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.EmptyDiveManager">
            <summary>
            Empties the dive manager into the general node manager.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.LogBranch(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Solvers.BoundConstraint,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Logs information about the branch.
            </summary>
            <param name="integerOptimalGoalValues">The current best integer solution.</param>
            <param name="node">The current node.</param>
            <param name="latestBoundConstraint">The latest bound constraint.</param>
            <param name="branchingVariable">The latest branching variable.</param>
            <param name="branchingValue">The latest branching value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ResetReducedModel(Microsoft.SolverFoundation.Solvers.Node@,System.Boolean)">
            <summary>
            Re-initializes the reduced model if needed.
            </summary>
            <param name="node">The current node.</param>
            <param name="forceReInit">Indicates whether reinitialization is forced.</param>
            <returns>False if the model is detected to be infeasible; true otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ApplyConstraints(Microsoft.SolverFoundation.Solvers.Node@)">
            <summary>
            Applies the constraints to the node. 
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.NodePresolve(Microsoft.SolverFoundation.Solvers.Node@,System.Int32@)">
            <summary>
            Presolve a node.
            </summary>
            <param name="node">The node to presolve.</param>
            <param name="presolveNodeCount"></param>
            <returns>False if infeasibility was detected; true otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.GenerateCuttingPlanes(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Services.LinearResult@)">
            <summary>
            Repeatedly try to generate cutting planes, apply them and solve.
            </summary>
            <param name="integerOptimalGoalValues">The best integer solution found so far.</param>
            <param name="node">The current node.</param>
            <param name="relaxationResult">The curren relaxation.</param>
            <returns>Whether cutting planes were generated.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ApplyCuttingPlanes(Microsoft.SolverFoundation.Solvers.Node@,System.Boolean)">
            <summary>
            Applies the curring planes associated with the node. Re-initializes the reduced model if needed.
            </summary>
            <param name="node">The current node.</param>
            <param name="forceReInit">Whether to force a re-initialization of the reduced model.</param>
            <returns>False if the model is detected to be infeasible; true otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.UpdateIntegerOptimalGoalValues(Microsoft.SolverFoundation.Solvers.OptimalGoalValues@,System.Int32@,System.Int32@)">
            <summary>
            Registers a new best integer solution.
            </summary>
            <param name="integerOptimalGoalValues">The best integer solution.</param>
            <param name="presolveNodeCount"></param>
            <param name="cutGenerationNodeCount"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.CreateNodes(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.BranchingStrategy,Microsoft.SolverFoundation.Solvers.Node@,System.Boolean,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates new chid nodes.
            </summary>
            <param name="integerOptimalGoalValues"></param>
            <param name="strategy"></param>
            <param name="node">The parent node.</param>
            <param name="appliedCuttingPlane">Whether cutting planes have been applied.</param>
            <param name="newBranchingVariable">The branching variable.</param>
            <param name="newBranchingValue">The branching value.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.AddNodes(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.BranchingStrategy,System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Node@)">
            <summary>
            Adds new nodes to the node managers.
            </summary>
            <param name="integerOptimalGoalValues"></param>
            <param name="strategy"></param>
            <param name="newBranchingVariable"></param>
            <param name="newBranchingValue"></param>
            <param name="node">The parent node.</param>
            <param name="upChildExpectedGoalValue">The expected goal value of the first child node.</param>
            <param name="upChild">The first child node.</param>
            <param name="downChildExpectedGoalValue">The expected goal value of the second child node.</param>
            <param name="downChild">The second child node.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ShouldDive(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.Node@)">
            <summary>
            Checks whether the node is worth investigating by diving.
            </summary>
            <param name="integerOptimalGoalValues"></param>
            <param name="childNode"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.UpdatePseudoCosts(Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Solvers.BoundConstraint,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Updates the pseudo costs.
            </summary>
            <param name="node"></param>
            <param name="latestBoundConstraint"></param>
            <param name="branchingVariable"></param>
            <param name="branchingValue"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.UpdateInfeasiblePseudoCosts(Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.Node@,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Update the pseudo costs when the branaching makes the problem infeasible.
            </summary>
            <param name="integerOptimalGoalValues"></param>
            <param name="node"></param>
            <param name="branchingVariable"></param>
            <param name="branchingValue"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.PreferUpChild(Microsoft.SolverFoundation.Solvers.BranchingStrategy,System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Node@)">
            <summary>
            Indicates whether the up child should be investigated first.
            </summary>
            <param name="strategy"></param>
            <param name="newBranchingVariable"></param>
            <param name="newBranchingValue"></param>
            <param name="upChildExpectedGoalValue"></param>
            <param name="upChild"></param>
            <param name="downChildExpectedGoalValue"></param>
            <param name="downChild"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.SetIntegerOptimalVariableValues">
            <summary>
            Gets the values of the variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.FindBranchingVariable(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Solvers.BranchingStrategy@,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Checks whether there is a variable to branch on and returns it if one is found.
            </summary>
            <param name="node"></param>
            <param name="integerOptimalGoalValues">The current best integer solutions.</param>
            <param name="strategy"></param>
            <param name="branchingVariable">A variable that can be branched on.</param>
            <param name="branchingValue">The value of the variable to branch on.</param>
            <returns>True if a variable to branch on is found; false otherwise.</returns>
            <remarks>
            Variables that can be branched on are variables restricted to be integers and
            whose current values are not integers. 
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.DoSOSBranchAndBound(Microsoft.SolverFoundation.Services.LinearResult)">
            <summary> The gate method for sos solving
            </summary>
            <param name="resLp">lp relaxation solution</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.SetVariablesToZero(Microsoft.SolverFoundation.Solvers.SOSRowNode,System.Int32@)">
            <summary>Set the relevant variables' upper bound to zero. 
            </summary>
            <param name="node"></param>
            <param name="stoppedAtVid">vid of the var that could not been set to zero, if any, otherwise -1</param>
            <returns>true if all that needed to be set to zero are set to zero, false otherwise</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ComputeBreakingPoints(Microsoft.SolverFoundation.Solvers.SOSRowNode)">
            <summary>Compute the breaking points at a SOS ref row
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.#ctor(Microsoft.SolverFoundation.Solvers.SimplexSolver,System.Int32,Microsoft.SolverFoundation.Solvers.SimplexSolverParams,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="solver">The solver associated with the thread.</param>
            <param name="tid">The thread ID.</param>
            <param name="prm">The thread parameters.</param>
            <param name="fForceExact"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.#ctor(Microsoft.SolverFoundation.Solvers.MipNode)">
            <summary> Create a Dual Simplex Solver Task to be used by MIP
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.#ctor(Microsoft.SolverFoundation.Solvers.MipNode,Microsoft.SolverFoundation.Solvers.SimplexReducedModel)">
            <summary> Create a Dual Simplex Solver Task to be used by MIP
            </summary>
            <param name="parentNode">parent node</param>
            <param name="mod">reduced model for this task</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ReInit">
            <summary>
            Reinitialize the internal data structures.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ReInit(Microsoft.SolverFoundation.Solvers.SimplexBasisKind)">
            <summary>
            Reinitialize the internal data structures.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ComputeExactVars">
            <summary>
            This is called to just compute the initial exact variable values and goal values.
            It is typically only called when PreSolve finds an infeasibility.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.ComputeTableauRow(System.Int32)">
            <summary>
            This computes the row of the tableau where vid is currently the basic variable in that row after solve.
            Of course we never realize the full tableau. Note that the coef of the basic variable is 1, not -1.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.InitRowUsedFlags">
            <summary>
            Initialized the flags array in this thread: create/resize the array, set all elements to 0.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.SetRowUsedFlag(System.Int32,Microsoft.SolverFoundation.Solvers.CutKind)">
            <summary>
            Set the bit "kind" of byte "vidRow" in the array of flags that indicates which user rows have been used to generate cuts.
            </summary>
            <param name="vidRow"></param>
            <param name="kind"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.HasRowUsedFlag(System.Int32,Microsoft.SolverFoundation.Solvers.CutKind)">
            <summary>
            Test if "vidRow" has been used to generate "kind" cut.
            </summary>
            <param name="vidRow">The row variable id</param>
            <param name="kind">The type of cut</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexTask.IsBasicVarInReducedModel(System.Int32)">
            <summary>
            Checks whether a given user model vid corresponds to a basic var in the reduced model.
            </summary>
            <param name="vid">User model vid</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexTask.MipResult">
            <summary>
            Gets the result of solving the mixed-integer problem.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.BestDownEstimate(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.PseudoCosts,Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Computes the best estimate for an integer solution from this node.
            </summary>
            <param name="node"></param>
            <param name="pseudoCosts"></param>
            <param name="relaxation"></param>
            <param name="branchingVariable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.BestUpEstimate(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.PseudoCosts,Microsoft.SolverFoundation.Common.Rational,System.Int32)">
            <summary>
            Computes the best estimate for an integer solution from this node.
            </summary>
            <param name="node"></param>
            <param name="pseudoCosts"></param>
            <param name="relaxation"></param>
            <param name="branchingVariable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.FindLargestPeudoCost(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.PseudoCosts,System.Boolean,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Select the branching variable that has the largest pseudocost score.
            </summary>
            <param name="node"></param>
            <param name="pseudoCosts"></param>
            <param name="preferBinaryVariables"></param>
            <param name="branchingVariable">A variable that can be branched on.</param>
            <param name="branchingValue">The value of the variable to branch on.</param>
            <returns>True if a variable to branch on is found; false otherwise.</returns>      
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.FindSmallestPeudoCost(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.PseudoCosts,System.Boolean,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Select the branching variable that has the largest pseudocost score.
            </summary>
            <param name="node"></param>
            <param name="pseudoCosts"></param>
            <param name="preferBinaryVariables"></param>
            <param name="branchingVariable">A variable that can be branched on.</param>
            <param name="branchingValue">The value of the variable to branch on.</param>
            <returns>True if a variable to branch on is found; false otherwise.</returns>      
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.FindMostFractionalVariable(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Boolean,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Select the branching variable that is the most fractional.
            </summary>
            <param name="thread">The thread for which the most fractional variable is sought.</param>
            <param name="preferBinaryVariables">Whether to prefer binary variables over other variables.</param>
            <param name="branchingVariable">A variable that can be branched on.</param>
            <param name="branchingValue">The value of the variable to branch on.</param>
            <returns>True if a variable to branch on is found; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.FindLeastFractionalVariable(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Boolean,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Select the branching variable that is the least fractional.
            </summary>
            <param name="thread"></param>
            <param name="preferBinaryVariables"></param>
            <param name="branchingVariable">A variable that can be branched on.</param>
            <param name="branchingValue">The value of the variable to branch on.</param>
            <returns>True if a variable to branch on is found; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.FindVectorLengthVariable(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.PseudoCosts,System.Boolean,System.Int32@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Finds an integer variable that has a non integer value and that impacts the objective function as well as other variables.
            </summary>
            <param name="node"></param>
            <param name="pseudoCosts"></param>
            <param name="preferBinaryVariables"></param>
            <param name="branchingVariable"></param>
            <param name="branchingValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.GetInfluenceCoefficient(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Computes the influence that a variable has on others. 
            </summary>
            <param name="thread"></param>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Branching.HasFractionalVariable(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Checks whether there is at least one fractional variable.
            </summary>
            <param name="thread"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Constraint">
            <summary>
            The base class for constraints that can be added to a linear model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.#ctor">
            <summary>
            Create a constraint instance
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.#ctor(Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Construct a constraint and set the parent constraint.
            </summary>
            <param name="parentConstraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.SetParent(Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Extends the current constraint with a new constraint.
            </summary>
            <param name="newConstraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.ApplyConstraint(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint to the model. If there exists a parent constraint, will appy parent constraint first.
            </summary>
            <param name="thread"></param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.ResetConstraint(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint to the model. If there exists a parent constraint, will remove parent constraint first.
            </summary>
            <param name="thread"></param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.ApplyConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint to the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Constraint.ResetConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint from the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Constraint.ParentConstraint">
            <summary>
            Gets and sets the parent constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Constraint.Count">
            <summary>
            Gets and sets the number of individual constraints included in this constraint.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BoundConstraint">
            <summary>
            A bound constraint that can be added to a linear model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
            <param name="parentConstraint"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BoundConstraint.Variable">
            <summary>
            Gets the variable involved in the constraint.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BoundConstraint.Bound">
            <summary>
            Gets the new bound of the variable.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.UpperBoundConstraint">
            <summary>
            Represents an upper bound constraint.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UpperBoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UpperBoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
            <param name="parentConstraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UpperBoundConstraint.ApplyConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint to the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.UpperBoundConstraint.ResetConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint from the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.LowerBoundConstraint">
            <summary>
            Represents an lower bound constraint.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LowerBoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LowerBoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
            <param name="parentConstraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LowerBoundConstraint.ApplyConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint to the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LowerBoundConstraint.ResetConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint from the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RowBoundConstraint">
            <summary>
            Represents a constraint on row bounds.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.RowBoundConstraint.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="row"></param>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.RowBoundConstraint.ApplyConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint to the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.RowBoundConstraint.ResetConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint from the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.Cover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.CuttingPlanePool)">
            <summary>
            Generate cover cuts
            </summary>
            <param name="thread">the thread that stores the user model</param>
            <param name="nodeLimit">the maximum number of cuts to generate</param>
            <param name="pool">the cutting plane pool to store the generated cuts</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.GenerateCoverCutFromRow(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Microsoft.SolverFoundation.Common.Rational},Microsoft.SolverFoundation.Solvers.CuttingPlanePool,System.Int32,System.Int32@)">
            <summary>
            
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
            <param name="matchedRealVids"></param>
            <param name="matchedBoolVids"></param>
            <param name="matchedBoolCoefs"></param>
            <param name="pool"></param>
            <param name="rowLimit"></param>
            <param name="count"></param>
            <returns></returns>
            <remarks>
            Let S = {x \in {0,1}^N : sum_{j \in N}(aj*xj &lt;= b)}, where aj >= 0 and b >= 0. Let C be a cover, i.e.
            \lambda = sum_{j \in C}(aj) - b > 0. Then the following inequality is valid for S:
            
            sum_{j\in C}(xj) &lt;= |C| - 1
            
            Now we deal with the case where some aj's are negative. Formally, we assume, for 0 &lt;= j &lt;= k, aj >= 0, and, for
            k+1 &lt;= j &lt; N, aj &lt; 0. Then the inequality becomes:
             
            sum_{j\in C and j &lt;= k}(xj) - sum_{j\in C and j >= k+1}(xj) &lt;= |C| - 1 - |{xj : j\in C and j >= k+1}|
               
            Moveover, the definition of a cover C becomes: \lambda = sum_{j\in C}(|aj|) - b' > 0,
            where b' = b - sum_{k+1 &lt;= j &lt;= n-1}(aj) (note that b is the upper-bound of the slack variable of the row).
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.GenerateCoverCutFromRowUpperBound(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Microsoft.SolverFoundation.Common.Rational},Microsoft.SolverFoundation.Solvers.CuttingPlanePool,System.Int32@)">
            <summary>
            Generate a cover cut for a row.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.AddCutToPool(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,System.Boolean,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Microsoft.SolverFoundation.Common.Rational},Microsoft.SolverFoundation.Solvers.CuttingPlanePool,System.Int32@,System.Boolean[],System.Boolean[])">
            <summary>
            Adds the cut to the model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.IsBetterThanImpliedBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.VectorRational,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Test if the two bounds of the cut row are tighter than the implied bounds of the row. If implied bounds are tighter,
            the cut bounds will be updated.
            </summary>
            <param name="thread"></param>
            <param name="cutRow"></param>
            <param name="cutLowerBound">Ref param, value will be set to a better lower-bound</param>
            <param name="cutUpperBound">Ref param, value will be set to a better upper-bound</param>
            <returns>true if any cut bound is better than the implied bound.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.GomoryFractional(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Services.LinearResult,System.Int32,Microsoft.SolverFoundation.Solvers.CuttingPlanePool)">
            <summary>
            Generate gomory fractional cuts
            </summary>
            <param name="thread">the thread that solves the relaxation</param>
            <param name="result">the result of the relaxation (expect Optimal)</param>
            <param name="nodeLimit">the maximum number of cuts to generate</param>
            <param name="pool">the cutting plane pool to store the generated cuts</param>
            
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutGenerator.FindMinCover(Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Enumerate the minimal covers for the given array absCoef.
            </summary>
            <param name="absCoef">Array of non-negative values</param>
            <param name="bPrime"></param>
            <returns>Minimal covers. The indices stored in each cover are indices of absCoef.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CuttingPlanePool">
            <summary>
            A cutting plane pool that stores the cuts and merge/clear the cuts to the user model when necessary.
            This class is designed for each branch and bound node, which should have its own cutting plane pool.
            When the node is relocated to a worker thread, we need to set the simplex solver object in the worker
            thread to this cutting plane pool.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.GetAncestorCutPool(Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Return the ancestor cutting plane pool of the input constraint
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.ApplyConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Merge the cuts to the user model (must be called before solve)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.ResetConstraintCore(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Disable all the cut rows in the user model (must be called after solve)
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.AddUsedRowCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Mark the vidRow to indicate it has been used to generate a cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.AddUsedRowMixedCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Mark the vidRow to indicate it has been used to generate a mixed cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.AddUsedRowFlowCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Mark the vidRow to indicate it has been used to generate a flow cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.IsUsedRowCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Test if the vidRow has been used to generate a cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.IsUsedRowMixedCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Test if the vidRow has been used to generate a mixed cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.IsUsedRowFlowCover(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>
            Test if the vidRow has been used to generate a flow cover cut.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.InitUsedRowFlags(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.Node)">
            <summary>
            Initialize the flags in the thread by walking through the constraint train and setting
            the flags based on all ancestor cut pools' lists of rows used to generate cuts.
            </summary>
            <param name="thread"></param>
            <param name="currentNode"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.GenerateCuts(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.Node@)">
            <summary>
            Generate cutting planes from the given simplex thread. The simplex thread must be the one that finds the
            optimum of the LP relaxation. In that case, the basis in the thread is valid.
            </summary>
            <param name="thread"></param>
            <param name="nodeLimit">The maximum number of cuts to generate (for each kind) at this node.</param>
            <param name="currentNode"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.GenerateCuts(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Solvers.CutKind)">
            <summary>
            Generate cutting planes from the given simplex thread. The simplex thread must be the one that finds the
            optimum of the LP relaxation. In that case, the basis in the thread is valid.
            </summary>
            <param name="thread"></param>
            <param name="nodeLimit">The maximum number of cuts to generate (for each kind) at this node.</param>
            <param name="currentNode"></param>
            <param name="kinds"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.GenerateCuts(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Generate cutting planes from the given simplex thread. The simplex thread must be the one that finds the
            optimum of the LP relaxation. In that case, the basis in the thread is valid.
            </summary>
            <param name="thread"></param>
            <param name="nodeLimit">The maximum number of cuts to generate (for each kind) at this node.</param>
            <param name="currentNode"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.GenerateCuts(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Solvers.CutKind,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Generate cutting planes from the given simplex thread. The simplex thread must be the one that finds the
            optimum of the LP relaxation. In that case, the basis in the thread is valid.
            </summary>
            <param name="thread"></param>
            <param name="kinds">the kind of the cuts to generate.</param>
            <param name="currentNode">the current node.</param>
            <param name="nodeLimit">The maximum number of cuts to generate (for each kind) at this node.</param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.#ctor(Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Create a cutting plane pool and set the simplex solver and the initial cut kinds, and set the path limit (this is
            supposed to be called only once).
            </summary>
            <param name="parent">The parent constraint.</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.Cuts">
            <summary>
            Return a list of current cuts.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.CuttingPlane">
            <summary>
            Struct for cutting planes
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CuttingPlanePool.CuttingPlane.#ctor(Microsoft.SolverFoundation.Solvers.CutKind,Microsoft.SolverFoundation.Solvers.VectorRational,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Create a cutting plane
            </summary>
            <param name="kind"></param>
            <param name="row">the cut row</param>
            <param name="lower">the lower bound</param>
            <param name="upper">the upper bound</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.KnapsackSolver">
            <summary>
            Solves a knapsack problem.
            </summary>
            <remarks>
            The solver is not generic. It is targeted at cut cover separation algorithm.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.KnapsackSolver.Solve(System.Double[],System.Double[],System.Int32,System.Double,System.Boolean,System.Double,System.Boolean[]@,System.Double@)">
            <summary>
            Returns a array indicating which values should be included into the knapsak to minimize the total value.
            </summary>
            <param name="values">The values of the items.</param>
            <param name="weights">The weights of the items.</param>
            <param name="length">The number of items.</param>
            <param name="requiredWeight">The minimum weight.</param>
            <param name="longer">Indicates whether we prefer having more (true) or less (false) items in the solution.</param>
            <param name="cutoffValue">The value above which the result is rejected.</param>
            <param name="selection">The array indicating which values should be included.</param>
            <param name="value">The value of the selection.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SearchStrategy">
            <summary>
            Lists the possible search strategies for the MIP solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SearchStrategy.BestBound">
            <summary>
            Selects the node with the smallest bound. 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SearchStrategy.BestEstimate">
            <summary>
            Selects the node with the best objective value estimate.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SearchStrategy.DepthFirst">
            <summary>
            Selects the node in depth first manner.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BranchingStrategy">
            <summary>
            Lists the possible branching strategies for the MIP solver.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.Automatic">
            <summary>
            Let the solver choose the strategy.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.SmallestPseudoCost">
            <summary>
            Selects the variable with the smallest pseudo-cost.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.LargestPseudoCost">
            <summary>
            Selects the variable with the largest pseudo-cost.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.LeastFractional">
            <summary>
            Selects the least fractional variable.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.MostFractional">
            <summary>
            Selects the most fractional variable.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.VectorLength">
            <summary>
            Selects a variable with large pseudo-cost and expected large influence on other variables.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.BranchingStrategy.StrongCost">
            <summary>
            Selects a variable with largest increase in objective value.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Node">
            <summary>
            Represents a node in the branch and bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Node.#ctor(System.Int32,Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent"></param>
            <param name="lowerBoundGoalValue"></param>
            <param name="expectedGoalValue"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Node.#ctor(System.Int32,Microsoft.SolverFoundation.Solvers.OptimalGoalValues,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Solvers.Constraint)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="parent"></param>
            <param name="lowerBoundGoalValue"></param>
            <param name="expectedGoalValue"></param>
            <param name="constraint"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Node.ApplyConstraints(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Applies the constraint related to the node to the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Node.ResetConstraints(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Removes the constraint related to the node from the model.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.Parent">
            <summary>
            Gets the ID of the parent node.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.ConstraintCount">
            <summary>
            Gets the number of individual constraints applying to the node.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.ExpectedGoalValue">
            <summary>
            Gets the estimated goal value for the node.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.LowerBoundGoalValue">
            <summary>
            Gets a lower bound goal value for the node.
            </summary>
            <remarks>
            The known goal value is the goal value of the parent node.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.BranchingVariable">
            <summary>
            Gets the variable the node branches on.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.BranchingValue">
            <summary>
            Gets the value of the branching variable.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Node.LatestConstraint">
            <summary>
            Gets the latest constraint.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NodeManager">
            <summary>
            Manages the nodes in the branch and bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.#ctor(Microsoft.SolverFoundation.Solvers.SearchStrategy)">
            <summary>
            Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.Add(Microsoft.SolverFoundation.Solvers.Node)">
            <summary>
            Adds a node.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.Clear">
            <summary>
            Removes all the nodes.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.Pop">
            <summary>
            Gets the next node to process.
            </summary>
            <returns>A node.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.SwitchTo(Microsoft.SolverFoundation.Solvers.SearchStrategy)">
            <summary>
            Switches to best bound search.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.Reverse(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.Node)">
            <summary>
            Compares two nodes.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NodeManager.EstimateReverse(Microsoft.SolverFoundation.Solvers.Node,Microsoft.SolverFoundation.Solvers.Node)">
            <summary>
            Compares two nodes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NodeManager.Count">
            <summary>
            Gets whether there are nodes being managed.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NodeManager.SearchStrategy">
            <summary>
            Gets or sets in which order the nodes are popped from the manager.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.NodeMipPreSolve(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.Node@,System.Int32@,System.Int32@)">
            <summary>
            Applies a set of techniques to reduce a mixed-integer program.
            </summary>
            <param name="thread">The thread for which presolve is performed.</param>
            <param name="node">The node to tighten.</param>
            <param name="tightenRowBoundCount">The number of row bounds that were tighten.</param>
            <param name="tightenVariableBoundCount">The number of variable bounds that were tighten.</param>
            <returns>False if the model is detected to be infeasible; true otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.ComputeImpliedRowBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[])">
            <summary>
            Computes the lower and upper bounds of the rows based on the lower and upper bounds on the variables.
            </summary>
            <param name="thread"></param>
            <param name="impliedLowerBounds">An array containing the implied lower bounds. The array gets populated inside the method.</param>
            <param name="impliedUpperBounds">An array containing the implied upper bounds. The array gets populated inside the method.</param>
            <returns>False if the model is detected to be infeasible; true otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.TightenVariableBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[],System.Int32@)">
            <summary>
            Tightens the variable bounds based on the bounds of rows and other variables.
            </summary>
            <param name="thread"></param>
            <param name="node"></param>
            <param name="impliedRowLowerBounds">An array containing the implied lower bounds.</param>
            <param name="impliedRowUpperBounds">An array containing the implied lower bounds.</param>
            <param name="tightenVariableBoundCount"></param>
            <returns>True if a change was made; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.TightenRowBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.Node@,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[],System.Int32@)">
            <summary>
            Tightens the row bounds to match the implied row bounds if these are more restrictive.
            If both the lower and upper implied row bounds are more restrictive than the row bounds,
            the row can be eliminated.
            </summary>
            <param name="thread"></param>
            <param name="node"></param>
            <param name="impliedRowLowerBounds">An array containing the implied lower bounds.</param>
            <param name="impliedRowUpperBounds">An array containing the implied lower bounds.</param>
            <param name="tightenRowCount"></param>
            <returns>True if a change was made; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.MipPreSolve(Microsoft.SolverFoundation.Solvers.SimplexSolver,Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Boolean)">
            <summary>
            Applies a set of techniques to reduce a mixed-integer program.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.SetIntegrality(Microsoft.SolverFoundation.Solvers.SimplexSolver,Microsoft.SolverFoundation.Solvers.SimplexReducedModel)">
            <summary>
            Sets the integrality of the slack variable based on the integrality of other variables.
            </summary>
            <param name="solver"></param>
            <param name="model"></param>
            <remarks>
            Setting the integrality is important for algorithms such as Gomory cuts which use the information.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.EliminateDuplicateColumns(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Int32@)">
            <summary>
            Eliminates duplicate columns by merging variables.
            </summary>
            <remarks>
            A post processing step is required to find the values of the merged variables.
            </remarks>
            <param name="model"></param>
            <param name="tightenVariableBoundCount"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.ComputeImpliedRowBounds(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Int32,Microsoft.SolverFoundation.Common.Rational[]@,Microsoft.SolverFoundation.Common.Rational[]@,System.Collections.BitArray@)">
            <summary>
            Computes the lower and upper bounds of the rows based on the lower and upper bounds on the variables.
            </summary>
            <param name="model"></param>
            <param name="row"></param>
            <param name="impliedLowerBounds">An array containing the implied lower bounds. The array gets populated inside the method.</param>
            <param name="impliedUpperBounds">An array containing the implied upper bounds. The array gets populated inside the method.</param>
            <param name="newInterestingRows"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.TightenVariableCoefficients(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Int32,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[],System.Int32@,System.Collections.BitArray@)">
            <summary>
            Tightens the coefficients of variables based on the bounds of rows and other variables.
            </summary>
            <param name="model"></param>
            <param name="row"></param>
            <param name="impliedRowLowerBounds">An array containing the implied lower bounds.</param>
            <param name="impliedRowUpperBounds">An array containing the implied lower bounds.</param>
            <param name="tightenVariableCoefficientCount"></param>
            <param name="newInterestingRows"></param>
            <returns>True if a change was made; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.TightenVariableBounds(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Int32,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[],System.Int32@,System.Collections.BitArray@)">
            <summary>
            Tightens the variable bounds based on the bounds of rows and other variables.
            </summary>
            <param name="model"></param>
            <param name="row"></param>
            <param name="impliedRowLowerBounds">An array containing the implied lower bounds.</param>
            <param name="impliedRowUpperBounds">An array containing the implied lower bounds.</param>
            <param name="tightenVariableBoundCount"></param>
            <param name="newInterestingRows"></param>
            <returns>True if a change was made; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Presolving.TightenRowBounds(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Int32,Microsoft.SolverFoundation.Common.Rational[],Microsoft.SolverFoundation.Common.Rational[],System.Int32@,System.Int32@,System.Collections.BitArray@)">
            <summary>
            Tightens the row bounds to match the implied row bounds if these are more restrictive.
            If both the lower and upper implied row bounds are more restrictive than the row bounds,
            the row can be eliminated.
            </summary>
            <param name="model"></param>
            <param name="row"></param>
            <param name="impliedRowLowerBounds">An array containing the implied lower bounds.</param>
            <param name="impliedRowUpperBounds">An array containing the implied lower bounds.</param>
            <param name="eliminatedRowCount"></param>
            <param name="tightenRowCount"></param>
            <param name="newInterestingRows"></param>
            <returns>True if a change was made; false otherwise.</returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PseudoCosts">
            <summary>
            Computes pseudo-costs for mixed-integer programs.
            </summary>
            <remarks>
            Pseudo costs are used to approximate the increase in the objective function (remember we are looking for
            a minimum) based on the change in a variable. The variable that is expected to give the biggest increase is
            selected as the branching variable. (Having a big increase makes it more likely that the node can be cut from
            the search tree.)
            Pseudo costs are based on historical data. Whenever a variable is selected during the branch and bound process,
            the increase in the objective function is recorded. The pseudo cost is the average of the increase divided by 
            the fractional part (up or down) of the variable.
            If a variable is not yet costed, its pseudo cost is approximated by the average pseudo cost of the costed variables.
            
            When using strong costs, the actual increase in objective function is computed (by resolving the problem) instead of 
            relying on historical data only. This gives a more accurate initial value for the pseudo-cost at the top of the tree 
            where good branching matters most. Since this operation is expansive, we only perform it for un-initialized pseudo-costs.
            We revert to the normal algorithm when the pseudo-costs are initialized.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.#ctor(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Boolean)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="thread">The thread requiring the pseudo costs.</param>
            <param name="strongCosts">Whether to use strong costs to initialize the pseudo-costs.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.Score(Microsoft.SolverFoundation.Solvers.Node,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Computes the score of a variable.
            </summary>
            <param name="node"></param>
            <param name="variable">The variable to score.</param>
            <param name="value">The current value of the variable.</param>
            <returns>
            The score represents how good the variable is for branching. Pseudo costs are used to approximate the
            increase in the objective function for the down and up branches. The scoring method combines the two
            estimates into one score.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetUsage(System.Int32)">
            <summary>
            Gets how many times the variable has been used.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.UpdateDownPseudoCost(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Updates the pseudo cost of a variable.
            </summary>
            <param name="variable"></param>
            <param name="fractionalPart"></param>
            <param name="objectiveIncrease"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.UpdateUpPseudoCost(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Updates the pseudo cost of a variable.
            </summary>
            <param name="variable"></param>
            <param name="fractionalPart"></param>
            <param name="objectiveIncrease"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetEstimatedGoalUpIncrease(Microsoft.SolverFoundation.Solvers.Node,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Gets the estimated increase in the goal value for a given variable.
            </summary>
            <param name="node"></param>
            <param name="branchingVariable"></param>
            <param name="branchingValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetEstimatedGoalDownIncrease(Microsoft.SolverFoundation.Solvers.Node,System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Gets the estimated increase in the goal value for a given variable.
            </summary>
            <param name="node"></param>
            <param name="branchingVariable"></param>
            <param name="branchingValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetPseudoCost(System.Int32)">
            <summary>
            Gets the pseudo cost for a variable.
            </summary>
            <param name="variable"></param>
            <returns>The pseudo cost or null if the variable has not been costed.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetDownPseudoCost(System.Int32)">
            <summary>
            Gets the pseudo cost associated with branching down on a given variable.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.GetUpPseudoCost(System.Int32)">
            <summary>
            Gets the pseudo cost associated with branching up on a given variable.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PseudoCosts.Score(System.Double,System.Double)">
            <summary>
            Combines the expected increases in objective function into a single score.
            </summary>
            <param name="expectedDownIncrease"></param>
            <param name="expectedUpIncrease"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PseudoCosts.PseudoCost">
            <summary>
            Record of a variable pseudo costs.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NelderMeadSolver">
            <summary>Finds a local minimum/maximum for an box-constrained nonlinear function.
            </summary>
            <remarks>
            NelderMeadSolver is used to find local minima or maxima for a function whose variables may be constrained to be in a range. 
            It does not require computing derivatives so it can be used in cases where other techniques cannot. NelderMeadSolver implements
            the INonlinearSolver interface, and the goal function is specified using the FunctionEvaluator property.
            NelderMeadSolver implements the method described in Nelder, J.A. and Mead, R., "A Simplex Method for Function Minimization", Computer Journal 7 (4): 308-313 (Jan., 1965)
            with the modifications described in Lee, D. and Wiswall, M., 
            "A Parallel Implementation of the Simplex Function Minimization Routine".
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.#ctor">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary>Creates a new instance.
            </summary>
            <param name="comparer">A key comparer</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Solve(System.Func{System.Double[],System.Double},System.Double[])">
            <summary>Finds the minimum value of the specified function, using the specified starting point.
            </summary>
            <param name="f">The function to minimize.</param>
            <param name="x0">The initial starting point for the search.</param>
            <returns>An INonlinearSolution instance.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Solve(System.Func{System.Double[],System.Double},System.Double[],System.Double[],System.Double[])">
            <summary>Finds the minimum value of the specified function, using the specified starting point and variable bounds.
            </summary>
            <param name="f">The function to minimize.</param>
            <param name="x0">The initial starting point for the search.</param>
            <param name="xLo">The lower bounds on the variables (optional, default is negative infinity).</param>
            <param name="xHi">The upper bounds on the variables (optional, default is infinity).</param>
            <returns>An INonlinearSolution instance.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.IsValidTolerance(System.Double)">
            <summary>Determines if the specified value is a valid solver tolerance.
            </summary>
            <param name="value">A proposed tolerance value.</param>
            <returns>True if the value is within the valid limits.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to set, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GetProperty(System.String,System.Int32)">
            <summary>Get a property for the specified index.
            </summary>
            <param name="propertyName">The name of the property to get, see SolverProperties.</param>
            <param name="vid">The variable index.</param>
            <returns>The value.</returns>
            <exception cref="T:System.ArgumentNullException">The property name is null.</exception>
            <exception cref="T:System.ArgumentException">The variable index is invalid.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException">The property is not supported. The Reason property indicates why the property is not supported.</exception>
            <remarks> This method is typically called by Solver Foundation Services in response to event handler code.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.ValidateInSolveState(System.String)">
            <summary>
            If not in solving state and property is one that solver supports, throw
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.AddVariable(System.Object,System.Int32@)">
            <summary>
            The AddVariable method ensures that a user variable with the given key is in the model.
            </summary>
            <remarks>
            If the model already includes a user variable referenced by key, this sets vid to the variable’s index 
            and returns false. Otherwise, if the model already includes a row referenced by key, this sets vid to -1 and returns false. 
            Otherwise, this adds a new user variable associated with key to the model, assigns the next available index to the new variable, 
            sets vid to this index, and returns true.
            By convention variables get indexes from 1 ... VariableCount in the order they were added.
            </remarks>
            <param name="key">Variable key.</param>
            <param name="vid">Variable index.</param>
            <returns>True if added successfully, otherwise false.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>Set or adjust upper and lower bounds for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The lower bound.</param>
            <param name="numHi">The upper bound.</param>
            <remarks>Not supported by unconstrained solvers.  Logically, a vid may have an upper bound of Infinity and/or a lower 
            bound of -Infinity. Specifying other non-finite values should be avoided. 
            If a vid has a lower bound that is greater than its upper bound, the model is automatically infeasible, 
            and ArgumentException is thrown.  
            </remarks>
            <exception cref="T:System.NotSupportedException">Not supported for goal rows.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the lower bound for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The lower bound.</param>
            <remarks>Not supported by unconstrained solvers.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported for goal rows.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Set or adjust the upper bound for a vid. 
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numHi">The upper bound.</param>
            <remarks>Not supported by unconstrained solvers.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported for goal rows.</exception>
            <exception cref="T:System.ArgumentException">Thrown if upper and lower bounds are incompatible.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GetBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Return the bounds for a vid.
            </summary>
            <param name="vid">The variable index.</param>
            <param name="numLo">The current lower bound.</param>
            <param name="numHi">The current upper bound.</param>
            <remarks>Not supported for goal rows.</remarks>
            <exception cref="T:System.NotSupportedException">Not supported by unconstrained solvers.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary>Solve the model using the given parameter instance.
            </summary>
            <param name="parameters">Should be an instance of NelderMeadSolverParams.</param>
            <returns>The solution after solving.</returns>
            <exception cref="T:System.ArgumentNullException">Parameters should not be null.</exception>
            <exception cref="T:System.ArgumentException">Parameters should be of type NelderMeadSolverParams.</exception>
            <exception cref="T:Microsoft.SolverFoundation.Common.ModelException">FunctionEvaluator must be specified before calling this method.</exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Shutdown">
            <summary>Shutdown.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GetSolutionValue(System.Int32)">
            <summary>Get the objective value of a goal.
            </summary>
            <param name="goalIndex">goal id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get information about a solved goal.
            </summary>
            <param name="goalIndex"> 0 &lt;= goal index &lt; SolvedGoalCount </param>
            <param name="key">The goal row key</param>
            <param name="vid">The goal row vid</param>
            <param name="minimize">Whether the goal is to minimize</param>
            <param name="optimal">Whether the goal is optimal</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Microsoft#SolverFoundation#Services#INonlinearSolution#GetValue(System.Int32)">
            <summary>Return the value of a variable.
            </summary>
            <param name="vid">A variable id.</param>
            <returns>The variable value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report.
            </summary>
            <param name="context">Solver context.</param>
            <param name="solution">The solution.</param>
            <param name="solutionMapping">The solution mapping.</param>
            <returns>A report object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Project(Microsoft.SolverFoundation.Common.Vector)">
            <summary>
            Ensures that the variable vector p is feasible.
            </summary>
            <param name="p">A vector of variable values.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.MapEvaluate(Microsoft.SolverFoundation.Common.Vector[],Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary>
            Evaluate the objective function at a series of points.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Evaluate(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary>
            Evaluate the objective function at a point.
            </summary>
            <param name="x">The point.</param>
            <param name="slot">Determines which ValuesByIndex to use (for parallel evaluation - use 0 if N/A).</param>
            <returns>The objective value.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.IterationCount">
            <summary>The number of Nelder-Mead iterations.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.AcceptedExpansionsCount">
            <summary>Number of times the expanded point was accepted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.RejectedExpansionsCount">
            <summary>Number of times the expanded point was rejected (using the reflected point).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.RejectedContractionsCount">
            <summary>Number of times the contracted point was rejected (regenerating the simplex).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.AcceptedContractionsCount">
            <summary>Number of times the contracted point was accepted.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.AcceptedReflectionsCount">
            <summary>Number of times the reflected point was accepted.
            </summary>
            <remarks>If the reflected point was rejected then we attempt to contract, either
            rejecting or accepting the contracted point.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SmallSimplexCount">
            <summary>Number of times a small simplex was encountered.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.NonlinearCapabilities">
            <summary>The capabilities for this solver.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.GradientCapability">
            <summary>Gradient capabilities.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.HessianCapability">
            <summary>Hessian capabilities.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.SolvedGoalCount">
            <summary>Number of goals being solved.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.EvaluationCallCount">
            <summary>The number of function evaluations performed for the most recent solve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.Result">
            <summary>Indicates the type of result (e.g., LocalOptimal). 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.NelderMeadValuesByIndex">
            <summary>Helps to map vid to solver index.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolver.NelderMeadValuesByIndex.#ctor">
            <summary>Creates a new instance.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams">
            <summary>Parameters for the NelderMeadSolver.
            </summary>
            <remarks>
            The solver terminates when the size of the Nelder-Mead simplex falls below the Tolerance.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.#ctor(System.Func{System.Boolean})">
            <summary>Create a new instance.
            </summary>
            <param name="fnQueryAbort">An abort delegate that is called during the solution process.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.#ctor">
            <summary>Create a new instance with default arguments.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.#ctor(System.Double,System.Double,System.Int32,System.Func{System.Boolean})">
            <summary>Create a new instance.
            </summary>
            <param name="tolerance">The solution tolerance.</param>
            <param name="unboundedTolerance">The unbounded solution tolerance.</param>
            <param name="maxIterations">The maximum number of iterations.</param>
            <param name="fnQueryAbort">An abort delegate that is called during the solution process.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.#ctor(Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams)">
            <summary>Copy constructor.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary>Create a new instance from a Directive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.ShouldAbort">
            <summary>Checks whether the solver should abort by examining the Abort property and
            the abort delegate.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.FillInSolverParams(Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Fill in NelderMeadSolverParams based on the given directive.
            </summary>
            <param name="dir">The directive instance that contains all the parameter settings</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.Tolerance">
            <summary>The solver terminates when the size of the simplex
            falls below the Tolerance.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.UnboundedTolerance">
            <summary>The solver terminates when the magnitude of the objective value at the centroid is beyond this value.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.IterationLimit">
            <summary>The maximum number of solver iterations.
            </summary>
            <remarks>
            If the iteration limit is exceeded, the solver will return an interrupted status.
            The default is Int32.MaxValue.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.MaximumSearchPoints">
            <summary>The maximum number of search points per iteration.
            </summary>
            <remarks>
            This value controls the number of points in the simplex that are updated during each iteration.
            For some problems, increasing the number of search points results in faster convergence.
            The default value is 1.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.Abort">
            <summary>Setting this property to true will cause the solver to abort.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.StartMethod">
            <summary>Determines how to initialize the starting point.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.TerminationSensitivity">
            <summary>The termination policy.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.QueryAbort">
            <summary>
            Get/set the callback function that decides when to abort the search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.NelderMeadSolverParams.Solving">
            <summary>
            Callback called during solve
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NelderMeadStartMethod">
            <summary>How to initialize the starting point.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.NelderMeadStartMethod.Default">
            <summary>Default.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.NelderMeadTerminationSensitivity">
            <summary>The termination policy for NelderMead.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.NelderMeadTerminationSensitivity.Conservative">
            <summary>Terminate when the simplex is sufficiently small and the goal value has remained stable.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.NelderMeadTerminationSensitivity.Aggressive">
            <summary>Terminate when the simplex is sufficiently small, without checking the change in goal value.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Literal">
            <summary>
            Struct for a literal. A literal is a Boolean variable or the negation of a Boolean variable
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.Literal.Nil">
            <summary>
            Null literal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.#ctor(System.Int32,System.Boolean)">
            <summary>
            Construct a literal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_OnesComplement(Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Construct the dual literal of lit
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_Equality(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Compare whether the two literals are the same
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_Inequality(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Compare whether the two literals are different
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_LessThan(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Whether lit1.Id is less than lit2.Id
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_GreaterThan(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Whether lit1.Id is greater than lit2.Id
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_LessThanOrEqual(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Whether lit1.Id is less than or equal to lit2.Id
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.op_GreaterThanOrEqual(Microsoft.SolverFoundation.Solvers.Literal,Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Whether lit1.Id is greater than or equal to lit2.Id
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.ToString">
            <summary>
            Return the string representation of this literal
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.Equals(System.Object)">
            <summary>
            Test whether obj is the same literal as this one
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.GetHashCode">
            <summary>
            Get the hash code of this literal
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Literal.CompareTo(Microsoft.SolverFoundation.Solvers.Literal)">
            <summary>
            Compare this literal to lit
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Literal.Id">
            <summary>
            Get the ID of the literal
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Literal.Var">
            <summary>
            Get the Boolean variable that forms this literal
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Literal.Sense">
            <summary>
            Get the sign of the literal
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Literal.IsNil">
            <summary>
            Whether this literal is a null literal
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SatSolution">
            <summary>
            Solutions for SatSolver models
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolution.#ctor(Microsoft.SolverFoundation.Solvers.Literal[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            Create a solution object
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolution.ToString">
            <summary>
            Get the string representation of the solution
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.RestartCount">
            <summary>
            Get the number of restarts during search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.BackTrackCount">
            <summary>
            Get the number of backtracks during search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.LearnedClauseCount">
            <summary>
            Get the number of learned clauses during search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.LearnedLiteralCount">
            <summary>
            Get the number of learned literals during search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.Time">
            <summary>
            Get the amount of time spent in search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.Literals">
            <summary>
            Get all literals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.Pos">
            <summary>
            Get all positive literals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.Neg">
            <summary>
            Get all negative literals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.Guesses">
            <summary>
            Get all choice literals
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.PosGuess">
            <summary>
            Get all choice literals that are positive
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolution.NegGuess">
            <summary>
            Get all choice literals that are negative
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SatSolverParams">
            <summary>
            Class for processing SatSolver parameters
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolverParams.#ctor">
            <summary>
            Create default parameter set
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolverParams.#ctor(System.Func{System.Boolean})">
            <summary>
            Create default parameter set with a callback function to indicate when to stop
            </summary>
            <param name="fnQueryAbort"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.Abort">
            <summary>
            Get/Set the abort flag to stop the solver
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.Biased">
            <summary>
            Whether the value choice is biased in the search
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.InitialGuess">
            <summary>
            If Biased is true, this indicates which direction will be tried first.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.RandVarProb">
            <summary>
            Probability that a variable is chosen at random.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.RandSenseProb">
            <summary>
            Probability that a sense is chosen at random.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SatSolverParams.BackTrackCountLimit">
            <summary>
            Initial number of back tracks that triggers a restart.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SatSolver">
            <summary>
            Class for SatSolver
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolver.Solve(Microsoft.SolverFoundation.Solvers.SatSolverParams,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.Literal[]})">
            <summary>
            This one uses heuristics to decide which boolean value to try first.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolver.Init(Microsoft.SolverFoundation.Solvers.SatSolverParams,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.SolverFoundation.Solvers.Literal[]})">
            <summary>
            Initializes the data structures to represent the given set of clauses.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SatSolver.UndoToLevel(System.Int32)">
            <summary>
            Backtrack to the given level
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AlgorithmBase`1.#ctor(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="thd"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AlgorithmDouble.ComputeBasicValues">
            <summary> This computes basic variable values assuming _bas is set correctly
                      and the basis is factored.  Results in _rgnumBasic.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.AlgorithmDouble.ComputeBasicValues(System.Double[])">
            <summary> This computes basic variable values assuming _bas is set correctly
                      and the basis is factored.
                      rgnumDst must be values in order that they appear in the basis.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.BoundManager">
            <summary>
            Manages the bounds during branch and bound.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.#ctor(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="thread"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.#ctor(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary> Clone
            </summary>
            <param name="thread"></param>
            <param name="cloneTask"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.InitBounds(Microsoft.SolverFoundation.Solvers.SimplexTask)">
            <summary>
            Resets the bounds.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.GetVarBound(System.Int32,Microsoft.SolverFoundation.Solvers.SimplexVarValKind)">
            <summary>
            Gets a variable's bound.
            </summary>
            <param name="variable"></param>
            <param name="vvk"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.GetLowerBoundsDbl(System.Double[])">
            <summary>
            Gets all the lower bounds. 
            </summary>
            <param name="rgnum"></param>
            <remarks>
            This method may be called before InitBounds. In this case we
            return the model's lower bounds.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.GetUpperBoundsDbl(System.Double[])">
            <summary>
            Gets all the upper bounds. 
            </summary>
            <param name="rgnum"></param>
            <remarks>
            This method may be called before InitBounds. In this case we
            return the model's upper bounds.
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.SetLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets the lower bound of a variable to a specific value.
            </summary>
            <param name="variable">The variable whose lower bound is set.</param>
            <param name="bound">The value of the upper bound (in the reduced model).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.SetLowerBoundDbl(System.Int32,System.Double)">
            <summary>
            Sets the lower bound of a variable to a specific value.
            </summary>
            <param name="variable">The variable whose lower bound is set.</param>
            <param name="bound">The value of the upper bound (in the reduced model).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.ResetLowerBound(System.Int32)">
            <summary>
            Resets the lower bound to its original value.
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.SetUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets the upper bound of a variable to a specific value.
            </summary>
            <remarks>This is currently used just for sos</remarks>
            <param name="variable">The variable whose upper bound is set.</param>
            <param name="bound">The value of the upper bound (in the reduced model).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.SetUpperBoundDbl(System.Int32,System.Double)">
            <summary>
            Sets the upper bound of a variable to a specific value.
            </summary>
            <param name="variable">The variable whose upper bound is set.</param>
            <param name="bound">The value of the upper bound (in the reduced model).</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.ResetUpperBound(System.Int32)">
            <summary>
            Resets the upper bound to its original value.
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.GetRowBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Gets the bounds of a row.
            </summary>
            <param name="row">The row whose bounds are sought.</param>
            <param name="lowerBound">The lower bound of the row.</param>
            <param name="upperBound">The upper bound of the row.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.SetRowBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets the bounds of a row.
            </summary>
            <param name="row">The row whose bounds are set.</param>
            <param name="lowerBound">The lower bound of the row.</param>
            <param name="upperBound">The upper bound of the row.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.ComputeImpliedBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Compute the implied bounds of vidRow.
            </summary>
            <param name="thread"></param>
            <param name="vidRow"></param>
            <param name="impliedLowerBound"></param>
            <param name="impliedUpperBound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.BoundManager.ComputeImpliedBounds(Microsoft.SolverFoundation.Solvers.SimplexTask,Microsoft.SolverFoundation.Solvers.VectorRational,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Compute the implied bounds of vector row, whose column vars must have been defined in the solver.
            </summary>
            <param name="thread"></param>
            <param name="row"></param>
            <param name="impliedLowerBound"></param>
            <param name="impliedUpperBound"></param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BoundManager.UpperBoundsCount">
            <summary>
            Gets the number of upper bounds that have been modified from the original reduced model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.BoundManager.LowerBoundsCount">
            <summary>
            Gets the number of lower bounds that have been modified from the original reduced model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CoefMatrix.IsPositiveSemiDefinite(Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Boolean,System.Func{System.Boolean})">
            <summary>
            This is a simple algorithm to test whether a matrix is PSD
             step 1. make SymMat = Mat + Mat^T 
             step 2. starting from the first row of SymMat, stop if the last row 
             step 3. check if any diagnoals are positive, continue. If negative, terminate not PSD. If zero, terminate if exist any other non-zero entries, otherwise continue. 
             step 4. Eliminate the column corresponding to the current row number, go to step 2 for the next row
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CoefMatrix.RowIter.#ctor(Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="matrix">The matrix whose row is iterated.</param>
            <param name="row">The row to iterate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CoefMatrix.ColIter.#ctor(Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="matrix">The matrix whose row is iterated.</param>
            <param name="column">The column to iterate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.CopyFrom(Microsoft.SolverFoundation.Solvers.Vector{`0})">
            <summary> Copy the contents of vecSrc into this vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.Clear">
            <summary> Set all vector positions to zero (optimized as empty).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.EraseRcSlotMap">
            <summary> Erase the _mprcslot entries.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.OrderForward">
            <summary> Set the slots in rising order of column number.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.ScaleBy(`0)">
            <summary> Multiply every element of the vector by a.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.GetCoef(System.Int32)">
            <summary> Return the value at the defined row/column position, element [rc].
                      0 &lt;= rc &lt; RcCount
                      Empty positions return zero.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.TryGetCoef(System.Int32,`0@)">
            <summary> Get the value at the defined row/column position, element [rc].
                      0 &lt;= rc &lt; RcCount
                      Empty positions return false.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.RemoveCoef(System.Int32)">
            <summary> Set element [rc] to zero, sparsely represented.
                      0 &lt;= rc &lt; RcCount
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Vector`1.RcCount">
            <summary> The count of defined row/column positions (including empties).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Vector`1.EntryCount">
            <summary> The count of non-zero elements currently in use.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.Vector`1.Iter">
            <summary> Iterate the non-zero elements of a vector in efficient but
                      arbitrary order.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.Iter.#ctor(Microsoft.SolverFoundation.Solvers.Vector{`0})">
            <summary> Iterate the non-zero elements of a vector by declining order
                      of slot number.  You can use OrderForward() to cause this to
                      be guaranteed right-to-left order, else order is arbitrary.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.Iter.Advance">
            <summary> Move to the next defined element.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.Vector`1.Iter.RemoveAndAdvance">
            <summary> Set current element to zero and remove from active slot list,
                      then advance to next element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.Vector`1.Iter.IsValid">
            <summary> True if the iterator is at a defined element, false if finished.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorRational.SetCoefNonZero(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary> Set a value, which the caller guarantees is not zero.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorRational.SetCoef(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary> Set a value, which may or may not be zero
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorRational.ScaleBy(Microsoft.SolverFoundation.Common.Rational)">
            <summary> Multiply every element of the vector by a.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorRational.Dot(Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary> Dot product, this[:i]*v[:i]
            </summary>
            <param name="v"> The other vector </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.CopyFrom(Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary> Copy the contents of vecSrc into this vector.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.SetCoefNonZero(System.Int32,System.Double)">
            <summary> Set a value, which the caller guarantees is not zero.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.SetCoef(System.Int32,System.Double)">
            <summary> Set a value, which may or may not be zero
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.AddAndShadow(System.Int32,System.Double,System.Double[]@)">
            <summary> Add a number to the element, and shadow it
                      by adding the Abs value to the shadow slot.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.ScaleBy(System.Double)">
            <summary> Multiply every element of the vector by a.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.SlamToZero(System.Double[],System.Double)">
            <summary> Ensure every element exceeds the stability threshold.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDouble.Dot(Microsoft.SolverFoundation.Solvers.VectorDouble,System.Double)">
            <summary> Dot product, this[:i]*v[:i]
            </summary>
            <param name="v"> The other vector </param>
            <param name="epsilon"> numerical stability threshold </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.Clear">
            <summary> Set all vector positions to zero (optimized as empty).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.EraseRcSlotMap">
            <summary> Erase the _mprcslot entries.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.GetCoef(System.Int32)">
            <summary> Return the value at the defined row/column position, element [rc].
                      0 &lt;= rc &lt; RcCount
                      Empty positions return zero.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.TryGetCoef(System.Int32,System.Double@)">
            <summary> Get the value at the defined row/column position, element [rc].
                      0 &lt;= rc &lt; RcCount
                      Empty positions return false.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.RemoveCoef(System.Int32)">
            <summary> Set element [rc] to zero, sparsely represented.
                      0 &lt;= rc &lt; RcCount
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.VectorDDouble.RcCount">
            <summary> The count of defined row/column positions (including empties).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.VectorDDouble.EntryCount">
            <summary> The count of non-zero elements currently in use.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.VectorDDouble.Iter">
            <summary> Iterate the non-zero elements of a vector in efficient but
                      arbitrary order.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.Iter.#ctor(Microsoft.SolverFoundation.Solvers.VectorDDouble@)">
            <summary> Iterate the non-zero elements of a vector by declining order
                      of slot double.  You can use OrderForward() to cause this to
                      be guaranteed right-to-left order, else order is arbitrary.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.Iter.Advance">
            <summary> Move to the next defined element.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.VectorDDouble.Iter.RemoveAndAdvance(Microsoft.SolverFoundation.Solvers.VectorDDouble@)">
            <summary> Set current element to zero and remove from active slot list,
                      then advance to next element.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.VectorDDouble.Iter.IsValid">
            <summary> True if the iterator is at a defined element, false if finished.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CountList">
            <summary> a double link list to link row/col with the same
            number of non-zeros
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CountList._next">
            <summary> row count link list 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CountList._prev">
            <summary> row count link list 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CountList._count">
            <summary> reverse mapping from index to count
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CountList.Add(System.Int32,System.Int32)">
            <summary>
            Add this row/col index to the list of #size 
            </summary>
            <param name="index"></param>
            <param name="size"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CountList.Remove(System.Int32)">
            <summary>
            Remove this row/col
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CutKind">
            <summary>
            Lists the cuts the solver can generate.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.None">
            <summary>
            No cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.GomoryFractional">
            <summary>
            Gomory cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.Cover">
            <summary>
            Cover cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.MixedCover">
            <summary>
            Mixed cover cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.FlowCover">
            <summary>
            Flow cover cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.Default">
            <summary>
            Default set of cuts.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CutKind.All">
            <summary>
            All cuts.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.RowCut">
            <summary> A single cutting plane row
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CutStore">
            <summary> In this class, we maintain cutting planes generated, detect/remove duplicates, etc.
            </summary>
            <remarks>Each MipSolver maintains a single global cut store.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutStore.#ctor(Microsoft.SolverFoundation.Solvers.MipSolver)">
            <summary> Construct a cut store
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutStore.Count(Microsoft.SolverFoundation.Solvers.MipNode)">
            <summary> Get the number of cuts generated in the given node
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutStore.Cuts(Microsoft.SolverFoundation.Solvers.MipNode)">
            <summary> Get the cuts in the store
            </summary>
            <remarks>Returned IList is guaranteed not to be null</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutStore.AddCuts(Microsoft.SolverFoundation.Solvers.CutBuilder)">
            <summary> Add a cut to the store
            </summary>
            <returns>false if and only if the node is integer infeasible</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutStore.Age(Microsoft.SolverFoundation.Solvers.MipNode)">
            <summary> Age the cuts in the store based on the relaxation solve result of the given node.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CutStore.GomoryCutRound">
            <summary> The number of rounds of Gomory cut generation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CutStore.TotalCutCount">
            <summary> Get the total number of cuts from all nodes
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CutBuilder">
            <summary> Base class for all cutting plane generators
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CutBuilder.ComputeCutRowValue(Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary> Compute the cut row value in the optimal relaxation solution.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GomoryCutBuilder">
            <summary> Generator of Gomory fractional cuts
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualDouble.ComputeBasicValuesPhaseOne(System.Double[])">
            <summary> This initializes variable values assuming _bas is set correctly
            and the basis is factored.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualDouble.InitVarValuesPostPhaseOne">
            <summary> This assumes we've just completed phase one and _vecReducedCost is valid.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualDouble.RepeatPivots(System.Boolean)">
            <summary>
            This repeatedly pivots.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualExact.ComputeBasicValuesPhaseOne(Microsoft.SolverFoundation.Common.Rational[])">
            <summary> This initializes variable values assuming _bas is set correctly
            and the basis is factored.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualExact.RepeatPivots(System.Boolean,System.Int32@,Microsoft.SolverFoundation.Services.LinearResult@)">
            <summary>
            This repeatedly pivots.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualExact.ComputeReducedCosts">
            <summary>
            Compute the reduced costs and put them in _vecCost.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.DualExact.ComputeTableauRow">
            <summary>
            This computes the _ivarLeave'th row of the tableau.
            Of course we never realize the full tableau.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PivotStrategyDbl.FindNext">
            <summary>
            Calls FindEnteringVar to set _varEnter, _vvkEnter, and _sign.
            Calls ComputeDelta to set _vecDelta.
            Calls ValidateCost to validate the entering variable.
            Calls FindLeavingVar to set _scale, _ivarLeave, _varLeave, and _vvkLeave.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PivotStrategyDbl.UpdateSOS(System.Int32)">
            <summary>Update the sos status due to the leaving var
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullReducedCostDbl.ComputeCosts">
            <summary>
            Compute the reduced costs and put them in _vecCost.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullReducedCostDbl.FindEnteringVar">
            <summary> Sets _varEnter and _sign.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PivotStrategyExact.FindNext">
            <summary>
            Calls FindEnteringVar to set _varEnter, _vvkEnter, and _sign.
            Calls ComputeDelta to set _vecDelta.
            Calls ValidateCost to validate the entering variable.
            Calls FindLeavingVar to set _scale, _ivarLeave, _varLeave, and _vvkLeave.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullReducedCostApprox.ComputeCosts">
            <summary>
            Compute the reduced costs and put them in _vecCost.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullReducedCostApprox.FindNext">
            <summary>
            Calls FindEnteringVar to set _varEnter, _vvkEnter, and _sign.
            Calls ComputeDelta to set _vecDelta.
            Calls ValidateCost to validate the entering variable.
            Calls FindLeavingVar to set _scale, _ivarLeave, _varLeave, and _vvkLeave.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullReducedCostApprox.FindEnteringVar">
            <summary>
            Sets _varEnter and _sign.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullWeightedCostDbl.ComputeCosts">
            <summary> The weights are reset whenever the relative costs are computed from scratch.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullWeightedCostDbl.InitWeightsInit">
            <summary> Compute the actual column norms for initial weights.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullWeightedCostDbl.UpdateCostsCore(System.Double)">
            <summary> Update the relative costs and weights against
                      a basis which has changed by committing a pivot.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.FullWeightedCostApprox.InitWeightsInit">
            <summary> Compute the actual column norms for initial weights.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorization`1.DoPivot(System.Int32)">
            <summary> The pivot row becomes a row of U.
            The pivot column, minus the diagonal entry, is updated inplace
            and becomes a column of L.
            The work space should already be cleared.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationRational.SolveCol(Microsoft.SolverFoundation.Common.Rational[])">
            <summary>
            Solve L.U.x = b by morphing vec from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationRational.SolveCol(Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary>
            Solve L.U.x = b by morphing vec from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationRational.SolveRow(Microsoft.SolverFoundation.Solvers.VectorRational)">
            <summary>
            Solve x.L.U = b by morphing rgnum from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationRational.SolveApproxRow(Microsoft.SolverFoundation.Solvers.VectorDouble,System.Single)">
            <summary>
            Solve x.L.U = b by morphing rgnum from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationDouble.SolveCol(System.Double[])">
            <summary> Solve L.U.x = b by morphing rgnum from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationDouble.SolveCol(Microsoft.SolverFoundation.Solvers.VectorDouble)">
            <summary> Solve L.U.x = b by morphing vec from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.LUFactorizationDouble.SolveRow(Microsoft.SolverFoundation.Solvers.VectorDouble)">
            <summary>
            Solve x.L.U = b by morphing vec from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPVariableBranchingAlgorithm.FindBranchVariable(Microsoft.SolverFoundation.Solvers.MipNode,System.Int32@,System.Int32@,System.Double@,System.Double@)">
            <summary> pick a branching variable within a node
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPVariableBranchingAlgorithm.UpdateAfterNodeSolve(Microsoft.SolverFoundation.Solvers.MipNode,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary> update the branching algorithm after node relaxation is solved
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPVariableBranchingAlgorithm.VariableBranchingCandidates(Microsoft.SolverFoundation.Solvers.MipNode)">
            <summary> return branching candidates so that specific branching algorithm can decide on which candidate the solver should branch
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPMostFractionalVariableBranching.UpdateAfterNodeSolve(Microsoft.SolverFoundation.Solvers.MipNode,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary> pick a branching variable within a node
            </summary>
            <remarks>No update is needed for most fractional branching</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPMostFractionalVariableBranching.FindBranchVariable(Microsoft.SolverFoundation.Solvers.MipNode,System.Int32@,System.Int32@,System.Double@,System.Double@)">
            <summary>
            Find a var and value to branch
            </summary>
            <param name="node">Current MIP node</param>
            <param name="ivar">row index of the var</param>
            <param name="branchVar">var to branch</param>
            <param name="branchingLowerBound">lower bound value to branch on (value is in the reduced model space)</param>
            <param name="branchingUpperBound">upper bound value to branch on (value is in the reduced model space)</param>
            <returns>true if branching var is found</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPPseudocostVariableBranching.FindBranchVariable(Microsoft.SolverFoundation.Solvers.MipNode,System.Int32@,System.Int32@,System.Double@,System.Double@)">
            <summary>
            Find a var and value to branch
            </summary>
            <param name="node">Current MIP node</param>
            <param name="ivar">row index of the var</param>
            <param name="branchVar">var to branch</param>
            <param name="branchingLowerBound">lower bound value to branch on (value is in the reduced model space)</param>
            <param name="branchingUpperBound">upper bound value to branch on (value is in the reduced model space)</param>
            <returns>true if branching var is found</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPSingleGoalPseudocostVariableBranching.UpdateAfterNodeSolve(Microsoft.SolverFoundation.Solvers.MipNode,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary> pick a branching variable within a node
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MIPMultiGoalPseudocostVariableBranching.UpdateAfterNodeSolve(Microsoft.SolverFoundation.Solvers.MipNode,Microsoft.SolverFoundation.Services.LinearResult)">
            <summary> pick a branching variable within a node
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.MIPVarFlags.Binary">
            <summary>
            0-1 variable type 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.MIPVarFlags.Integer">
            <summary>
            integer variable type 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.MIPVarFlags.Continuous">
            <summary>
            real/double variable type
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.RowType.Equal">
            <summary>
             = 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.RowType.LessEqual">
            <summary>
            less than or equal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.RowType.GreaterEqual">
            <summary>
            greater than or equal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.RowType.Unknown">
            <summary>
            place holder
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.InitializeReducedModelWithCuts(Microsoft.SolverFoundation.Solvers.SimplexReducedModel,System.Collections.Generic.IList{Microsoft.SolverFoundation.Solvers.RowCut})">
            <summary> Add cuts to the reduced model and initialize cut related data structures
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.IsEliminatedIntegerVidFeasible">
            <summary> Check if all eliminated integer vids are fixed to integer values
            </summary>
            <returns>True if they all are fixed to integer values</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.#ctor(Microsoft.SolverFoundation.Solvers.SimplexSolver)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="solver">The solver containing the user model.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.#ctor(Microsoft.SolverFoundation.Solvers.SimplexSolver,System.Boolean[])">
            <summary>
            Creates a new instance without the specific row
            </summary>
            <param name="solver">The solver containing the user
            model.</param>
            <param name="rowFilter">row filter</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.Load">
            <summary>
            Loads our internal representation from the user specified representation.
            This only eliminates disabled rows, nothing more.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.LoadWithoutRow(System.Boolean[])">
            <summary>
            Loads our internal representation from the user specified representation.
            This only eliminates disabled rows, nothing more.
            </summary>
            <param name="rowFilter">row filter</param>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetRow(System.Int32)">
            <summary>
            Gets the index of a row (i.e., its position in the reduced model matrix) given a row id in the user model.
            </summary>
            <param name="vidRow">The id of the row.</param>
            <returns>The index of the row or -1 if the row has been eliminated.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.IsBinary(System.Int32)">
            <summary>
            Checks whether a variable is a binary variable.
            </summary>
            <param name="variable">The variable to test.</param>
            <returns>True if the variable is binary; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.IsFixed(System.Int32)">
            <summary>
            Checks whether a variable is fixed.
            </summary>
            <param name="variable">The variable to test.</param>
            <returns>True if the variable is fixed; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.IsGoal(System.Int32)">
            <summary>
            Checks whether a row is a goal row (true) or a constraint row (false).
            </summary>
            <param name="row">The row to test.</param>
            <returns>True for a goal row; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.IsRowEliminated(System.Int32)">
            <summary>
            Checks whether a row has been eliminated.
            </summary>
            <param name="row">The row to test.</param>
            <returns>True if the row has been eliminated; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetLowerBoundsDbl(System.Double[])">
            <summary> Copy the model's lower bounds into the rgnum array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetUpperBoundsDbl(System.Double[])">
            <summary> Copy the model's upper bounds into the rgnum array.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.ScaleRowsDbl">
            <summary>
            Scale the rows so each has a maximum absolute value of 1.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.ScaleColsDbl">
            <summary>
            Scale the columns so each has a maximum absolute value of 1.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetScale(System.Int32)">
            <summary>
            Return the scale factor of var
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetScaleDbl(System.Int32)">
            <summary>
            Return the extra double scale factor of var
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetDelta(System.Int32)">
            <summary>
            Return the shifting delta of var
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MapValueFromVarToVid(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            This maps FROM a value for "var" TO a value for the
            corresponding "vid".
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MapValueFromVarToVid(System.Int32,System.Double)">
            <summary>
            This maps FROM a value for "var" TO a value for the
            corresponding "vid".
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MapValueFromVidToVar(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            This maps TO a value for "var" FROM a value for the
            corresponding "vid".
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MapValueFromExactToDouble(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            The double side is scaled differently than the exact side.
            This maps a value from the exact side to the double side.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MapValueFromDoubleToExact(System.Int32,System.Double)">
            <summary>
            The double side is scaled differently than the exact side.
            This maps a value from the double side to the exact side.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.SetupRowShadowPrice(System.Int32)">
            <summary>  setup the initial shadow price table
            </summary>
            <param name="rid">a row id</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.CheckRedundantRowConstraint(System.Int32)">
            <summary>
            Check redundant row or dominant constraint
            Paper ref: Analysis of math. programming problems prior to applying the Simplex algorithm
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MarkAsModifiedRow(System.Int32)">
            <summary>
            Marks a row that has had coefficients changed during presolve.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.MarkAsMergedVid(System.Int32,System.Int32)">
            <summary>
            Marks that a column has been merged with another.
            </summary>
            <param name="original">The column merged into.</param>
            <param name="merged">The merged column.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.SetVariableUpperBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets a variable upper bound.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.SetVariableLowerBound(System.Int32,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets a variable lower bound.
            </summary>
            <param name="variable"></param>
            <param name="bound"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.GetRowBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary>
            Gets the bounds of a row.
            </summary>
            <param name="row">The row whose bounds are sought.</param>
            <param name="lowerBound">The lower bound of the row.</param>
            <param name="upperBound">The upper bound of the row.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.SetRowBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational,Microsoft.SolverFoundation.Common.Rational)">
            <summary>
            Sets the bounds of a row.
            </summary>
            <param name="row">The row whose bounds are set.</param>
            <param name="lowerBound">The lower bound of the row.</param>
            <param name="upperBound">The upper bound of the row.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexReducedModel.ComputeTableauRow(System.Int32,Microsoft.SolverFoundation.Solvers.SimplexFactoredBasis)">
            <summary>
            Compute a row in the reduced model where vid is the user vid of the basic variable in that row
            </summary>
            <param name="vid"></param>
            <param name="bas"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MipNode.GenerateCuts(Microsoft.SolverFoundation.Solvers.CutStore)">
            <summary> Generate cutting planes
            </summary>
            <returns>false if and only if the node is integer infeasible</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.MipNode.ToString">
            <summary> format values as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NewPartialPricingDbl.InitWeightsInit">
            <summary> Compute the actual column norms for initial weights.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NewPartialPricingDbl.ComputeCosts">
            <summary>
            Compute the reduced costs and put them in _rgnumCost.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NewPartialPricingDbl.FindNext">
            <summary>
            Calls FindEnteringVar to set _varEnter, _vvkEnter, and _sign.
            Calls ComputeDelta to set _vecDelta.
            Calls ValidateCost to validate the entering variable.
            Calls FindLeavingVar to set _scale, _ivarLeave, _varLeave, and _vvkLeave.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NewPartialPricingDbl.FindEnteringVar">
            <summary>
            Sets _varEnter and _sign.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.NewPartialPricingDbl.UpdateCostsAndWeights(System.Double)">
            <summary> Update the relative costs and weights.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.OptimalGoalValues.#ctor(System.Int32)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="cnum"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.OptimalGoalValues.#ctor(System.Int32,Microsoft.SolverFoundation.Common.Rational[])">
            <summary>
            Creates a new instance.
            </summary>
            <param name="cnum"></param>
            <param name="rgnum"></param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PartialPricingDbl.InitWeightsInit">
            <summary> Compute the actual column norms for initial weights.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PartialPricingDbl.ComputeCosts">
            <summary>
            Compute the reduced costs and put them in _rgnumCost.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PartialPricingDbl.FindNext">
            <summary>
            Calls FindEnteringVar to set _varEnter, _vvkEnter, and _sign.
            Calls ComputeDelta to set _vecDelta.
            Calls ValidateCost to validate the entering variable.
            Calls FindLeavingVar to set _scale, _ivarLeave, _varLeave, and _vvkLeave.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PartialPricingDbl.FindEnteringVar">
            <summary>
            Sets _varEnter and _sign.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasis._rgvarBasic">
            <summary> The basic variables.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexBasis._mpvarivar">
            <summary> For basic variables, this records the location in _rgvarBasic.
                      For non-basic variables, this records the negative of the SimplexVarValKind.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.GetBasicVar(System.Int32)">
            <summary> Lookup the variable associated with basis index ivar.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.IsBasic(System.Int32)">
            <summary> Test if variable var is part of the current basis.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.GetBasisSlot(System.Int32)">
            <summary> Lookup the basis index equivalent to the variable var.
                      -1 is returned if the variable is not in the basis.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.SetToSlacks">
            <summary> Set this basis to the set of slack variables in the given reduced model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.SetToFreedomInner(System.Double,System.Double)">
            <summary> Choose an initial basis on blended principles of avoiding restrictions,
                      maximizing basis sparseness, and domains likely to help feasibility.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.SetToFreedom">
            <summary> Choose an initial basis using Bixby's idea of maximally free variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.SetToCrash">
            <summary> Use a simple lower triangular symbolic most feasible crash basis [CRASH(LTSF)]
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.BuildRowCountList">
            <summary> walk each row to add non-free rows to the row count list 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.BuildColCountList">
            <summary> walk each column escape fixed/slack var
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexBasis.SetToVidValues(Microsoft.SolverFoundation.Common.Rational[])">
            <summary> Set this basis according to the set of values in the reduced model
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexFactoredBasis.InplaceSolveCol(System.Double[])">
            <summary> Solve L.U.x = b by morphing rgnum from b to x.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexFactoredBasis.InplaceSolveCol(Microsoft.SolverFoundation.Solvers.VectorDouble)">
            <summary> Solve L.U.x = b by morphing vec from b to x.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.PrimalDouble.kDegenerateThreshold">
            <summary> A threshold for enabling more costly anti-degeneracy algorithms
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalDouble.ReduceError(Microsoft.SolverFoundation.Solvers.PivotStrategy{System.Double})">
            <summary>
            Attempts to reduce error in the system. Typically called by the
            PivotStrategy. This does NOT update the PivotStrategy!
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalDouble.RepeatPivots(System.Int32)">
            <summary>
            This repeatedly pivots.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalDouble.UpdateBasicValues(Microsoft.SolverFoundation.Solvers.PivotStrategyDbl)">
            <summary> This recomputes basic variable values after a pivot.  Results in _rgnumBasic.
                      Parameter ps is the most recent pivot.
            </summary>
            
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.PrimalDouble._recentDegeneracyMetric">
            <summary> A measure of consecutive recent degenerate leaving variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.PrimalDouble._degeneracyFloor">
            <summary> Used to modify degeneracy metric to allow varying thresholds.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalDouble.NotifyLeaving(System.Double)">
            <summary> Note each time we successfully find a non-degenerate base.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalDouble.ApplyAntidegeneracyLeaving">
            <summary> Test if leaving-variable degeneracy avoidance algorithms should be used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.PrimalDouble.RemoveFixedLeaving">
            <summary> Test if it is time to apply priority to removing fixed variables from the basis.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PrimalExact.RepeatPivots(System.Int32,System.Int32,Microsoft.SolverFoundation.Services.LinearResult@)">
            <summary>
            This repeatedly pivots.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexLogIds">
            <summary> Identify the various kinds of Logger messages
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.VerifyBasicValues">
            <summary> Verify computation of basic variable values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.VerifyBasisSolve">
            <summary> Verify solving against current basis
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.VerifyReducedCostsExact">
            <summary> Verify computation of exact reduced costs
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.VerifyReducedCostsDouble">
            <summary> Verify computation of double reduced costs
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.ErrorBasis">
            <summary> The basis is singular
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.ErrorRefactor">
            <summary> Excessive error caused us to refactor the basis matrix
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.ErrorRestart">
            <summary> A solve was restarted due to error, either a singular basis or wandering to infeasible
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.ErrorPatch">
            <summary> Excessive error caused us to patch some numeric values
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Pivots">
            <summary> Log each pivot
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Cycles">
            <summary> Check for cycles
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Solution">
            <summary> Log solution registration
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Branching">
            <summary> Log branching decisions when solving MIPs
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.SolutionImprovement">
            <summary> Log integer solution improvements when solving MIPs
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Presolve">
            <summary> Log information about presolve
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Cuts">
            <summary> Log information about cutting planes
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.Ipm">
            <summary> Interior Point Method general
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.IpmPredictor">
            <summary> Predictor step in a predictor-corrector algorithm
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexLogIds.IpmCorrector">
            <summary> Corrector step in a predictor-corrector algorithm
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSensitivity.GetDualValue(System.Int32)">
            <summary> Return the dual value  
            </summary>
            <param name="vidRow">a row id</param>
            <returns>a number</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSensitivity.GetObjectiveCoefficientRange(System.Int32)">
            <summary> Get the coefficient range on the first objective row   
            </summary>
            <param name="vid">a vairable id</param>
            <returns>a range </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSensitivity.GetObjectiveCoefficientRange(System.Int32,System.Int32)">
            <summary> Get the coefficient range on the first objective row   
            </summary>
            <param name="vid">a variable id</param>
            <param name="pri">a speific goal</param>
            <returns>a range </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSensitivity.GetVariableRange(System.Int32)">
            <summary> Get the rhs range on the specific row   
            </summary>
            <param name="vid">a variable id</param>
            <returns>a range</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSensitivity.GetRhsRange(System.Int32,Microsoft.SolverFoundation.Services.LinearSolverSensitivityRange@)">
            <summary>Gets the rhs range for a non-basic variables (active constraints)
            See chapter 7 in "Linear Programming, Foundation and Extensions, Second Edition, Robert J. Vanderbei"
            The code is a modified version of the book computation, as the book treat models in Standard Form.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexSolverParams">
            <summary>
            Parameters used by a solver 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.#ctor(System.Func{System.Boolean})">
            <summary> construct a solver parameter object
            </summary>
            <param name="fnQueryAbort">a call back delegate</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.#ctor">
            <summary> constructor 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary> adaptor to convert Directive into SimplexSolverParams
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.#ctor(Microsoft.SolverFoundation.Solvers.SimplexSolverParams)">
            <summary> copy constructor
            </summary>
            <param name="prm">a parameter to be cloned from</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.ShouldAbort(Microsoft.SolverFoundation.Services.ILinearSimplexStatistics)">
            <summary> callback on whether the solver should abort execution 
            </summary>
            <param name="stat">callback context</param>
            <returns>true if should stop. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyStartSolve(System.Int32)">
            <summary> callback before the solve starts 
            </summary>
            <param name="threadIndex">simplex thread id</param>
            <returns>return code is not used</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyStartFactorization(System.Int32,Microsoft.SolverFoundation.Services.ILinearSimplexStatistics,System.Boolean)">
            <summary> callback before the matrix factorization 
            </summary>
            <param name="threadIndex">a simplex thread id</param>
            <param name="stat">context</param>
            <param name="fDouble">whether double arithmetic is used</param>
            <returns>true if the execution should continue. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyEndFactorization(System.Int32,Microsoft.SolverFoundation.Services.ILinearSimplexStatistics,System.Boolean)">
            <summary> callback after the matrix factorization 
            </summary>
            <param name="threadIndex">a simplex thread id</param>
            <param name="stat">context</param>
            <param name="fDouble">whether double arithmetic is used</param>
            <returns>true if the execution should continue. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyFindNext(System.Int32,Microsoft.SolverFoundation.Services.ILinearSimplexStatistics,System.Boolean)">
            <summary> callback when Simplex finds the next pair of pivoting variables 
            </summary>
            <param name="threadIndex">a simplex thread id</param>
            <param name="stat">context</param>
            <param name="fDouble">whether double arithmetic is used</param>
            <returns>true if the execution should continue. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyStartPivot(System.Int32,Microsoft.SolverFoundation.Services.ILinearSimplexStatistics,Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation)">
            <summary> callback before the pivot
            </summary>
            <param name="threadIndex">a simplex thread id</param>
            <param name="stat">context</param>
            <param name="pi">pivoting information</param>
            <returns>true if the execution should continue. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.NotifyEndPivot(System.Int32,Microsoft.SolverFoundation.Services.ILinearSimplexStatistics,Microsoft.SolverFoundation.Solvers.ISimplexPivotInformation)">
            <summary> callback after the pivot
            </summary>
            <param name="threadIndex">a simplex thread id</param>
            <param name="stat">context</param>
            <param name="pi">pivoting information</param>
            <returns>true if the execution should continue. otherwise false</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.RaiseSolvingEvent">
            <summary> Raise the solving event during simplex solve
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.FillInSolverParams(Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Fill in SimplexSolverParams based on the given directive.
            </summary>
            <param name="dir">The directive instance that contains all the parameter settings</param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.QueryAbort">
            <summary> Callback for ending the solve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.Solving">
            <summary>
            Callback called during solve
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.UseDouble">
            <summary> Use double arthimetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.UseExact">
            <summary> Use exact arthimetic 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.KindOfSolver">
            <summary> Choose a solver 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.Algorithm">
            <summary> Choose a solver algorithm 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.Costing">
            <summary> Simplex costing 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.VariableFeasibilityTolerance">
            <summary> Numerical tolerance for variables 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.CostTolerance">
            <summary> Numerical tolerance for Simplex pricing 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.UserOveride">
            <summary> whether being overriden by users
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.UserOverideCostEps">
            <summary> whether being overriden by users
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.UserOverideVarEps">
            <summary> whether being overriden by users
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.Abort">
            <summary> Should the solver stop 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MaxPivotCount">
            <summary> Simplex specific. The upper limit of pivit count a solver can do 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.ShiftBounds">
            <summary> Should a solver shift variable bounds 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.InitialBasisKind">
            <summary> Simplex specific. Choose the initial basis. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MaxGeometricScalingIterations">
            <summary> the upper limit of geometric scaling in the reduced model 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.GeometricScalingThreshold">
            <summary> the threshhold of geometric scaling in the reduced model 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.GetSensitivityReport">
            <summary> whether to generate sensitivity report 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.GetInfeasibilityReport">
            <summary> whether to generate infeasibility report 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.PresolveLevel">
            <summary> the level of presolve the SimplexSolver will apply 
            -1 means default or automatic, 0 means presolve, >0 primal and dual reduce
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerGapTolerance">
            <summary> Gets or sets the tolerance to declare an integer solution optimal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerSearchStrategy">
            <summary> Gets or sets the search strategy for finding an optimal integer solution.
            </summary>
            <remarks>
            This property controls the post-feasibility search strategy.
            The pre-feasibility search strategy cannot be changed.
            </remarks>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerBranchingStrategyPreFeasibility">
            <summary> Gets or sets the way the solver selects variables to branch on, before feasibility is achieved,
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerBranchingStrategyPostFeasibility">
            <summary> Gets or sets the way the solver selects variables to branch on, after feasibility is achieved,
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerPresolve">
            <summary> Gets or sets whether to presolve the model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerNodePresolve">
            <summary> Gets or sets whether to perform presolve during the search.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerGenerateCuts">
            <summary> Gets or sets whether to generate cuts.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.MixedIntegerGomoryCutRoundLimit">
            <summary> Gets or sets the level limit on cutting plane generation
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SimplexSolverParams.CutKinds">
            <summary> Control what kinds of cut will be generated in cut-and-branch.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SimplexSolveState">
            <summary> The current simplex solver state.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.PreInit">
            <summary>
            Before solve has been started.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.Init">
            <summary>
            Start. Currently the first event happens after this state is changed.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.Presolve">
            <summary>
            In presolve. Currently the first event happens after this state is changed.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.SimplexSolving">
            <summary>
            During simplex solving.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.MipSolving">
            <summary>
            In mip solving.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.MipNewSolution">
            <summary>
            During mip, new best mip solution found.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SimplexSolveState.MipBranchCreated">
            <summary>
            During mip, branch created.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.PartialPricingDblSOS.FindEnteringVar">
            <summary>
            Sets _varEnter and _sign.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOSUtils.IsEnteringCandidate(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary> check status of SOS1/SOS2 row
            For SOS2 return true if no element is basic or if a Neightbor is basic, otherwise returns false.
            For SOS1 returns true if no element is basic, otherwise returns false.
            </summary>
            <param name="thd"></param>
            <param name="var"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOSUtils.UpdateEnteringVar(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>Called when variable is decided to be the entering to the basis
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOSUtils.IsNeightbor(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32,Microsoft.SolverFoundation.Solvers.SOS2Status,System.Int32)">
            <summary>
            
            </summary>
            <param name="thd"></param>
            <param name="sos2Row"></param>
            <param name="sos2Status"></param>
            <param name="var"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOSUtils.IsSOSVar(Microsoft.SolverFoundation.Solvers.SimplexTask,System.Int32)">
            <summary>Is var from type of SOS
            </summary>
            <param name="thd">the SimplexTask</param>
            <param name="var">vid of var</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CentralPathSolver">
            <summary> CentralPathSolver is a partial class to provide a limited name scope.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StandardModel">
            <summary> The standard model is
                      Minimize &lt;c,x> + x*Qx/2 + F(x)
                      Ax = b
                      x >= 0
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel">
            <summary>Base class for interior point solver models.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics">
            <summary> IPM algorithm solution metrics.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.RowCount">
            <summary> The number of rows in the solver model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.VarCount">
            <summary> Total number of variables, user and slack.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.Primal">
            <summary> The primal version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.Dual">
            <summary> The dual version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.Gap">
            <summary> The gap between primal and dual objective values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.Algorithm">
            <summary> The kind of IPM algorithm used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.IInteriorPointStatistics.KktForm">
            <summary> The form of KKT matrices used.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._goalDirection">
            <summary> -1 == maximize, 0 == unknown, +1 = minimize (the standard)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._goalVid">
            <summary>VID of the (single) goal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._solution">
            <summary>Solution.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.model">
            <summary>The user model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._socpModel">
            <summary>The user model (SOCP).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.removedRowsByVid">
            <summary> Keep track of rows removed due to unbounded slacks
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">Row vid.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._infeasibleRowVarPairs">
            <summary> List of &lt;rowVid, varVid> pairs found infeasible (varVid == -1 for row itself).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._removeRedundantMinMax">
            <summary>Remove rows that are found to be redundant due to upper and lower bounds on vars.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Solve(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary>Solves the model.
            </summary>
            <param name="prm">IPM solver parameters.</param>
            <returns>A LinearResult.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.IsGoalMinimize(System.Int32)">
            <summary> Confirm the direction of the goal.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.MapVarValues(Microsoft.SolverFoundation.Common.Rational[])">
            <summary>Map solution to user model.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.IsGoalVid(System.Int32)">
            <summary> Check to see if a vid represents a goal.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel._inferredBounds">
            <summary> Track tighter inferred bounds assigned to user variables
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.GetUserBounds(System.Int32,Microsoft.SolverFoundation.Common.Rational@,Microsoft.SolverFoundation.Common.Rational@)">
            <summary> Get the user model bounds, imposing any inferred tightening.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.RemoveRedundant">
            <summary> Some models have redundant variables.
                      It is best to remove them and any rows they play in.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.SingletonRows">
            <summary> Singleton rows can be removed by adjusting variable bounds.
            </summary>
            <remarks>Here is an example of an LP where this rule applies.  We can introduce
            a lower bound x1 >= 2, and remove the constraint:
            min x1
            2 x1 >= 4
            x1 &lt;= 10
            </remarks>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.RemoveEmptyRows">
            <summary> Empty rows can be removed.
            </summary>
            <remarks>Here is an example of an LP where this rule applies. It is infeasible because 0 is not greater than 2.
            min x1
            4 >= 0 * x1 >= 2
            x1 &lt;= 10
            </remarks>    
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.CheapDual">
            <summary>Cheap dual tests - see section 2.1.4 of Meszaros "Advanced preprocessing techniques for LP and QP" (2003).
            </summary>
            <returns>True if any bounds were changed.</returns>
            <remarks>Here is an example of an LP where this rule applies.  x1 can be fixed
            at its upper bound 10:
            min -x1
            2x1 + x2 >= -1
            -Inf &lt;= x1 &lt;= 10
            </remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.TightenBounds(System.Int32)">
            <summary> Find rows which reduce the bounds of variables
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Logger">
            <summary>The LogSource.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.SolveState">
            <summary> Phases of the IPM solution process.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.GoalVid">
            <summary>VID of the (single) goal.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Solution">
            <summary>Solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.RowCount">
            <summary> The number of rows in the solver model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.VarCount">
            <summary> Total number of variables, user and slack.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Primal">
            <summary> The primal version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Dual">
            <summary> The dual version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Gap">
            <summary> The gap between primal and dual objective values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.Algorithm">
            <summary> The kind of IPM algorithm used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.KktForm">
            <summary> The form of KKT matrices used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.InfeasibleRowVarPairs">
            <summary> List of infeasible (row, var) pairs.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointReducedModel.RemoveRedundantMinMax">
            <summary>Remove rows that are found to be redundant due to upper and lower bounds on vars.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._epsilon">
            <summary> Threshold used for numerical stability.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._qpModel">
            <summary> The user-model version of the Q matrix
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._mpvidQid">
            <summary> A map from vid to an index for the _qpModel
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._mapQidToVid">
            <summary> The Q matrix may be compressed to just those variables
                      with a quadratic component.  Map the indexes of the Q
                      and qpModel to the Vids of the user model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._mirrorRowCount">
            <summary> The count of additional rows invented to support bound mirrors
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._ignoredUserVarCount">
            <summary> Fixed or unbounded slack variables which have been removed
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._slackVarCount">
            <summary> The count of slack variables invented to convert rows to equality
                      and to mirror dual-bounded rows or variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._vidToVars">
            <summary> Map from user-model vid to standard model var and row.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._varToVids">
            <summary> Map from standard model var to user-model vid
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._rowToVids">
            <summary> Map from standard model row to user-model vid
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._vidToRows">
            <summary> Map from user-model vid to standard model row 
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._inventions">
            <summary> During initialization we keep a list of all dual-bounded
                      vars and rows so we can append their mirror rows.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._unboundedVids">
            <summary> Keep track of the user variables which are unbounded
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._A">
            <summary> The Standard constraint coefficients in Ax = b, exact and double
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._bExact">
            <summary> The exact RHS values in Ax = b
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._b">
            <summary> The double RHS values in Ax = b
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._cExact">
            <summary> the exact linear portion of the goal Minimize&lt;c,x>
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._c">
            <summary> the double linear portion of the goal Minimize&lt;c,x>
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._constantCost">
            <summary> The cost function may have a constant component.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._Q">
            <summary> the quadratic portion of the minimization goal
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._QnotDiagonal">
            <summary> If Q is present and not diagonal then we cannot use
                      Normal form to solve the Reduced KKT.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._x">
            <summary> The primal variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._y">
            <summary> The dual variables in A*y + z = c
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._yVec">
            <summary> The dual variables as a Vector.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel._z">
            <summary> The dual slacks
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.ReverseMapParameters(System.Int32,System.Double@,System.Double@)">
            <summary> Characterize the standard => user map,  s·x + t => v
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.#ctor(Microsoft.SolverFoundation.Services.LinearModel,Microsoft.SolverFoundation.Common.LogSource,Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32[],System.Int32)">
            <summary> Creates a new instance.
            Loads our internal representation from the user specified representation.
            This only eliminates disabled rows, nothing more.
            </summary>
            <param name="model">The object containing the user model.</param>
            <param name="logger">The LogSource.</param>
            <param name="qpModel">A compact matrix of quadratic coeffs indexed by Qid.</param>
            <param name="mpvidQid">vid to Qid, zero means not used in the quadratic.</param>
            <param name="presolveLevel">Presolve level.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.MakeReductions(System.Int32[])">
            <summary> Predict the initial size necessary for the SparseMatrix
            </summary>
            <param name="mpvidQid"> the map from vid to indexes on the compressed qpMatrix </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.RemoveIdleRows(System.Int32@,System.Int32@)">
            <summary> Some models have constant "variables" which result in empty rows.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.FillMaps">
            <summary> Fill the vidToVar and varToVid maps, categorizing every vid
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.NullPermute">
            <summary> Choose a permutation of rows and vars which will minimize array fill
                      during factorizations.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.CopyInitialMatrix">
            <summary> Copy initial values from user model into Matrix using prepared maps
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.GetDualValue(System.Double[],System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="y">Vector containing dual values.</param>
            <param name="vidRow">Row vid.</param>
            <returns>The dual value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.GetDualFromDualVector(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary>Return the dual value corresponding to a vid.
            </summary>
            <param name="y">Vector containing dual values.</param>
            <param name="vid">A vid corresponding to a constraint.</param>_
            <returns>
            Returns the dual value.  If the constraint has both upper and lower bounds
            then there are actually two dual values.  In this case the dual for the active bound (if any) will be returned.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.QisTriviallyNotConvex">
            <summary> Do some quick tests of _Q and return true if it is not convex.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.StandardModel.MapVidToValue(System.Int32)">
            <summary> Map from a var's value  TO a value for the user-model "vid".
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.RowCount">
            <summary> standard model number of rows
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.GoalCount">
            <summary> Count of goals //REVIEW: tanjb: IPM supports == 1
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.DirectSolution">
            <summary> True means that the model has a pre-solved solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.VarCount">
            <summary> Standard Model total number of variables, user and slack.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.Primal">
            <summary> The primal version of the objective
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.Dual">
            <summary> The dual version of the objective
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.StandardModel.GoalIsUnbounded">
            <summary> Did we detect an unbounded objective?
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMapKind">
            <summary> Mapping types for rows and vars
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMapKind.RowConstant">
            <summary> Goal is less than RowConstant
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMapKind.VarConstant">
            <summary> All row kinds are less than VarConstant
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMap">
            <summary> This is the key to understanding how user vids map to standard vars
            </summary>
            <remarks> Map from _solver (user-model) vid to standard model var, or reverse:
               Condition	      Forward map	          Reverse map
               0 ≤ v ≤ ∞	      v => x	              x => v
               l ≤ v ≤ ∞	      v - l => x	          x + l => v
               -∞ ≤ v ≤ u	      -v + u => x	          u - x => v
               l ≤ v ≤ u   	    v - l => xl + l,
                                xl - xu = 0	          xl + l => v
               ∞ ≤ v ≤ ∞	      Not yet implemented.	
               l = u	          v => l	              l => v
            </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMap.iVar">
            <summary> MinValue => eliminated, non-negative => standard var
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMap.mirror">
            <summary> MinValue => none, negative => row, otherwise mirror var
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardModel.VidToVarMap.kind">
            <summary> goal &lt; row kinds &lt; var kinds
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.IterationStartedCallback">
            <summary>Called at the start of each iteration.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver._mu">
            <summary> The mix ratio for the log barrier functions, also
                      known as the complementarity measure
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver._gap">
            <summary> Duality gap.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver._iterations">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver._ipmKktForm">
            <summary>The KKT formulation used by the algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.#ctor(Microsoft.SolverFoundation.Solvers.InteriorPointSolver,Microsoft.SolverFoundation.Common.LogSource,Microsoft.SolverFoundation.Solvers.CoefMatrix,System.Int32[],System.Int32)">
            <summary> Creates a new instance.
            </summary>
            <param name="solver">The object containing the user model.</param>
            <param name="logger">The LogSource.</param>
            <param name="qpModel">A compact matrix of quadratic coeffs indexed by Qid.</param>
            <param name="mpvidQid">vid to Qid, zero means not used in the quadratic.</param>
            <param name="presolveLevel">Presolve level.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.Half_xQx">
            <summary>Result compute xQx/2.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.MeasureDuality(System.Double[],System.Double[])">
            <summary> Calculate the duality measure (Nocedal and Wright 2nd ed, 14.6)
            </summary>
            <param name="x"> primal vars </param>
            <param name="z"> primal slacks </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BigInnerProduct(System.Double[],System.Double[])">
            <summary> z = x[]·y[] -- (extension method)
            </summary>
            <returns> inner (dot) product of x and y </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.InitializeCentralPath(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary> Choose Augmented or Normal, and get an initial value
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.SolveCentralPath(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary> Run Central Path iterations
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.Solve(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary>solve problems of form Ax >= b, 0 &lt;= x, minimize &lt;c,x>.
            </summary>
            <param name="prm"> solver parameters </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">Row vid.</param>
            <returns>
            Returns the dual value.  If the constraint has both upper and lower bounds
            then there are actually two dual values.  In this case the dual for the active bound (if any) will be returned.
            </returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.Algorithm">
            <summary>The algorithm kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KktForm">
            <summary>The KKT formulation used by the algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.Gap">
            <summary> Duality gap.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem">
            <summary> Factor and solve using a blend of Augmented and Normal form.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem">
            <summary> Factor and solve using KKT
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._n">
            <summary> primal column count
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._m">
            <summary> primal row count
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._δz">
            <summary> The line-step for z (dual) slacks
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._diagonalExponents">
            <summary> Capture the exponents of the leading diagonal, used for
                      tuning pivot order for stability.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._wide">
            <summary> A constrained pairing helps stabilize.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.#ctor(Microsoft.SolverFoundation.Solvers.CentralPathSolver)">
            <summary> KKTsystem is context for factoring and solving
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.FillKKTandFactor(System.Double@)">
            <summary>Form the matrix of the KKT and factor it.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.InitializeValuesSimple">
            <summary> Initialize x, y, z with a good guess
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.ReviseInitialValues">
            <summary> If the x, y, z values stray negative they are made
                      positive by adding a uniform correction factor.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.InitializeValues">
            <summary> Initialize x, y, z with a good guess
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.AffineStepRHS">
            <summary> Calculate the RHS for the Affine step.  Sets
                      _nVec = c + Qx - A*y, and _mVec = b - Ax, and
                      also builds _rhs = {_nVec, _mVec}
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.SolveAndCalculateStep(System.Double,System.Double[],System.Boolean,System.Double@,System.Double@,System.Double@)">
            <summary> Solve the KKT to derive ΔxΔy, Δz, and α prime and α dual.
                      The corrector, (mu - dxdz), is conditional upon dxdz being present.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.FinishStep(System.Double,System.Double,System.Double)">
            <summary> Given Δx, Δy, Δz, α for prime and dual, calculate the new x, y, and z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.PredictorCorrectorStep(System.Boolean,System.Double)">
            <summary> Given the step for x,y calculate the steps for z.
                      Use steps aiming to improve centrality.
            </summary>
            <param name="refine"> should iterative refinement be applied to the matrix solution? </param>
            <param name="rate"> 0 &lt;= rate &lt; 0.995 controls rate of convergence </param>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._µ">
            <summary> The complementarity measure
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._xVars">
            <summary> The primal Variables
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._y">
            <summary> The dual variables
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._zComps">
            <summary> The primal complements
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._A">
            <summary> The reduced Linear coefficients
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._Q">
            <summary> The reduced Quadratic coefficients
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._b">
            <summary> The reduced primal row bounds
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem._c">
            <summary> The reduced primal costs
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.NonZeroesCount">
            <summary> An upper bound of the non-zeroes anticipated after fill-in
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.Decided">
            <summary> If the model is decided during construction, we set this.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.KKTsystem.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._blendedKkt">
            <summary> The LLt = ADAt factorization mechanism for Normal form.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._rhsX">
            <summary> -r_cx + r_zx / x
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._rhsS">
            <summary> -r_cs + r_zs / s
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._rhsB">
            <summary> -rb = b - A (x:s)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._δx">
            <summary> step change in the augmented X
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._δs">
            <summary> step change in the simple X
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._δy">
            <summary> step change in the Y
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._δz_x">
            <summary> step change in the augmented complements
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._δz_s">
            <summary> step change in the simple complements
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem._rate">
            <summary> a value 0 &lt;= rate &lt; 0.995 controls the rate of convergence
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.IsUnboundedX(System.Int32)">
            <summary> only unbounded variables have zero complementarity
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.IsUnboundedS(System.Int32)">
            <summary> only unbounded variables have zero complementarity
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.FillKKTandFactor(System.Double@)">
            <summary>Result _KKT is the upper triangular, _L will be the lower.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.InitializeValuesSimple">
            <summary> Initialize x, y, z with a good guess
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.ReviseInitialValues">
            <summary> If the x, y, z values stray negative they are made
                      positive by adding a uniform correction factor.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.InitializeValues">
            <summary> Initialize x, y, z with a good guess
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveAndCalculateStep(System.Double,System.Double[],System.Boolean,System.Double@,System.Double@,System.Double@)">
            <summary> Solve the Normal form KKT to derive δx δs δy, δz, and α prime and α dual.
                      The corrector, (mu - dxdz), is conditional upon dxdz being present.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.AffineStepRHS">
            <summary> Calculate the RHS for the Affine step, rhsS is a side-effect.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.CorrectorStepRHS">
            <summary> Calculate the RHS for the Corrector step, starting from Affine.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveForXYS(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Boolean)">
            <summary> Solve the Blended form KKT to derive δx δs δy.
                      The outputs are additive to allow for iteration of residuals.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveForXYS(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary> Solve the Blended form KKT to derive δx δs δy.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.PredictorElementZ(System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary> The calculation for affine δz[i].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolvePredictorZ(System.Double@,System.Double@,System.Double@)">
            <summary> Solve the Normal form KKT to derive δx δs δy, δz, and α prime and α dual.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.CorrectorElementZ(System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary> The calculation for predictor δz[i].
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveCorrectorZ(System.Double,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Double@,System.Double@,System.Double@)">
            <summary> Solve the Normal form KKT to derive δx δs δy, δz, and α prime and α dual.
                      The corrector, (mu - dxdz), is conditional upon dxdz being present.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.BoundComplement(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Int32,System.Double)">
            <summary> Limit the new x:s, and z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.FinishStep(System.Double,System.Double,System.Double)">
            <summary> Given δx, δs, δy, δz, α for prime and dual, calculate the new x, s, y, and z.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.PredictorCorrectorStep(System.Boolean,System.Double)">
            <summary> Given the step for x,y calculate the steps for z.
                      Use steps aiming to improve centrality.
            </summary>
            <param name="refine"> should iterative refinement be applied to the matrix solution? </param>
            <param name="rate"> 0 &lt;= rate &lt; 0.995 controls rate of convergence </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveTrivialQuadratic">
            <summary> Find a closed form solution for a quadratic problem.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolvePurelyQuadraticBlendedSystem">
            <summary> Find the closed form solution when A is null Q involves unbounded variables only.
            In this case we can simply solve for x directly using Q.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.SolveDiagonalQuadraticNoConstraints">
            <summary> Find the closed form solution when A is null and there are only diagonal quadratic entries.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.NonZeroesCount">
            <summary> An upper bound of the non-zeroes anticipated after fill-in
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.CentralPathSolver.BlendedSystem.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModel">
             <summary>LP/QP/SOCP model used by solver (Solver Model)
            
                  minimize             cL'*xL +    cU'*xU + cF'*xF                |
                  subject to  bG &lt;= AGL*xL +    AGU*xU + AGF*xF &lt;= bG + uH  |     mG
                              bK &lt;= AKL*xL +    AKU*xU + AKF*xF                |     mK
                                   0 &lt;= xL, 0 &lt;= xU &lt;= uV                |      
                  -------------------------------------------------------       
                                        nL       nU       nF                   (sizes)
             </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.#ctor(Microsoft.SolverFoundation.Services.LinearModel,Microsoft.SolverFoundation.Common.LogSource,System.Int32)">
            <summary>Create a new instance using the given LinearModel.
            </summary>
            <param name="model">The LinearModel.</param>
            <param name="log">The LogSource.</param>
            <param name="presolveLevel">Presolve level.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.MapVarValues(Microsoft.SolverFoundation.Common.Rational[])">
            <summary>Map vars to user model values.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.SolveZeroConstraints(Microsoft.SolverFoundation.Common.Vector)">
            <summary>Solve a zero-constraint (null A) problem.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.GetDualValue(Microsoft.SolverFoundation.Common.Vector,System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="y">Vector containing dual values.</param>
            <param name="vidRow">Row vid.</param>
            <returns>The dual value.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.GeneralModel.Primal">
            <summary> The primal version of the objective
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.GeneralModel.Dual">
            <summary> The dual version of the objective
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMapKind">
            <summary> Mapping types for rows and vars
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMapKind.RowConstant">
            <summary> Goal is less than RowConstant
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMapKind.VarZero">
            <summary> All row kinds are less than VarZero
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMap">
            <summary> This is the key to understanding how user vids map to solver vars.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMap.iVar">
            <summary> MinValue => eliminated, non-negative => standard var
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VidToVarMap.kind">
            <summary> goal &lt; row kinds &lt; var kinds
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition">
            <summary>Categorizes constraints by type.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.G">
            <summary>lower and upper bounded, including equality
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.IG">
            <summary>lower bounded inequality
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.IL">
            <summary>upper bounded inequality, to be transformed to lower bounded
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.QR">
            <summary>Quadratic or rotated quadratic cones.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.F0">
            <summary>free or zero row, these are to be ignored
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.ToString">
            <summary>String representation.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.GeneralModel.ConstraintPartition.Count">
            <summary>Total number of constraints.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition">
            <summary>Categorizes variables by type.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.LG">
            <summary>lower bounded variables (greater than lower bound)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.LL">
            <summary>upper bounded variables, to be transformed into lower bounded
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.U">
            <summary>upper and lower bounded variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.F">
            <summary>free variables
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.Zero">
            <summary>zero columns in A (zero coefficients in all rows)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.Const">
            <summary>constant (fixed) variables
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModel.VariablePartition.ToString">
            <summary>String representation.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor">
            <summary>Solves systems of the form
             ⌠  a dP_x        Ax*              │ ⌠Δx │
             │   Ax     b dD - As dP_s^-1 As*  ⌡ │Δy ⌡
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Func{System.Boolean},Microsoft.SolverFoundation.Common.FactorizationParameters)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.SetBlendedValues(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector,System.Boolean)">
            <summary> Compute the blended matrix:
            
             ⌠  a dP_x        Ax*              │ ⌠Δx │
             │   Ax     b dD - As dP_s^-1 As*  ⌡ │Δy ⌡
            </summary>
            <param name="alpha">The multiplier for the primal diagonal perturbation</param>
            <param name="dPrml">Primal diagonal perturbation.</param>
            <param name="beta">The multiplier for the dual diagonal perturbation.</param>
            <param name="dDual">Dual diagonal perturbation.</param>
            <param name="setA">Whether the entire factor needs to be set, or only the perturbations.
            This implementation does not use setA, because the blended factor combines A with the 
            perturbations - therefore it is impossible to update the perturbations without looking
            at A.
            </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.ZeroPivotRepair(System.Int32,System.Double,System.Collections.Generic.List{Microsoft.SolverFoundation.Common.SparseVectorCell})">
            <summary> Cause a zero pivot's row and column to be ignored.
            </summary>
            <returns> throw a DivideByZeroException </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.ComputeResidue(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
             <summary>
             Calculate the residue r* = Mx - r using the augmented equations:
            
                    M          x       r
              ⌠  a dP  A*  │ ⌠x_p│ = ⌠r_p│
              │   A   b dD ⌡ │x_d⌡   │r_d⌡
             </summary>
             <returns>The 2-norm of the residue.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.SolveSystem(System.Double,Microsoft.SolverFoundation.Common.Vector,System.Double,Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary> solve for vectors gfx, gfy, using prepared blended factors.
            gfx and gfy are additive so that caller may use a residual correction loop
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.GeneralModelBlendedFactor.ZeroPivots">
            <summary>Number of zero pivots encountered during factorization.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IpmVectorUtilities.IPMRatioTest(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary>The IPM ratio test: (the input vector x should be elementwise positive) 
            </summary>
            <returns>Returns maximum alpha such that x + alpha*dx is nonegative vector </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IpmVectorUtilities.IPMUniformTest(Microsoft.SolverFoundation.Common.Vector,System.Double)">
            <summary>The IPM uniform test for complementary pairs
            </summary>
            <param name="xz"></param>
            <param name="mu"></param>
            <returns>Returns minimum (over i) of xz[i]/mu</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IpmVectorUtilities.TruncateBottom(Microsoft.SolverFoundation.Common.Vector,System.Double)">
            <summary>Threshold truncating: this[i] = max( this[i], threshold )
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.IpmVectorUtilities.TruncateTop(Microsoft.SolverFoundation.Common.Vector,System.Double)">
            <summary>Threshold truncating: this[i] = min( this[i], threshold )
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver">
             <summary>Homogeneous self-dual predictor-corrector LP solver using the general model:
            
                  minimize             cL'*xL +    cU'*xU + cF'*xF                |
                  subject to  bG &lt;= AGL*xL +    AGU*xU + AGF*xF &lt;= bG + uH  |     mG
                              bI &lt;= AIL*xL +    AIU*xU + AIF*xF                |     mI
                                   0 &lt;= xL, 0 &lt;= xU &lt;= uV                |      
                  -------------------------------------------------------       
                                        nL       nU       nF                   (sizes)
             </summary>
             <remarks>Please see the implementation notes for details.
             </remarks>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.Solving">
            <summary> Solving callback.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.IterationStartedCallback">
            <summary>Called at the start of each iteration.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver._hsdFactor">
            <summary>Factorization.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver._options">
            <summary>Solver options.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver._iterations">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver._gap">
            <summary> Duality gap.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.#ctor(Microsoft.SolverFoundation.Solvers.InteriorPointSolver,Microsoft.SolverFoundation.Common.LogSource,Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary>Create a new instance.
            </summary>
            <param name="solver">The InteriorPointSolver containing user data.</param>
            <param name="log">The LogSource.</param>
            <param name="prm">Solver parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.Solve(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary>Solve an LP.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">Row vid.</param>
            <returns></returns>
            <returns>The dual value.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.Solve">
            <summary>Core solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.NumericalFactorization">
            <summary> Numerical factorization (define necessary state in derived class)
            <remarks>
            Derived classes should implement specific methods to solve the augmented system:
               | Dp  A' | |dx| - |rx|
               | A   Dd | |dy| - |ry| 
            </remarks>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.SetLinearSystem(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary>Set the values of the augmented system.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.SetLinearSystemDiagonals(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector)">
            <summary>Set the diagonal values of the augmented system.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.SolveSystem(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector@,System.Int32)">
            <summary>Solve the augmented system.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.ComputeResidue(Microsoft.SolverFoundation.Common.Vector@,Microsoft.SolverFoundation.Common.Vector)">
            <summary>Compute the residual of the solution to the augmented system.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.CleanUpLinearSolver">
            <summary>Cleanup the linear solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.CleanUpMemory">
            <summary>Cleanup workspace.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.Gap">
            <summary> Duality gap.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.RowCount">
            <summary>Row count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.VarCount">
            <summary>Variable count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.Algorithm">
            <summary>The algorithm kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdGeneralModelSolver.KktForm">
            <summary>The KKT formulation used by the algorithm.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.HsdSolverOptions">
            <summary>HSD solver parameters and stopping criteria.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.SetTolerance(System.Double,System.Boolean)">
            <summary>Set primal, dual, gap tolerance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.#ctor">
            <summary>Create a new instance with default values.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsPrimalInfeasible">
            <summary>Termination criteria for relative primal feasibility
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsDualInfeasible">
            <summary>Termination criteria for relative dual feasibility
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsAccuracy">
            <summary>Termination criteria for relative accuracy
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsMuRatio">
            <summary>Termination criteria for duality gap change ratio 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsTauKappaRatio">
            <summary>Termination criteria for tau/kappa (infeasibility)
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MaxIterations">
            <summary>maximum number of iterations allowed
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.AdvancedStartingPoint">
            <summary>whether or not to use advanced start point
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.BetaMaxCentering">
            <summary>max centering component in predictor-corrector-centering
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.BetaComplementUnif">
            <summary>ratio test for uniformity of complementarity 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.BetaBackOffRatio">
            <summary>back off ratio due to nonuniform complementarity
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MaxBackoffAttempts">
            <summary>maximum number of backoff attempts per iteration
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MultipleCorrections">
            <summary>whether or not to use Gondzio's multiple corrections
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MCStepThreshold">
            <summary>threshold for stepsize (if alpha is smaller) to do mc
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MCComplementBound">
            <summary>complementarity uniform bound (0.1 ~ 1/0.1) 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MaxCorrections">
            <summary>number of maximum corrections allowed
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MaxIR">
            <summary>max number of IRs before changing cond for perturbation   
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MaxFastIR">
            <summary>max number of IRs considered as fast convergence
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsIR">
            <summary>relative residue norm for iterative refinements
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.MinConeSizeLowRank">
            <summary> Minimum size for quadratic cone to do sparse+low-rank update
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsDualGapInfeasible">
            <summary>Stopping criteria for relative duality gap.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.BetaNeighborhood">
            <summary>One-sided infinity norm of neighborhood size. (1 is central path) 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.EpsInsufficientStep">
            <summary>The threshhold for "insufficient step size".  Consecutive tiny steps
            indicate we are stuck and should consider returning with reduced accuracy.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.HsdSolverOptions.FactorizationParameters">
            <summary>Symbolic factorization parameters.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointSolver">
            <summary> The Microsoft Solver Foundation interior point solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.#ctor">
            <summary> Construct an InteriorPointSolver with defaults.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.#ctor(Microsoft.SolverFoundation.Services.ISolverEnvironment)">
            <summary> Construct an InteriorPointSolver with defaults.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.#ctor(System.Collections.Generic.IEqualityComparer{System.Object})">
            <summary> Construct an InteriorPointSolver with specified comparison mechanism for keys
            </summary>
            <param name="cmp">Key comparison mechanism.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.AddRow(System.Object,Microsoft.SolverFoundation.Services.SpecialOrderedSetType,System.Int32@)">
            <summary> Add a reference row for a SOS set. Each SOS set has one reference row
            </summary>
            <param name="key">a SOS key</param>
            <param name="sos">type of SOS</param>
            <param name="vidRow">the vid of the reference row</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetSpecialOrderedSetTypeRowIndexes(Microsoft.SolverFoundation.Services.SpecialOrderedSetType)">
            <summary> Return a list of SOS1 or SOS2 row indexes
            </summary>
            <param name="sosType"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetProperty(System.String,System.Int32)">
            <summary>Get the value of a property.
            </summary>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <returns>The property value as a System.Object.</returns>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.ValidateInSolveState(System.String)">
            <summary>
            If not in solving state and property is one that solver supports, throw
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.SetProperty(System.String,System.Int32,System.Object)">
            <summary>Set the value of a property.
            </summary>
            <remarks>Currently there is no support for setting propery during solve.</remarks>
            <param name="propertyName">The name of the property to get.</param>
            <param name="vid">An index for the item of interest.</param>
            <param name="value">The property value.</param>
            <exception cref="T:Microsoft.SolverFoundation.Common.InvalidSolverPropertyException"></exception>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Solve(Microsoft.SolverFoundation.Services.ISolverParameters)">
            <summary> 
            Run the solver with one SolverParam.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Solve(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams[])">
            <summary> Run the solver with one thread per SolverParam.
            </summary>
            <param name="parameters"> The parameters to apply to the threads </param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.ToString">
            <summary>Returns a string representation of the solver.
            </summary>
            <returns>Returns a string representation of the solver.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.InitIPM">
            <summary> Fill our data structures from the given problem
            </summary>
            <returns> false iff the model is found to be infeasible, typically by PreSolve </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.IsComplete(Microsoft.SolverFoundation.Services.LinearResult)">
            <summary>
            Checks whether the solver ran until it got a final result, i.e., it
            was not interrupted during the solve process.
            </summary>
            <param name="result">The result.</param>
            <returns>True if the solver ran to completion; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.SetIntegrality(System.Int32,System.Boolean)">
            <summary>InteriorPointSolver does not support integer variables
            </summary>
            <param name="vid">a variable index </param>
            <param name="fInteger">whether to be an integer variable</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetSolvedGoal(System.Int32,System.Object@,System.Int32@,System.Boolean@,System.Boolean@)">
            <summary> Get the information of a solved goal
            </summary>
            <param name="igoal"> 0 &lt;= goal index &lt; SolvedGoalCount </param>
            <param name="key">the goal row key</param>
            <param name="vid">the goal row vid</param>
            <param name="fMinimize">whether the goal is minimization</param>
            <param name="fOptimal">whether the goal is optimal</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetSolutionValue(System.Int32)">
            <summary>
            get the objective value of a goal 
            </summary>
            <param name="goalIndex">goal id</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.InitializeLogging">
            <summary>
            Initializes the logging framework.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.AddListener(System.Diagnostics.TraceListener,Microsoft.SolverFoundation.Common.LogIdSet)">
            <summary>
            Add tracing listener 
            </summary>
            <param name="listener">a listener</param>
            <param name="ids">interested events</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.RemoveListener(System.Diagnostics.TraceListener)">
            <summary>
            Remove tracing listener
            </summary>
            <param name="listener">a listener</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetReport(Microsoft.SolverFoundation.Services.LinearSolverReportType)">
            <summary> Get sensitivity report  
            </summary>
            <param name="reportType">simplex report type</param>
            <returns>a linear solver report</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Shutdown">
            <summary> Shutdown the solver instance
            </summary>
            <remarks>Solver needs to dispose any unmanaged memory used upon this call.</remarks>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetReport(Microsoft.SolverFoundation.Services.SolverContext,Microsoft.SolverFoundation.Services.Solution,Microsoft.SolverFoundation.Services.SolutionMapping)">
            <summary>Generate a report
            
            </summary>
            <param name="context"></param>
            <param name="solution"></param>
            <param name="solutionMapping"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">Row vid.</param>
            <returns>
            Returns the dual value.  If the constraint has both upper and lower bounds
            then there are actually two dual values.  In this case the dual for the active bound (if any) will be returned.
            If the model has not been solved then the result is indeterminate.
            </returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Microsoft#SolverFoundation#Services#ILinearSolverSensitivityReport#GetObjectiveCoefficientRange(System.Int32)">
            <summary> Get the coefficient range on the first goal row.
            </summary>
            <param name="vid">A variable vid.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Microsoft#SolverFoundation#Services#ILinearSolverSensitivityReport#GetObjectiveCoefficientRange(System.Int32,System.Int32)">
            <summary> Get the coefficient range for a goal row.
            </summary>
            <param name="vid">A variable vid.</param>
            <param name="pri">The goal index.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Microsoft#SolverFoundation#Services#ILinearSolverSensitivityReport#GetVariableRange(System.Int32)">
            <summary> Get the variable range.  
            </summary>
            <param name="vid">A variable vid.</param>
            <returns>A LinearSolverSensitivityRange object.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.IsInteriorPoint">
            <summary> Are we using Interior Point instead of Simplex?
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Parameters">
            <summary> Parameters select options for solving and metods for
                      reporting events and checking on Abort.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Statistics">
            <summary> IPM algorithm solution metrics.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.SolutionQuality">
            <summary>
            indicates the quality level of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.LpResult">
            <summary>
            indicates the result of solving the LP relaxation, which is essentially the model with its integrality conditions ignored
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.MipResult">
            <summary>
            indicates the result of considering the integrality conditions
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.MipBestBound">
            <summary> No MIP support
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Gap">
            <summary> solution gap 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Result">
            <summary>
            indicates the result of the solve attempt
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.SolvedGoalCount">
            <summary>
            goal count
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Microsoft#SolverFoundation#Solvers#IInteriorPointStatistics#RowCount">
            <summary> Total number of rows in reduced model.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.VarCount">
            <summary> Total number of variables, user and slack.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Primal">
            <summary> The primal version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Dual">
            <summary> The dual version of the objective.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Microsoft#SolverFoundation#Solvers#IInteriorPointStatistics#Gap">
            <summary> The kind of IPM algorithm used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.Algorithm">
            <summary> The kind of IPM algorithm used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolver.KktForm">
            <summary> The form of KKT matrices used.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams">
            <summary>
            Parameters used by the interior point solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.#ctor">
            <summary> Create a new instance.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.#ctor(Microsoft.SolverFoundation.Services.Directive)">
            <summary> Create a new instance from a Directive.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.#ctor(System.Func{System.Boolean})">
            <summary> Create a new instance.
            </summary>
            <param name="fnQueryAbort">A callback delegate.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.#ctor(Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary> Copy constructor. 
            </summary>
            <param name="parameters">An InteriorPointSolverParams object.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.ShouldAbort">
            <summary> Callback on whether the solver should abort execution.
            </summary>
            <returns>True if the solver should stop, False otherwise.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.NotifyStartSolve(System.Int32)">
            <summary> Callback before the solve starts.
            </summary>
            <param name="threadIndex">simplex thread id</param>
            <returns>Return code is not used.</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.FillInSolverParams(Microsoft.SolverFoundation.Services.Directive)">
            <summary>
            Fill in InteriorPointSolverParams based on the InteriorPointMethodDirective instance passed in.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.QueryAbort">
            <summary> Callback for ending the solve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.Solving">
            <summary> Callback called during solve.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.IterationStartedCallback">
            <summary> Callback for the start of each iteration.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.Abort">
            <summary> Indicates that the solver should stop.  The value is sticky.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.IpmAlgorithm">
            <summary> Choose an IPM algorithm. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.IpmKKT">
            <summary> Get or set the form of KKT matrix arithmetic to be used.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.KindOfSolver">
            <summary> Choose a solver. 
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.SymbolicOrdering">
            <summary> The type of matrix ordering to apply.
            -1 means automatic, 0 is minimum fill, 1 is AMD.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.MaxDenseColumnRatio">
            <summary>
            If the matrix becomes dense we can switch algorithms in some places for more speed,
               a tradeoff against space.  This portion of the matrix is the "dense window".
               The start of the dense window is the first column that has at least this
               percentage of nonzeroes.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.PresolveLevel">
            <summary> The level of presolve the IPM solver will apply.
            -1 means default or automatic, 0 means no presolve, >0 full.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.MaxIterationCount">
            <summary> The maximum number of iterations. If negative, no limit.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.SolveTolerance">
            <summary> Solve tolerance (gap, primal, dual).
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.ThreadCountLimit">
            <summary>Set the maximum threads to use in algebra.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams.DebugIteration">
            <summary>Print debug information for a specific iteration.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointAlgorithmKind">
            <summary> Select the interior point method algorithm.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointAlgorithmKind.PredictorCorrector">
            <summary> Mehrohtra style central path predictor-corrector
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointAlgorithmKind.HSD">
            <summary> Homogeneous Self Dual form has advantages of feasibility certification
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointAlgorithmKind.SOCP">
            <summary> SOCP solver (also HSD).
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointAlgorithmKind.MKL">
            <summary> Undocumented test
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointKktForm">
            <summary> Select the form of KKT matrix arithmetic to be used.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointKktForm.Normal">
            <summary> Normal form is faster, but will be ignored for non-diagonal quadratics.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointKktForm.Augmented">
            <summary> Augmented form is more robust and general, but a little slower.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.InteriorPointKktForm.Blended">
            <summary> A blend of augmented matrix containing an embedded normal section.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.StandardSolution">
            <summary> Data structure that specifies solution for standard LP model
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.x">
            <summary> primal variables, A·x = b
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.y">
            <summary> dual variables, A'·y + z = c
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.z">
            <summary> dual slacks, A'·y + z = c
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.cx">
            <summary> costs, primal: minimize c·x, dual: A'·y + z = c
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.by">
            <summary> RHS, primal: A·x = b, dual: maximize b·y
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.status">
            <summary> the result of the solve
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.relGap">
            <summary> relative gap (cx-by)/(1+cx)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.relPrmlFeas">
            <summary> relative primal feasibility ||A*x-b||/(1+||b||)
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.StandardSolution.relDualFeas">
            <summary> relative dual feasibility ||c-A'*y-z||/(1+||c||)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.PresolveResult">
            <summary> Encapsulates presolve results.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.InteriorPointSolveState">
            <summary> The current IPM solution state.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.ConicStructure">
            <summary> Conic inequality structure.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.ConicStructure.#ctor(Microsoft.SolverFoundation.Solvers.ConicStructure)">
            <summary>Create a new instance.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SocpFactor">
            <summary>Solves the augmented system for SOCP.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SocpFactor.#ctor(Microsoft.SolverFoundation.Common.SparseMatrixDouble,System.Func{System.Boolean},Microsoft.SolverFoundation.Common.FactorizationParameters)">
            <summary>Create a new instance.
            </summary>
            <param name="M">The coefficient matrix.</param>
            <param name="CheckAbort">CheckAbort.</param>
            <param name="factorParam">Factorization parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SocpFactor.SetLinearSystemDiagonals(Microsoft.SolverFoundation.Common.Vector,Microsoft.SolverFoundation.Common.Vector,System.Double[],System.Double[],System.Collections.Generic.List{Microsoft.SolverFoundation.Common.Vector},System.Collections.Generic.List{Microsoft.SolverFoundation.Common.Vector},System.Int32)">
            <summary>Set the diagonal values of the augmented system.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SocpLinearSystem">
            <summary> Creates the augmented system for SOCP.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD">
            <summary>SOCP solver using homogeneous and self-dual model.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.CheckAbort">
            <summary> This async callback returns true if a task needs to be stopped,
                      for example by timeout, or if an exception in one thread needs
                      to stop all the others.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.Solving">
            <summary> Solving callback.
            </summary>
        </member>
        <member name="F:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.IterationStartedCallback">
            <summary>Called at the start of each iteration.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.#ctor(Microsoft.SolverFoundation.Solvers.InteriorPointSolver,Microsoft.SolverFoundation.Common.LogSource,Microsoft.SolverFoundation.Solvers.InteriorPointSolverParams)">
            <summary>Create a new instance.
            </summary>
            <param name="solver">The SecondOrderConicModel containing user data.</param>
            <param name="log">The LogSource.</param>
            <param name="prm">Solver parameters.</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.EmptySolution">
            <summary> Indicates whether there are any decision variables.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.GetDualValue(System.Int32)">
            <summary> Return the dual value for a row constraint.
            </summary>
            <param name="vidRow">Row vid.</param>
            <returns>The dual value.</returns>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.RowCount">
            <summary>Row count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.VarCount">
            <summary>Variable count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.IterationCount">
            <summary>Iteration count.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.Gap">
            <summary>Duality gap.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.Algorithm">
            <summary>The algorithm kind.
            </summary>
        </member>
        <member name="P:Microsoft.SolverFoundation.Solvers.SOCPSolverHSD.KktForm">
            <summary>The KKT formulation used by the algorithm.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.Symbol">
            <summary> Symbol is the class for a symbolic variable and is also the base type for
                      all more specialized symbols.  Each has the characteristics:
              Name and Scope,
              ParseInfo - precedence and infix operator information,
              Attributes - a set of attributes,
              Rules - a list of rules like F[x_,y_],
              and Id - a unique integer useful for debugging.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.ExcelInputTypeSymbol">
            <summary>
            For now, this is the only type we support
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.ExcelOutputsymbol">
            <summary>
            Uses for two places
            1. As first sun of model section, just with one arguments (string for the BindOut for all model)
            2. As sum of Variables section, two arguments (var and string for the dataout)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.PlacementInfo">
            <summary>
            Gives information about the original placement of the expression 
            in the file
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.Invocation.Context">
            <summary> thread continuation  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.ForeachSymbol.Generate(Microsoft.SolverFoundation.Rewrite.InvocationBuilder,Microsoft.SolverFoundation.Rewrite.IterInfo[],System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression},System.Int32,Microsoft.SolverFoundation.Rewrite.Substitution)">
            <summary>
            Generate each element of the foreach.
            </summary>
            <param name="ib">The InvocationBuilder containing the Foreach arguments</param>
            <param name="rgii">A list of IterInfos which the iterator expressions will be parsed into</param>
            <param name="rgexpr">A List to put the results into</param>
            <param name="iii">The index of the IterInfo being iterated over at this level</param>
            <param name="sub">A substitution containing the values of the iterators so far</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.FilteredForeachSymbol.Generate(Microsoft.SolverFoundation.Rewrite.InvocationBuilder,Microsoft.SolverFoundation.Rewrite.IterInfo[],System.Collections.Generic.List{Microsoft.SolverFoundation.Rewrite.Expression},System.Int32,Microsoft.SolverFoundation.Rewrite.Substitution)">
            <summary>
            Generate each element of the foreach.
            </summary>
            <param name="ib">The InvocationBuilder containing the Foreach arguments</param>
            <param name="rgii">A list of IterInfos which the iterator expressions will be parsed into</param>
            <param name="rgexpr">A List to put the results into</param>
            <param name="iii">The index of the IterInfo being iterated over at this level</param>
            <param name="sub">A substitution containing the values of the iterators so far</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.MathMLVisitor">
            <summary>
            Implements a visitor which produces MathML.  
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.MathMLVisitor.Visit(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary>
            Main entry point for visiting a model and producing MathML output.
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.RecourseSymbol">
            <summary>Recourse decisions.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.InputSectionSymbol">
            <summary>Define input (data binding)
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.ParametersSymbol">
            <summary>Define parameters with data binding
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.Sos2Symbol">
            <summary>
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteSystem.IsNull(Microsoft.SolverFoundation.Rewrite.Expression)">
            <summary> Check for null expression
            </summary>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.RewriteSystem.ApplyRuleSet(Microsoft.SolverFoundation.Rewrite.Expression,Microsoft.SolverFoundation.Rewrite.Invocation,System.Int32@)">
            <summary>
            If no rule applied, this returns exprSrc and sets irule to -1. If rules is a single rule
            that applies, irule is set to 0. This asserts that the rule set is valid.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.Substitution">
            <summary> Implement small mappings (few variables). It uses linear search
            to resolve the mappings.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SetBaseSymbol">
            <summary>
            This and SetDelayed are almost identical. SetDelayed has HoldAll while Set has HoldFirst.
            SetDelayed returns Null when successful and this returns the rhs.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SetSymbol">
            <summary>
            This and SetDelayed are almost identical. SetDelayed has HoldAll while Set has HoldFirst.
            SetDelayed returns Null when successful and this returns the rhs.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.BaseSolveSymbol">
            <summary>
            This is the base type for all Symbols in the "BuiltinSolveSymbols".
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SimplexSolverSymbol">
            <summary>
            Symbol for the Simplex solver. A simplex solver can be created from an MPS file, a model or another simplex solver.
            
            Arguments: A series of MPS symobl, Model symbol or SimplexSolver symbol. If options are used, the symbols are put in a list
            as the first element. Further elements are options.
            
            Returns a SimplexSolver symbol.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SimplexSolverSymbol.MergeMps(Microsoft.SolverFoundation.Rewrite.SimplexSolverWrapper,Microsoft.SolverFoundation.Rewrite.Invocation,System.Func{System.Object,Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Merges an MPS file into a simplex solver.
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SimplexSolverSymbol.MergeLinearModels(Microsoft.SolverFoundation.Rewrite.RewriteSystem,Microsoft.SolverFoundation.Services.ILinearModel,Microsoft.SolverFoundation.Services.ILinearModel,System.Func{System.Object,Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Merges two linear models.
            The keys for source rows and source variables are sent to the mapper which transforms them into destination keys.
            If a destination key already exists, we log a warning and continue merging the models.
            The goals are merged in order (first goal with first goal and so on down the list of rows).
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SimplexSolverSymbol.CopyRow(Microsoft.SolverFoundation.Rewrite.RewriteSystem,Microsoft.SolverFoundation.Services.ILinearModel,Microsoft.SolverFoundation.Services.ILinearModel,System.Object,System.Func{System.Object,Microsoft.SolverFoundation.Rewrite.Expression})">
            <summary>
            Copies a row from the source model into the destination models. 
            The row to copy is identified by its key.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.MpsSymbol">
            <summary>
            Symbol for MPS files.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SsGetKeysSymbol">
            <summary>
            Gets the variable/row/goal keys.
            Arguments are: a simplex solver. 
            The result is a sequence of keys.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SsGetValuesSymbol">
            <summary>
            Gets the values/bounds of the variables/rows.
            Arguments are: a simplex solver, and optional keys.
            If no keys are specified, the values of all variables/rows are returned.
            Otherwise only the values of the specified variables/rows are returned.
            If a key is invalid, the expression is not reduced.
            The result is a list of rules with first argument the key and second argument the value.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SsSetValuesSymbol">
            <summary>
            Sets the value/bounds of variables.
            Arguments are: a simplex solver, a series of rules mapping keys to values/bounds. 
            If a variable key is not correct, the entry is not reduced.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.GetCoefsSymbol">
            <summary>
            Sets the coefficient of a variable in a row.
            Arguments are: a simplex solver, followed by any number of rules: { row, var } -> coef. 
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SetCoefsSymbol">
            <summary>
            Sets the coefficient of a variable in a row.
            Arguments are: a simplex solver, followed by any number of rules: { row, var } -> coef. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SolveRewriteSystem.#ctor(System.Action{Microsoft.SolverFoundation.Services.ValueTableAdapter,System.String,System.String[]},System.Action{System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,Microsoft.SolverFoundation.Common.Rational}}})">
            <summary>
            
            </summary>
            <param name="excelBindParamDel">delegate with takes ValueTable, address as string(for the excel table/range) and array of keys 
            which is used for table binding</param>
            <param name="excelBindOutDel">M5 symtax</param>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SolveRewriteSystem.#ctor(System.Action{Microsoft.SolverFoundation.Services.ValueTableAdapter,System.String,System.String[]})">
            <summary>
            
            </summary>
            <param name="excelBindParamDel">delegate with takes ValueTable, address as string(for the excel table/range) and array of keys 
            which is used for table binding</param>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.OmlTimedSimplexParams">
            <summary>
            Params which should be used temporarily from OML
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.OmlTimedSimplexParams.Reset">
            <summary>
            Reset any state that changed. The TimedParams is about to be re-used.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.OmlTimedIPMParams">
            <summary>
            Params which should be used temporarily from OML
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.OmlTimedIPMParams.Reset">
            <summary>
            Reset any state that changed. The TimedParams is about to be re-used.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.SolveSymbol">
            <summary>
            Solves a model.
            
            Arguments: the model to solve, a series of optional options. 
            </summary>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SolveSymbol.GetValueForModelType(System.String,System.Collections.Generic.Dictionary{System.String,Microsoft.SolverFoundation.Rewrite.Expression},Microsoft.SolverFoundation.Rewrite.SolveSymbol.ModelType)">
            <summary>
            look up in the dictinary with the prefix of the model
            </summary>
            <param name="key"></param>
            <param name="mpstrexprOpt"></param>
            <param name="model"></param>
            <returns>if the key exists return the value, otherwise empty string</returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SolveSymbol.IsRelevantForModelType(System.String@,Microsoft.SolverFoundation.Rewrite.SolveSymbol.ModelType[])">
            <summary>
            Check the initial of parameter to see if it is relevant to model
            if yes, it cuts the string to the clean parameter
            </summary>
            <param name="parameter"></param>
            <param name="models"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.SolverFoundation.Rewrite.SolveSymbol.TryParseOption(Microsoft.SolverFoundation.Rewrite.RewriteSystem,Microsoft.SolverFoundation.Rewrite.Expression,System.String@,Microsoft.SolverFoundation.Rewrite.Expression@)">
            <summary>
            Parses options given in the form of rules OptionName -> Value. If only the OptionName is specified, 
            the Value is assumed to be True.
            </summary>
        </member>
        <member name="T:Microsoft.SolverFoundation.Rewrite.WriteMpsSymbol">
            <summary> Writes the content of a model as MPS. 
            Arguments: A model or a simplex solver, an optional boolean indicating whether to use fixed format (true) or not (false).
            The format defaults to fixed.
            </summary>
        </member>
    </members>
</doc>
